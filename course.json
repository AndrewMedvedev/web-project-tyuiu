{
  "id": "edd3851d-be9b-4ed4-8084-c37d55176702",
  "created_at": "2026-02-15T10:20:54.663604+03:00",
  "creator_id": 123,
  "status": "generated",
  "image_url": null,
  "title": "Сценарий курса: Инженерия программного обеспечения",
  "description": "Модульный сценарий курса для студентов 3 курса IT-направлений, построенный на основе интервью с экспертом и методических принципов. Курс охватывает 14 недель, включает теорию, практику, кейсы и финальный проект. Акцент сделан на системное мышление, архитектурные компромиссы, документирование и командную работу.",
  "learning_objectives": [
    "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
    "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
    "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
    "Применять архитектурные паттерны и обосновывать их выбор.",
    "Документировать архитектурные решения по шаблону C4.",
    "Разрабатывать стратегию тестирования, включая нефункциональные аспекты.",
    "Оценивать качество ПО и управлять техническим долгом.",
    "Работать в команде, использовать инструменты трассируемости и управления изменениями."
  ],
  "modules": [
    {
      "id": "e11a0aaf-2bb4-4233-be14-9470d9637c86",
      "title": "Модуль 0: Введение в инженерию ПО",
      "description": "Этот модуль знакомит студентов с основами инженерии программного обеспечения как дисциплины, лежащей на стыке технических, организационных и управленческих аспектов разработки ПО. Студенты освоят ключевые понятия, принципы и жизненный цикл разработки, поймут, чем инженерия ПО отличается от программирования, и научатся мыслить системно. Модуль закладывает фундамент для последующего изучения проектирования, управления требованиями, архитектуры и качества ПО.",
      "learning_objectives": [
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
        "Применять архитектурные паттерны и обосновывать их выбор.",
        "Документировать архитектурные решения по шаблону C4.",
        "Разрабатывать стратегию тестирования, включая нефункциональные аспекты.",
        "Оценивать качество ПО и управлять техническим долгом.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 0,
      "content_blocks": [
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Введение: что такое инженерия ПО?\n\n**Инженерия программного обеспечения (Инжиниринг ПО)** — это систематический, дисциплинированный и измеримый подход к разработке, эксплуатации и сопровождению программного обеспечения. В отличие от программирования, которое сосредоточено в основном на написании кода, инженерия ПО охватывает весь жизненный цикл создания программного продукта: от формулировки требований и проектирования до тестирования, внедрения, сопровождения и вывода из эксплуатации.\n\n#### Отличие от программирования\n\n| Аспект | Программирование | Инженерия ПО |\n|--------|------------------|-------------|\n| Фокус | Написание кода, реализация функций | Весь жизненный цикл ПО: анализ, проектирование, тестирование, управление требованиями, документирование |\n| Масштаб | Часто задачи небольшого объёма | Крупные, сложные системы, командная разработка |\n| Подход | Творческий, индивидуальный | Системный, стандартизированный, управляемый |\n| Результат | Работающий код | Надёжное, масштабируемое, поддерживаемое и безопасное ПО |\n\nТаким образом, программирование — это лишь один из этапов в рамках инженерии ПО.\n\n#### Почему нужна системность в разработке ПО?\n\nСовременные программные системы — это сложные продукты, включающие множество компонентов, взаимодействующих между собой и с внешними системами. Без системного подхода:\n\n- сложно управлять требованиями,\n- возрастает риск ошибок,\n- нарушается согласованность архитектуры,\n- увеличивается технический долг,\n- снижается качество и надёжность продукта.\n\nСистемность позволяет:\n\n- планировать и контролировать процесс разработки,\n- обеспечивать трассируемость решений,\n- управлять изменениями,\n- гарантировать качество на всех этапах,\n- эффективно работать в команде.\n\n#### Примеры провалов из-за отсутствия инженерного подхода\n\n**1. Therac-25 (1985–1987)**\n\nTherac-25 — это медицинский ускоритель частиц для лучевой терапии, который из-за ошибок в программном обеспечении привёл к смерти нескольких пациентов. Причина катастрофы:\n\n- Отсутствие системного тестирования и анализа рисков,\n- Использование устаревшего кода без адекватной модернизации,\n- Нет обработки ошибок и отсутствие аппаратных предохранителей,\n- Race condition в многопоточном коде приводила к передозировке облучения.\n\nЭтот случай стал классическим примером того, как пренебрежение инженерными практиками может стоить человеческих жизней.\n\n**2. Knight Capital Group (2012)**\n\nАмериканская финансовая компания потеряла **440 миллионов долларов** за 45 минут из-за ошибки в программном обеспечении торговой системы.\n\nПричина:\n\n- В продакшен был задеплоен неактивный, но неудалённый код,\n- Новый механизм запуска активировал старый модуль, который начал массово размещать ордера по некорректным ценам,\n- Отсутствовала система тестирования изменений в продакшене,\n- Не было контроля за техническим долгом и устаревшим кодом.\n\nКомпания чуть не обанкротилась, а инцидент стал поворотной точкой в осознании важности управления конфигурациями и процессами развёртывания в инженерии ПО.\n\n> Эти примеры показывают, что программирование — это не просто написание кода. Это ответственность. Инженерия ПО обеспечивает эту ответственность через структуру, дисциплину и системный подход."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "Инженерия программного обеспечения (ПО) — это систематический и дисциплинированный подход к разработке, эксплуатации и сопровождению программных систем. В отличие от простого программирования, который сосредоточен на написании кода, инженерия ПО охватывает весь жизненный цикл продукта и опирается на ряд фундаментальных принципов, обеспечивающих создание надёжных, эффективных и поддерживаемых систем. Ключевыми из них являются **предсказуемость, воспроизводимость, управляемость, качество и масштабируемость**.\n\n### 1. Предсказуемость\nПредсказуемость означает способность заранее оценивать поведение системы, сроки выполнения задач и риски в процессе разработки. Это достигается за счёт:\n- чёткого планирования и оценки трудозатрат;\n- использования методик управления проектами (например, Agile, Waterfall);\n- регулярного мониторинга прогресса и отклонений от плана.\n\nПредсказуемость позволяет командам избегать «эффекта лавины» — когда небольшие задержки приводят к критическим срывам сроков. Она особенно важна при работе с заказчиками, которым необходимо понимать, когда будет готов продукт и сколько это будет стоить.\n\n### 2. Воспроизводимость\nВоспроизводимость — это возможность получить идентичный результат при повторении процесса разработки или запуска системы. В контексте инженерии ПО это включает:\n- использование систем контроля версий (например, Git);\n- автоматизацию сборки, тестирования и развёртывания (CI/CD);\n- описания окружений в коде (Infrastructure as Code, например, с помощью Docker, Terraform).\n\nВоспроизводимость гарантирует, что приложение будет работать одинаково на разных машинах и в разных средах (разработка, тестирование, продакшн), что снижает количество ошибок, связанных с «у меня же работало».\n\n### 3. Управляемость\nУправляемость означает возможность контролировать все аспекты разработки: процессы, команду, изменения в коде и требования. Она обеспечивается через:\n- чёткую структуру команды и распределение ролей;\n- процессы управления изменениями (change management);\n- инструменты трассировки требований (от бизнес-цели до строки кода);\n- использование систем управления задачами (Jira, Trello и др.).\n\nУправляемость позволяет быстро реагировать на изменения, минимизировать хаос в проекте и поддерживать прозрачность для всех участников.\n\n### 4. Качество\nКачество ПО — это не просто отсутствие багов, а совокупность характеристик, таких как надёжность, производительность, безопасность, удобство использования и поддерживаемость. Обеспечение качества включает:\n- написание тестов (модульных, интеграционных, сквозных);\n- код-ревью и статический анализ кода;\n- регулярное рефакторинг и управление техническим долгом;\n- оценку нефункциональных требований (например, время отклика, отказоустойчивость).\n\nКачество закладывается на всех этапах жизненного цикла, а не проверяется только на финальной стадии.\n\n### 5. Масштабируемость\nМасштабируемость — это способность системы эффективно справляться с ростом нагрузки (пользователей, данных, транзакций) за счёт добавления ресурсов. Она бывает:\n- **вертикальной** — увеличение мощности одного сервера;\n- **горизонтальной** — добавление новых узлов в систему.\n\nМасштабируемость достигается за счёт правильной архитектуры (например, микросервисы, балансировка нагрузки, кэширование), а также проектирования с учётом будущего роста.\n\n---\n\nЭти принципы тесно связаны между собой и взаимодополняют друг друга. Например, воспроизводимость способствует предсказуемости, а управляемость помогает поддерживать качество. Вместе они формируют основу профессионального подхода к созданию программного обеспечения, превращая разработку из «творческого хаоса» в инженерную дисциплину."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Жизненный цикл программного обеспечения\n\nЖизненный цикл программного обеспечения (ЖЦ ПО) — это структурированный процесс, охватывающий все этапы создания, эксплуатации и вывода из употребления программной системы. Он обеспечивает системный подход к разработке, помогает управлять сложностью проектов, контролировать качество и минимизировать риски. Ниже приведены основные этапы жизненного цикла ПО:\n\n1. **Идея (Инициация)**  \n   На этом этапе формируется концепция будущей системы. Определяется бизнес-потребность, цель разработки, потенциальные пользователи и ожидаемая ценность продукта. Результат — предварительное обоснование проекта (бизнес-кейс), которое помогает принять решение о его запуске.\n\n2. **Анализ требований**  \n   На этом этапе собираются и анализируются требования к системе. Выделяют:\n   - **Функциональные требования** — что система должна делать.\n   - **Нефункциональные требования** — как система должна себя вести (производительность, безопасность, удобство использования и т.д.).\n   Результат — документ спецификации требований, который служит основой для проектирования.\n\n3. **Проектирование**  \n   На основе требований разрабатывается архитектура системы и детальные проектные решения. Определяются:\n   - Структура системы (модули, компоненты, взаимодействия).\n   - Технологический стек.\n   - Интерфейсы (пользовательские и программные).\n   - Базы данных и интеграции.\n   Результат — архитектурная документация, диаграммы, модели.\n\n4. **Реализация (разработка)**  \n   Программисты пишут код в соответствии с проектными решениями. На этом этапе применяются принципы чистого кода, контроль версий, код-ревью и автоматизация сборки. Результат — рабочая версия программного продукта.\n\n5. **Тестирование**  \n   Проверка корректности работы системы. Проводятся различные виды тестирования:\n   - Модульное (unit-тесты).\n   - Интеграционное.\n   - Системное.\n   - Приёмочное.\n   - Тестирование производительности, безопасности и т.д.\n   Цель — выявить и устранить дефекты до выхода продукта в эксплуатацию.\n\n6. **Развёртывание (внедрение)**  \n   Система устанавливается в производственную среду и становится доступной пользователям. Может включать миграцию данных, настройку окружения, обучение пользователей. Современные подходы (CI/CD) позволяют автоматизировать развёртывание и обеспечивать его регулярность.\n\n7. **Сопровождение**  \n   После запуска система требует поддержки: устранение ошибок, обновление функциональности, адаптация к новым условиям. На этом этапе также собирается обратная связь от пользователей для улучшения продукта.\n\n8. **Вывод из эксплуатации**  \n   Когда система устаревает, становится неподдерживаемой или заменяется новой, она постепенно отключается. Этот этап включает архивирование данных, уведомление пользователей и безопасное удаление компонентов.\n\nКаждый из этапов жизненного цикла может быть организован в рамках различных моделей разработки (каскадная, итеративная, Agile и др.), но сама структура остаётся универсальной и применимой к любым проектам в инженерии ПО."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Модели жизненного цикла разработки ПО\n\nЖизненный цикл разработки программного обеспечения (ПО) — это структура, описывающая все этапы создания и сопровождения ПО: от инициации идеи до вывода из эксплуатации. Выбор модели жизненного цикла напрямую влияет на организацию процесса разработки, управление проектом, качество продукта и удовлетворённость заказчика. Ниже рассмотрены наиболее распространённые модели, их особенности, преимущества, недостатки и области применения.\n\n### 1. Каскадная модель (Waterfall)\n\n**Описание**: Линейная модель, в которой этапы (анализ требований, проектирование, реализация, тестирование, внедрение, сопровождение) выполняются последовательно, один за другим. Переход к следующему этапу возможен только после полного завершения предыдущего.\n\n**Плюсы**:\n- Простота управления и планирования.\n- Чёткая документация на каждом этапе.\n- Подходит для проектов с чётко определёнными и стабильными требованиями.\n\n**Минусы**:\n- Низкая гибкость: изменения требований на поздних этапах очень дороги.\n- Позднее выявление ошибок.\n- Конечный продукт доступен только в конце проекта.\n\n**Область применения**: Проекты с низкой неопределённостью, например, в аэрокосмической, оборонной или медицинской отраслях, где требуется строгая документация и соответствие стандартам.\n\n### 2. Итеративная модель (Iterative)\n\n**Описание**: Процесс разработки разбивается на повторяющиеся циклы (итерации). На каждой итерации создаётся улучшенная версия продукта, начиная с базовой версии.\n\n**Плюсы**:\n- Возможность постепенного улучшения продукта.\n- Раннее выявление рисков.\n- Гибкость в управлении требованиями.\n\n**Минусы**:\n- Требует хорошего управления архитектурой, чтобы избежать накопления технического долга.\n- Может быть сложно оценить сроки завершения проекта.\n\n**Область применения**: Проекты с частично определёнными требованиями, где важно постепенно уточнять функциональность.\n\n### 3. Инкрементная модель (Incremental)\n\n**Описание**: Продукт разбивается на части (инкременты), каждая из которых доставляется заказчику как завершённый функционал. Каждый инкремент проходит все этапы жизненного цикла.\n\n**Плюсы**:\n- Ранняя доставка частей продукта.\n- Возможность получения обратной связи от заказчика.\n- Лучшее управление рисками по сравнению с каскадной моделью.\n\n**Минусы**:\n- Требует чёткого планирования архитектуры с самого начала.\n- Интеграция инкрементов может быть сложной.\n\n**Область применения**: Проекты, где можно логически разбить функционал на независимые части (например, CRM-системы, интернет-магазины).\n\n### 4. Спиральная модель (Spiral)\n\n**Описание**: Комбинирует итеративный подход с элементами каскадной модели и акцентом на управлении рисками. Каждый виток спирали включает планирование, анализ рисков, разработку и оценку.\n\n**Плюсы**:\n- Сильный акцент на управлении рисками.\n- Подходит для крупных и сложных проектов.\n- Высокая гибкость.\n\n**Минусы**:\n- Сложность в управлении и необходимости экспертизы в оценке рисков.\n- Высокая стоимость.\n\n**Область применения**: Крупные, критически важные проекты с высокой степенью неопределённости и рисками (например, банковские системы, телеком).\n\n### 5. V-Model (V-Shaped Model)\n\n**Описание**: Расширение каскадной модели, в которой каждому этапу разработки ставится в соответствие этап тестирования. Например, анализу требований соответствует приёмочное тестирование.\n\n**Плюсы**:\n- Раннее планирование тестов.\n- Высокое качество за счёт строгого соответствия.\n- Подходит для проектов с жёсткими требованиями к безопасности.\n\n**Минусы**:\n- Низкая гибкость.\n- Сложность внесения изменений.\n\n**Область применения**: Проекты в регулируемых отраслях (медицинское ПО, транспорт, оборона), где требуется доказательство корректности системы.\n\n### 6. Гибкие модели (Agile)\n\nAgile — это не одна модель, а подход, основанный на итеративной и инкрементной разработке с акцентом на сотрудничество, гибкость и быструю доставку ценности заказчику. Наиболее популярные фреймворки:\n\n#### Scrum\n- Работа организована в спринты (обычно 2–4 недели).\n- Роли: Scrum Master, Product Owner, Команда.\n- Артефакты: Product Backlog, Sprint Backlog, Increment.\n- Ежедневные стендапы, планирование спринтов, ретроспективы.\n\n**Плюсы**: Высокая адаптивность, прозрачность, вовлечённость заказчика.\n**Минусы**: Требует зрелой команды и активного участия заказчика.\n**Применение**: Веб-приложения, стартапы, проекты с изменяющимися требованиями.\n\n#### Kanban\n- Визуализация потока работ (доска с колонками).\n- Ограничение количества задач в работе (WIP).\n- Непрерывная доставка.\n\n**Плюсы**: Гибкость, прозрачность, оптимизация потока.\n**Минусы**: Меньше структуры по сравнению с Scrum.\n**Применение**: Поддержка и сопровождение ПО, команды эксплуатации, DevOps.\n\n### Сравнительная таблица моделей\n\n| Модель       | Гибкость | Управление рисками | Сложность | Обратная связь | Лучше всего подходит для |\n|--------------|----------|--------------------|-----------|----------------|---------------------------|\n| Waterfall    | Низкая   | Низкое             | Низкая    | Поздняя        | Стабильные требования     |\n| Iterative    | Средняя  | Среднее            | Средняя   | Средняя        | Уточнение архитектуры     |\n| Incremental  | Средняя  | Среднее            | Средняя   | Ранняя         | Разделение на модули      |\n| Spiral       | Высокая  | Высокое            | Высокая   | Регулярная     | Крупные рисковые проекты  |\n| V-Model      | Низкая   | Низкое             | Средняя   | Поздняя        | Критически важные системы |\n| Agile (Scrum)| Высокая  | Высокое            | Средняя   | Постоянная     | Динамичные проекты        |\n| Kanban       | Высокая  | Среднее            | Низкая    | Постоянная     | Непрерывная доставка      |\n\n### Заключение\nВыбор модели жизненного цикла зависит от множества факторов: характера проекта, степени неопределённости требований, размера команды, уровня рисков и ожиданий заказчика. Современные проекты всё чаще используют гибкие подходы или гибриды моделей (например, Waterfall для анализа и Agile для разработки). Важно понимать, что модель — это инструмент, а не догма, и её можно адаптировать под конкретные условия."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Роль инженера ПО в команде: взаимодействие с ключевыми участниками\n\nИнженер программного обеспечения (инженер ПО) — это центральная фигура в разработке качественного и надёжного продукта. В отличие от разработчика, который может сосредоточиться на написании кода, инженер ПО охватывает более широкую картину: от понимания потребностей заказчика до обеспечения стабильности и масштабируемости системы в продакшене. Его роль заключается в системном подходе к созданию ПО, а ключевым элементом успеха является эффективное взаимодействие со всеми участниками команды.\n\n#### Взаимодействие с заказчиком\nЗаказчик определяет, *что* нужно создать. Инженер ПО участвует в сборе и анализе требований, помогая трансформировать бизнес-идеи в технически реализуемые задачи. Он задаёт уточняющие вопросы, выявляет скрытые потребности и помогает сформулировать как функциональные (например, «пользователь может добавить товар в корзину»), так и нефункциональные требования (например, «система должна обрабатывать 1000 запросов в секунду»). Важная задача — управление ожиданиями: инженер объясняет технические ограничения и предлагает компромиссные решения.\n\n#### Взаимодействие с аналитиком\nБизнес-аналитик детализирует требования и готовит спецификации. Инженер ПО работает с ним, чтобы:\n- Проверить техническую осуществимость требований;\n- Уточнить логику поведения системы;\n- Оценить сложность реализации;\n- Внести предложения по улучшению архитектуры на ранних этапах.\n\nЭто тесное сотрудничество позволяет избежать ошибок проектирования и снизить риски появления технического долга.\n\n#### Взаимодействие с разработчиком\nИнженер ПО выступает в роли наставника и архитектора для разработчиков. Он:\n- Участвует в проектировании модулей и компонентов;\n- Рекомендует паттерны проектирования и технологии;\n- Проводит код-ревью с акцентом на архитектурные и качественные аспекты;\n- Помогает решать сложные технические задачи.\n\nПри этом инженер ПО не только указывает, *как* писать код, но и объясняет *почему* — формируя культуру осознанной разработки.\n\n#### Взаимодействие с тестировщиком\nКачество ПО — общая ответственность. Инженер ПО тесно сотрудничает с тестировщиками, чтобы:\n- Определить стратегию тестирования (модульное, интеграционное, нагрузочное);\n- Обеспечить тестируемость архитектуры (например, через слабую связанность);\n- Проанализировать дефекты не как ошибки разработки, а как сигналы о проблемах в проектировании;\n- Участвовать в построении автоматизированных тестов, особенно на уровне компонентов и интеграций.\n\nТакой подход позволяет выявлять архитектурные уязвимости на ранних стадиях.\n\n#### Взаимодействие с DevOps-инженером\nСовременный инженер ПО не может игнорировать процессы доставки и эксплуатации. Взаимодействие с DevOps включает:\n- Совместное проектирование CI/CD-пайплайнов;\n- Обеспечение готовности системы к мониторингу, логированию и трассировке;\n- Участие в построении инфраструктуры как кода (IaC);\n- Анализ инцидентов в продакшене и внесение изменений в архитектуру для повышения надёжности.\n\nИнженер ПО и DevOps вместе отвечают за то, чтобы система была не только функциональной, но и устойчивой, масштабируемой и легко разворачиваемой.\n\n#### Заключение\nРоль инженера ПО — это мост между бизнесом и технологиями, между проектированием и эксплуатацией. Успешный инженер обладает технической экспертизой, системным мышлением и навыками коммуникации. Он не работает в изоляции, а активно взаимодействует со всеми участниками процесса, обеспечивая целостность, качество и долгосрочную поддерживаемость программного продукта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Понятие требований: функциональные и нефункциональные требования\n\nТребования к программному обеспечению — это формализованные ожидания заказчика, пользователей и других заинтересованных сторон относительно того, что система должна делать и как она должна себя вести. Правильное определение и документирование требований — ключевой этап в жизненном цикле разработки ПО, поскольку именно от них зависит успех всего проекта.\n\n#### Функциональные требования\n\nФункциональные требования описывают, **что** должна делать система. Они определяют поведение программного обеспечения в ответ на определённые действия пользователя или внешние события. Эти требования, как правило, формулируются в виде сценариев использования (use cases) или пользовательских историй (user stories).\n\n**Примеры функциональных требований:**\n- Пользователь может войти в систему, используя логин и пароль.\n- Система должна позволять добавлять, редактировать и удалять товары в каталоге.\n- При оформлении заказа система должна проверять наличие товара на складе.\n\n**Пример из реальной системы:** В интернет-магазине (например, Wildberries) функциональное требование — «Пользователь может добавить товар в корзину и оформить заказ с выбором способа доставки и оплаты».\n\n#### Нефункциональные требования\n\nНефункциональные требования описывают **как** система должна выполнять свои функции. Они определяют качество, характеристики и ограничения системы. Эти требования часто касаются производительности, безопасности, надёжности, удобства сопровождения, масштабируемости и других атрибутов качества ПО.\n\nОсновные категории нефункциональных требований:\n\n1. **Производительность** — время отклика системы, пропускная способность, нагрузка.\n   - *Пример:* Система должна обрабатывать до 10 000 запросов в секунду с задержкой не более 200 мс.\n   - *Реальный пример:* Поисковая система Google должна возвращать результаты поиска менее чем за 0.5 секунды.\n\n2. **Безопасность** — защита данных, аутентификация, авторизация, защита от атак.\n   - *Пример:* Все передаваемые данные должны шифроваться с использованием TLS 1.3.\n   - *Реальный пример:* Банковское приложение (например, Сбербанк Онлайн) требует двухфакторной аутентификации и шифрования всех транзакций.\n\n3. **Удобство сопровождения (maintainability)** — лёгкость внесения изменений, исправления ошибок и обновления системы.\n   - *Пример:* Код должен быть покрыт модульными тестами на 80% и соответствовать стандартам кодирования.\n   - *Реальный пример:* Внутренние корпоративные системы (например, CRM-системы) должны поддерживать модульную архитектуру, чтобы можно было обновлять отдельные компоненты без пересборки всей системы.\n\n4. **Надёжность (reliability)** — способность системы работать без сбоев в течение заданного времени.\n   - *Пример:* Система должна обеспечивать доступность 99.9% в течение года (не более 8.76 часов простоя в год).\n\n5. **Масштабируемость (scalability)** — способность системы эффективно работать при увеличении нагрузки.\n   - *Пример:* Система должна поддерживать горизонтальное масштабирование для обработки роста числа пользователей.\n\n6. **Юзабилити (usability)** — удобство использования интерфейса.\n   - *Пример:* Новый пользователь должен быть способен выполнить базовые действия (например, регистрацию) без инструкций.\n\n#### Важность баланса между функциональными и нефункциональными требованиями\n\nЧасто разработчики сосредотачиваются только на функциональных требованиях, но игнорирование нефункциональных может привести к серьёзным проблемам: медленной работе, уязвимостям, высокой стоимости сопровождения. Например, даже если интернет-магазин позволяет покупать товары (функционально корректен), но работает медленно или теряет данные при сбоях, пользователи уйдут к конкурентам.\n\nТаким образом, качественная инженерия ПО требует всестороннего учёта как функциональных, так и нефункциональных требований на ранних этапах проекта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Введение в управление требованиями\n\nУправление требованиями — это ключевой процесс в инженерии программного обеспечения, обеспечивающий понимание того, *что* должно делать программное решение и *зачем*. Он охватывает систематический подход к выявлению, анализу, документированию, приоритизации и отслеживанию требований на протяжении всего жизненного цикла разработки. Эффективное управление требованиями снижает риски недопонимания, ошибок, перерасхода бюджета и провала проекта.\n\n#### Основные этапы управления требованиями\n\n1. **Сбор требований (Requirements Elicitation)**\n   На этом этапе команда взаимодействует с заинтересованными сторонами (стейкхолдерами) — заказчиками, пользователями, аналитиками, юристами и другими — чтобы выявить их потребности. Методы сбора включают интервью, опросы, наблюдение за работой пользователей, анализ существующих систем и работу в фокус-группах.\n\n2. **Анализ требований (Requirements Analysis)**\n   Собранные требования анализируются на полноту, согласованность, реализуемость и непротиворечивость. На этом этапе нечёткие пожелания преобразуются в чёткие, измеримые и проверяемые требования. Также определяется, какие требования являются функциональными (что система должна делать), а какие — нефункциональными (как система должна себя вести: производительность, безопасность, удобство использования и т.д.).\n\n3. **Приоритизация требований (Requirements Prioritization)**\n   Не все требования одинаково важны. Приоритизация помогает определить, какие функции нужно реализовать в первую очередь. Это особенно важно в условиях ограниченных ресурсов и сроках. Один из популярных методов — **MoSCoW**:\n   - **M** — Must have (обязательно)\n   - **S** — Should have (желательно)\n   - **C** — Could have (можно, но не критично)\n   - **W** — Won’t have (не будет в этом релизе)\n\n   Другие методы включают метод парных сравнений, анализ стоимости и выгод (cost-value), а также матрицу Кано.\n\n4. **Трассируемость требований (Traceability)**\n   Трассируемость означает возможность отследить каждое требование от его источника (например, от стейкхолдера) через этапы проектирования, реализации и тестирования до финальной проверки. Это обеспечивает контроль над тем, что всё запланированное реализовано и протестировано. Трассируемость особенно важна в регулируемых отраслях (медицина, финансы, авиация).\n\n#### Инструменты документирования требований\n\n- **User Stories (Пользовательские истории)**\n  Представляют собой краткое описание функциональности с точки зрения конечного пользователя. Формат: *«Как [роль], я хочу [действие], чтобы [цель]»*. Например: *«Как пользователь, я хочу входить в систему через Google, чтобы не запоминать пароль»*. User stories широко используются в гибких методологиях (Agile, Scrum).\n\n- **Use Cases (Сценарии использования)**\n  Более формализованный способ описания взаимодействия пользователя с системой. Use case включает актёров, основной поток действий, альтернативные и ошибочные сценарии. Подходит для сложных систем, где важно описать поведение в деталях.\n\nЭффективное управление требованиями — не разовый этап, а непрерывный процесс, требующий тесного взаимодействия между командой разработки и стейкхолдерами. Он лежит в основе создания качественного, востребованного и соответствующего ожиданиям продукта."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Сравнение моделей жизненного цикла разработки ПО",
        "max_score": 10,
        "passing_score": 6,
        "questions": [
          {
            "text": "На основе изученного материала о жизненном цикле программного обеспечения, сравните пять ключевых моделей — каскадную (Waterfall), итеративную (Iterative), спиральную (Spiral), V-Model и Agile — по следующим критериям: предсказуемость сроков, гибкость к изменениям, уровень рисков, объём и роль документации, особенности командной работы. Представьте результат в виде таблицы. После таблицы подробно объясните, в каких типах проектов каждая модель будет наиболее эффективной и почему.",
            "options": [],
            "correct_answers": [],
            "points": 3
          },
          {
            "text": "Почему в каскадной модели (Waterfall) изменения требований на поздних этапах разработки считаются критически дорогими? Какие последствия это может иметь для проекта? Приведите пример из реальной практики (например, Therac-25 или другой), где отсутствие гибкости в процессе привело к серьёзным последствиям.",
            "options": [],
            "correct_answers": [],
            "points": 2
          },
          {
            "text": "В чём заключается принцип трассируемости требований, и как он поддерживается в разных моделях жизненного цикла? Объясните, почему трассируемость особенно важна в V-Model и спиральной модели, и как она влияет на качество и безопасность конечного продукта.",
            "options": [],
            "correct_answers": [],
            "points": 2
          },
          {
            "text": "Какие из рассмотренных моделей жизненного цикла ПО лучше всего способствуют воспроизводимости и управляемости процесса разработки? Обоснуйте свой ответ, ссылаясь на принципы инженерии ПО (воспроизводимость, управляемость, качество и др.) и конкретные практики, например, использование CI/CD, контроля версий или IaC.",
            "options": [],
            "correct_answers": [],
            "points": 1
          },
          {
            "text": "Представьте, что вы — инженер ПО в команде, разрабатывающей систему электронного голосования для национальных выборов. Какую модель жизненного цикла вы бы выбрали и почему? Обоснуйте свой выбор, учитывая такие факторы, как критичность системы, необходимость тестирования, безопасность, управление требованиями и взаимодействие с заказчиком.",
            "options": [],
            "correct_answers": [],
            "points": 2
          }
        ]
      }
    },
    {
      "id": "3a06b1cd-9283-4e52-8ba7-cc174bde2bee",
      "title": "Модуль 1: Основы инженерии программного обеспечения",
      "description": "Первый модуль курса знакомит студентов с фундаментальными концепциями инженерии ПО, формируя базовое понимание системного подхода к разработке. Акцент сделан на переходе от написания кода к проектированию и управлению ПО как системой. Студенты освоят ключевые принципы, лежащие в основе профессиональной разработки: качество кода, технический долг, трассируемость требований, командная работа и ответственность за архитектурные решения. Модуль закладывает основу для последующего изучения жизненного цикла, архитектуры и управления требованиями.",
      "learning_objectives": [
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
        "Применять архитектурные паттерны и обосновывать их выбор.",
        "Документировать архитектурные решения по шаблону C4.",
        "Разрабатывать стратегию тестирования, включая нефункциональные аспекты.",
        "Оценивать качество ПО и управлять техническим долгом.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 1,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 1: Основы инженерии ПО] --> B[Тема 1.1: Что такое инженерия ПО?]\n    A --> C[Тема 1.2: Качество ПО и технический долг]\n    A --> D[Тема 1.3: Работа в команде и инструменты]\n    A --> E[Тема 1.4: Введение в требования и трассируемость]\n    B --> B1[Лекция: От программирования к инженерии]\n    B --> B2[Практика: Анализ кейса провала ПО]\n    C --> C1[Лекция: Качество кода и архитектуры]\n    C --> C2[Практика: Оценка технического долга в коде]\n    D --> D1[Лекция: Инструменты: Jira, Git, Confluence]\n    D --> D2[Практика: Настройка командного репозитория]\n    E --> E1[Лекция: Типы требований: функциональные и нефункциональные]\n    E --> E2[Практика: Сбор требований по мокапу]\n```",
          "explanation": "Диаграмма отображает структуру первого модуля курса по инженерии программного обеспечения, показывая иерархию тем и связанных с ними лекций и практических занятий."
        },
        {
          "content_type": "quiz",
          "ai_generated": true,
          "questions": []
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "markdown",
          "code": "### Анализ технического долга в ветке `feature/login-bug` (файл `auth.py`)\n\nНайденные признаки технического долга зафиксированы в **issue #45**:\n\n---\n\n**- Проблема:** Дублирование логики проверки пароля в нескольких функциях\n**- Строка:** 42, 87\n**- Рекомендация:** Вынести общую логику проверки пароля (длина, наличие символов) в отдельную функцию `validate_password(password)` и использовать её повторно.\n\n---\n\n**- Проблема:** Плохие имена переменных, затрудняющие понимание кода\n**- Строка:** 33 (`u`, `p`, `res`)\n**- Рекомендация:** Переименовать переменные в соответствии с их семантикой: `username`, `password`, `auth_result`.\n\n---\n\n**- Проблема:** Отсутствие комментариев и документации у критических функций\n**- Строка:** 25 (`def authenticate_user(...)`)\n**- Рекомендация:** Добавить docstring по стандарту PEP 257, описывающий параметры, возвращаемое значение и возможные исключения.\n\n---\n\n*Анализ выполнен в ветке `feature/login-bug` репозитория `team-project-2025`.*",
          "explanation": "Пример демонстрирует, как фиксировать технический долг в системе управления задачами (GitHub Issues). Использован структурированный формат, позволяющий легко трассировать проблемы, определять их местоположение и предлагать улучшения — что соответствует практикам инженерии ПО и управлению качеством кода."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Тема 1.1: Что такое инженерия ПО?\n\nИнженерия программного обеспечения (ПО) — это систематический, дисциплинированный и измеримый подход к разработке, эксплуатации и сопровождению программного обеспечения. В отличие от простого программирования, которое сосредоточено на написании кода, инженерия ПО охватывает весь жизненный цикл продукта: от формулировки требований до вывода из эксплуатации. Это переход от творческого хакинга к профессии, где важны надёжность, масштабируемость, безопасность и поддерживаемость.\n\n### От программирования к инженерии: масштаб, сложность, надёжность\n\nС развитием технологий программные системы стали значительно сложнее. Современные приложения — это не просто отдельные скрипты, а распределённые, многомодульные системы с тысячами строк кода, взаимодействующие с пользователями, базами данных и внешними сервисами. Такой рост масштаба требует не только навыков написания кода, но и системного мышления.\n\nИнженерия ПО появилась как ответ на вызовы, связанные с:\n- **Масштабом** — управление большими командами и кодовыми базами.\n- **Сложностью** — проектирование архитектуры, которая остаётся понятной и модифицируемой.\n- **Надёжностью** — обеспечение стабильной работы ПО в реальных условиях, включая отказоустойчивость и безопасность.\n\n### Исторические провалы ПО: уроки из прошлого\n\nОшибки в проектировании и разработке ПО могут иметь катастрофические последствия. Два известных примера подчёркивают важность инженерного подхода:\n\n- **Therac-25** — медицинский линейный ускоритель 1980-х годов, который из-за ошибки в программном обеспечении давал пациентам смертельные дозы радиации. Причина — отсутствие проверок на параллельные операции и игнорирование требований безопасности.\n- **Ariane 5** — ракета-носитель, которая взорвалась через 37 секунд после запуска в 1996 году. Причина — переполнение переменной из-за переиспользования кода от Ariane 4 без адаптации к новым условиям.\n\nЭти кейсы показывают, что даже небольшая ошибка в коде может привести к трагедии, если не соблюдаются принципы инженерии: тестирование, анализ требований, трассировка изменений и ревью архитектуры.\n\n### Основные дисциплины инженерии ПО\n\nИнженерия ПО включает в себя несколько ключевых направлений, каждое из которых критически важно для успеха проекта:\n\n- **Управление требованиями** — сбор, анализ, документирование и отслеживание требований. Обеспечивает, что продукт решает нужные задачи.\n- **Архитектура ПО** — проектирование структуры системы с учётом масштабируемости, надёжности и поддерживаемости.\n- **Тестирование** — проверка корректности, производительности и безопасности ПО. Включает модульное, интеграционное, нагрузочное и приёмочное тестирование.\n- **Сопровождение** — внесение изменений, исправление ошибок и адаптация ПО к новым условиям на протяжении всего жизненного цикла.\n\nЭти дисциплины работают вместе, обеспечивая качество и предсказуемость процесса разработки.\n\n### Роль инженера ПО: не только код\n\nИнженер ПО — это не просто разработчик, который пишет код. Его роль гораздо шире:\n- **Проектирование** — создание архитектуры и выбор технологий.\n- **Документация** — фиксация решений, требований и изменений для обеспечения прозрачности.\n- **Коммуникация** — взаимодействие с заказчиками, аналитиками, тестировщиками и другими инженерами.\n- **Управление техническим долгом** — осознанное принятие решений о временных упрощениях и планирование их устранения.\n\nИнженер ПО отвечает за долгосрочное качество продукта, а не только за его текущую работоспособность.\n\n### Практика: Анализ кейса\n\n**Ситуация:** Система бронирования авиабилетов крупной авиакомпании внезапно вышла из строя в период новогодних каникул. В пиковый момент нагрузка достигла 10 000 запросов в секунду, и сервера не выдержали. Пользователи не могли завершить покупку, теряли данные, а компания понесла убытки в миллионы долларов.\n\n**Вопросы для обсуждения:**\n1. Какие этапы жизненного цикла разработки ПО были нарушены?\n2. Какие требования (функциональные и нефункциональные) были проигнорированы?\n3. Какие последствия имел этот сбой для бизнеса и пользователей?\n4. Какие меры можно было предпринять на этапе проектирования и тестирования, чтобы избежать этой ситуации?\n\n**Цель задания:** Научиться распознавать последствия пренебрежения инженерными практиками и понимать важность каждого этапа жизненного цикла."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Тема 1.2: Качество ПО и технический долг\n\n### Внутреннее и внешнее качество ПО\n\nКачество программного обеспечения (ПО) — это совокупность характеристик, определяющих, насколько продукт соответствует ожиданиям пользователей и требованиям разработчиков. Оно делится на **внешнее** и **внутреннее**.\n\n- **Внешнее качество** — это то, что видит пользователь: удобство интерфейса, скорость отклика, стабильность работы, корректность выполнения функций. Оно напрямую влияет на удовлетворённость клиента.\n- **Внутреннее качество** — это характеристики, «невидимые» конечному пользователю, но критически важные для разработчиков: структура кода, читаемость, модульность, тестируемость, отсутствие дублирования. Оно определяет, насколько легко и быстро можно вносить изменения, исправлять ошибки и масштабировать систему.\n\nВысокое внутреннее качество — залог долгосрочной поддерживаемости и устойчивого развития продукта.\n\n### Факторы качества ПО\n\nОсновные факторы, определяющие качество ПО, включают:\n\n- **Надёжность** — способность системы корректно работать в течение заданного времени без сбоев. Включает устойчивость к ошибкам, восстановление после сбоев и отказоустойчивость.\n- **Производительность** — эффективность работы системы: время отклика, пропускная способность, использование ресурсов (память, CPU). Низкая производительность может привести к плохому пользовательскому опыту.\n- **Поддерживаемость** — лёгкость внесения изменений, исправления ошибок и добавления новых функций. Зависит от качества архитектуры, документации и структуры кода.\n\nДругие важные аспекты: масштабируемость, безопасность, переносимость и удобство сопровождения.\n\n### Понятие технического долга\n\n**Технический долг** — это метафора, введённая Уордом Каннингемом, описывающая последствия выбора быстрого, но неоптимального решения в разработке ПО. Как финансовый долг, технический долг требует «процентов» — дополнительных усилий в будущем при поддержке и развитии системы.\n\n#### Виды технического долга:\n\n- **Долг кода** — использование плохих практик: дублирование кода, длинные функции, плохие имена переменных, отсутствие тестов.\n- **Архитектурный долг** — упрощение архитектуры за счёт модульности, слабая трассировка компонентов, нарушение принципов разделения ответственности.\n- **Долг документации** — отсутствие или устаревшая документация, что затрудняет понимание системы новыми разработчиками.\n- **Долг тестирования** — недостаточное покрытие тестами, ручное тестирование вместо автоматизированного.\n\n#### Последствия технического долга:\n\n- Замедление разработки со временем\n- Рост числа ошибок при внесении изменений\n- Сложность обучения новых сотрудников\n- Повышенные риски при рефакторинге\n- Увеличение стоимости сопровождения\n\n### Управление техническим долгом\n\nТехнический долг не всегда вреден — иногда его осознанно принимают, чтобы быстрее выйти на рынок. Ключевое — **управлять** им, а не игнорировать.\n\n#### Методы управления:\n\n- **Рефакторинг** — структурное улучшение кода без изменения его поведения. Позволяет постепенно «погашать» долг.\n- **Метрики качества кода** — использование инструментов (например, SonarQube) для измерения сложности, покрытия тестами, количества предупреждений. Метрики помогают выявлять «зоны риска».\n- **Технические спринты** — выделение времени в процессе разработки (например, один спринт в квартал) исключительно на улучшение архитектуры, рефакторинг и погашение долга.\n- **Технический бэклог** — ведение списка задач по улучшению кода и архитектуры наравне с функциональными требованиями.\n\n> **Важно**: технический долг должен быть **осознанным и задокументированным**. Принятие решения о его накоплении должно сопровождаться оценкой рисков и планом погашения.\n\n### Практическое задание\n\nСтуденты получают фрагмент кода, содержащий типичные антипаттерны: дублирование, длинные методы, плохие имена, отсутствие комментариев и тестов.\n\n**Задача**:\n1. Выявить признаки технического долга.\n2. Определить его тип (кода, архитектуры и т.д.).\n3. Предложить конкретные шаги по улучшению: рефакторинг, разбиение на модули, добавление тестов, документирование.\n4. Обосновать, как изменения повлияют на внутреннее и внешнее качество ПО.\n\nЭто задание формирует навык критического анализа кода и ответственного подхода к проектированию."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Тема 1.3: Работа в команде и инструменты\n\n### Введение\n\nСовременная разработка программного обеспечения — это, прежде всего, командная работа. Успешное создание качественного ПО невозможно без слаженного взаимодействия между разработчиками, тестировщиками, аналитиками, архитекторами и другими участниками процесса. Для эффективной координации используются специализированные инструменты и стандартизированные рабочие процессы, которые обеспечивают прозрачность, контроль изменений и трассируемость на всех этапах жизненного цикла.\n\nВ этом модуле мы рассмотрим ключевые инструменты и практики, лежащие в основе командной разработки.\n\n---\n\n### Современные инструменты разработки\n\n#### 1. **Jira — управление задачами**\n\nJira — это мощная система управления проектами и задачами, разработанная Atlassian. Она широко используется в командах разработки для:\n\n- Планирования спринтов и релизов\n- Создания и отслеживания задач (issues)\n- Управления багами и улучшениями\n- Визуализации прогресса через доски (Kanban, Scrum)\n\nКаждая задача в Jira имеет уникальный идентификатор (например, `PROJ-123`), статус, исполнителя, описание и может быть связана с другими задачами (родительская/подзадача). Это позволяет строить иерархию требований и отслеживать их реализацию.\n\n#### 2. **Confluence — документация**\n\nConfluence — это корпоративная платформа для совместного создания и хранения документации. В контексте разработки ПО она используется для:\n\n- Описания требований\n- Документирования архитектурных решений (в том числе по шаблону C4)\n- Ведения технической документации (API, инструкции)\n- Фиксации решений на встрече (минутки)\n\nConfluence интегрируется с Jira: можно вставлять задачи, ссылаться на страницы из задач и наоборот, обеспечивая связность информации.\n\n#### 3. **Git — контроль версий**\n\nGit — распределённая система контроля версий, ставшая стандартом де-факто в разработке ПО. Она позволяет:\n\n- Отслеживать изменения в коде\n- Работать параллельно над разными функциями (ветки)\n- Слияние изменений с контролем конфликтов\n- Восстанавливать предыдущие версии\n\nПлатформы вроде GitHub, GitLab или Bitbucket предоставляют веб-интерфейс для Git, а также дополнительные функции: CI/CD, code review, issue tracking.\n\n---\n\n### Принципы трассируемости\n\n**Трассируемость** — это способность проследить путь требования от его появления до реализации и тестирования. Она критически важна для:\n\n- Контроля качества\n- Управления изменениями\n- Аудита и регулирования (в регулируемых отраслях)\n- Оценки влияния изменений (impact analysis)\n\n#### Цепочка трассируемости:\n\n```\nТребование (Confluence / Jira) → Задача (Jira) → Ветка / Коммит (Git) → Тест (Jira / Test-план)\n```\n\n**Пример:**\n\n1. В Confluence описано требование: \"Пользователь должен иметь возможность сбросить пароль через email\".\n2. В Jira создана задача `AUTH-45` — \"Реализовать сброс пароля\".\n3. Разработчик создаёт ветку `feature/auth-password-reset` и делает коммит с сообщением: `AUTH-45: add password reset endpoint`.\n4. Коммит автоматически отображается в задаче Jira.\n5. Тестировщик создаёт тест-кейс, привязанный к `AUTH-45`, и проверяет реализацию.\n\nТакая цепочка позволяет в любой момент понять:\n- Что реализовано, а что нет\n- Какие части кода затрагивает изменение\n- Какие тесты покрывают конкретное требование\n\n---\n\n### Рабочие процессы\n\n#### 1. **Git Flow**\n\nGit Flow — это популярная модель ветвления в Git, предложенная Винсентом Дрисселерсом. Она определяет строгую структуру веток:\n\n- `main` — стабильная версия продукта (релизы)\n- `develop` — основная ветка разработки\n- `feature/*` — ветки для реализации новых функций\n- `release/*` — ветки для подготовки релиза\n- `hotfix/*` — срочные исправления для продакшена\n\n**Преимущества:**\n- Чёткое разделение стадий\n- Поддержка параллельной разработки\n- Контроль версий и релизов\n\n**Недостатки:**\n- Сложность при частых релизах (CI/CD)\n- Избыточность для небольших проектов\n\nАльтернативы: GitHub Flow, GitLab Flow — более лёгкие модели, ориентированные на непрерывную доставку.\n\n#### 2. **Issue Tracking**\n\nIssue tracking — это процесс регистрации, отслеживания и управления задачами (issues) в системе, такой как Jira. Ключевые практики:\n\n- Каждое изменение кода должно быть привязано к задаче\n- Задачи должны быть атомарными и выполнимыми\n- Используется workflow: `To Do → In Progress → Code Review → Done`\n- Автоматизация: при коммите с именем задачи (например, `PROJ-123`) система автоматически связывает коммит с задачей\n\n---\n\n### Практика: Командная задача\n\n**Цель:** Настроить инструментарий для командной разработки и продемонстрировать трассируемость.\n\n**Шаги:**\n\n1. **Создайте репозиторий в GitHub**\n   - Название: `team-project-demo`\n   - Инициализируйте с `README.md` и `.gitignore` для языка Python/Java\n\n2. **Настройте ветки**\n   - Создайте ветку `develop` из `main`\n   - Установите `develop` как default branch для разработки\n   - Настройте Git Flow (по желанию)\n\n3. **Создайте задачу в Jira**\n   - Проект: `TEAM-DEV`\n   - Задача: \"Добавить функцию калькулятора\"\n   - Код: `TEAM-1`\n   - Описание, оценка, исполнитель\n\n4. **Привяжите коммит к задаче**\n   - Создайте ветку `feature/calculator-add` из `develop`\n   - Реализуйте функцию `add(a, b)`\n   - Сделайте коммит с сообщением: `TEAM-1: implement add function`\n   - Запушьте ветку в GitHub\n   - Убедитесь, что коммит отображается в задаче Jira (при интеграции)\n\n5. **Добавьте документацию в Confluence**\n   - Создайте страницу \"API Калькулятора\"\n   - Опишите функцию `add`\n   - Ссылка на задачу `TEAM-1` и репозиторий\n   - Вставьте ссылку на ветку или коммит\n\n**Результат:** Полная цепочка трассируемости от требования до кода и документации.\n\n---\n\n### Заключение\n\nЭффективная командная разработка невозможна без использования современных инструментов и дисциплинированного подхода к процессам. Jira, Confluence и Git — это не просто инструменты, а часть культуры инженерии ПО. Они позволяют строить прозрачные, масштабируемые и поддерживаемые процессы, где каждое изменение можно отследить, а каждое решение — документировать.\n\nОсвоение этих инструментов и практик — важный шаг на пути от программиста к инженеру ПО."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Тема 1.4: Введение в требования и трассируемость\n\n### Лекция\n\n#### Функциональные и нефункциональные требования\n\nТребования к программному обеспечению — это основа успешной разработки. Они определяют, что система должна делать и как она должна себя вести. Требования делятся на две основные категории: **функциональные** и **нефункциональные**.\n\n- **Функциональные требования** описывают поведение системы — то, какие действия она должна выполнять. Например: «Пользователь может войти в систему, введя логин и пароль».\n  \n- **Нефункциональные требования** определяют, *как* система должна работать. Они касаются характеристик, таких как:\n  - **Производительность** — например, «Система должна обрабатывать 1000 запросов в секунду».\n  - **Безопасность** — например, «Все данные передаются по зашифрованному соединению (HTTPS)».\n  - **Доступность** — например, «Система должна быть доступна 99,9% времени в течение года».\n  - Другие примеры: масштабируемость, удобство использования (usability), поддерживаемость, отказоустойчивость.\n\nНефункциональные требования часто игнорируются на ранних этапах, но именно они определяют качество системы в продакшене и влияют на архитектурные решения.\n\n#### Форматы описания требований\n\nДля чёткого и понятного описания требований используются стандартизированные форматы:\n\n- **User Story (Пользовательская история)** — краткое описание функциональности с точки зрения пользователя. Формат: \n  > «Как [роль], я хочу [действие], чтобы [цель]».\n  \n  Пример: «Как пользователь, я хочу сбросить пароль, чтобы восстановить доступ к аккаунту».\n\n- **Use Case (Сценарий использования)** — более формализованное описание взаимодействия между актёром и системой. Включает основной поток, альтернативные и ошибочные сценарии. Подходит для сложных систем, где важно описать все возможные пути выполнения.\n\n- **Критерии приёмки (Acceptance Criteria)** — конкретные условия, при которых user story считается выполненной. Обычно формулируются в формате Given-When-Then:\n  > Given [начальное состояние], When [действие], Then [ожидаемый результат].\n  \n  Пример: \n  > Given, что пользователь находится на странице восстановления пароля, \n  > When он вводит зарегистрированный email и нажимает «Отправить», \n  > Then система отправляет письмо со ссылкой на сброс пароля.\n\n#### Важность трассируемости требований\n\n**Трассируемость требований** — это способность отслеживать каждое требование на всех этапах жизненного цикла: от постановки до реализации, тестирования и сопровождения.\n\nТрассируемость позволяет:\n- Убедиться, что все требования реализованы.\n- Оценить влияние изменений (impact analysis) — например, если меняется одно требование, можно быстро найти все связанные компоненты.\n- Обеспечить прозрачность и контроль качества.\n- Подготовиться к аудиту или сертификации (например, в медицинских или финансовых системах).\n\nДля поддержки трассируемости используются инструменты (Jira, Confluence, DOORS) и матрицы трассируемости — таблицы, связывающие требования с задачами, тестами и архитектурными элементами.\n\n---\n\n### Практика\n\n**Задание:** По мокапу веб-интерфейса сформулируйте:\n\n1. **5 функциональных требований** в формате **user story** с **критериями приёмки**.\n2. **3 нефункциональных требования**, касающихся производительности, безопасности и доступности.\n\n**Пример выполнения (для вдохновения):**\n\n**Функциональное требование 1:**\n> Как пользователь, я хочу видеть список своих заказов, чтобы отслеживать статус доставки.\n\n**Критерии приёмки:**\n> Given, что пользователь авторизован и находится в личном кабинете, \n> When он переходит на вкладку «Мои заказы», \n> Then система отображает список всех его заказов с датой, статусом и суммой.\n\n**Нефункциональное требование 1 (Производительность):**\n> Страница списка заказов должна загружаться не более чем за 2 секунды при объёме данных до 100 заказов.\n\n**Нефункциональное требование 2 (Безопасность):**\n> Доступ к личному кабинету возможен только после аутентификации и с использованием HTTPS.\n\n**Нефункциональное требование 3 (Доступность):**\n> Сервис должен быть доступен 24/7 с годовой доступностью не менее 99,5%.\n\nВыполните аналогичное задание на основе предоставленного мокапа."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Практическое задание: Тест по модулю 1",
        "max_score": 10,
        "passing_score": 7,
        "questions": [
          {
            "text": "Какое из следующих утверждений наилучшим образом описывает суть инженерии программного обеспечения по сравнению с программированием?",
            "options": [
              "Инженерия ПО фокусируется на написании максимально быстрого кода, а программирование — на его структуре.",
              "Программирование включает проектирование архитектуры, а инженерия ПО — только написание кода.",
              "Инженерия ПО охватывает весь жизненный цикл ПО, включая требования, архитектуру, тестирование и сопровождение, а не только написание кода.",
              "Инженерия ПО и программирование — это синонимы, различия отсутствуют."
            ],
            "correct_answers": [
              2
            ],
            "points": 1
          },
          {
            "text": "Какие из перечисленных факторов относятся к **внутреннему качеству** программного обеспечения? Выберите все подходящие варианты.",
            "options": [
              "Скорость отклика системы",
              "Читаемость и структура кода",
              "Удобство пользовательского интерфейса",
              "Модульность и тестируемость",
              "Наличие документации"
            ],
            "correct_answers": [
              1,
              3,
              4
            ],
            "points": 1
          },
          {
            "text": "Что такое технический долг в контексте разработки ПО? Объясните кратко, приведите один пример.",
            "options": [
              "Произвольный текстовый ответ",
              "Технический долг — это..."
            ],
            "correct_answers": [
              0
            ],
            "points": 1
          },
          {
            "text": "Какие из следующих ситуаций являются примерами технического долга? Выберите все верные варианты.",
            "options": [
              "Код не покрыт автоматическими тестами.",
              "Функция длиной 200 строк выполняет несколько задач.",
              "Используется устаревшая, но стабильная версия библиотеки.",
              "Переменные названы как `x`, `temp`, `data1`.",
              "Система не отвечает на запросы в течение 10 секунд."
            ],
            "correct_answers": [
              0,
              1,
              3
            ],
            "points": 1
          },
          {
            "text": "Какой из следующих примеров иллюстрирует **нефункциональное требование**?",
            "options": [
              "Пользователь может добавить товар в корзину.",
              "Система должна отправлять уведомления по email при оформлении заказа.",
              "Страница загружается не более чем за 2 секунды при нагрузке до 5000 пользователей.",
              "Администратор может удалять учётные записи пользователей."
            ],
            "correct_answers": [
              2
            ],
            "points": 1
          },
          {
            "text": "Какие из перечисленных инструментов используются для управления задачами и документацией в командной разработке? Выберите все подходящие варианты.",
            "options": [
              "Jira",
              "Confluence",
              "Git",
              "Figma",
              "Postman"
            ],
            "correct_answers": [
              0,
              1
            ],
            "points": 1
          },
          {
            "text": "Что такое трассируемость требований и зачем она нужна? Приведите краткое объяснение и пример цепочки трассируемости.",
            "options": [
              "Произвольный текстовый ответ",
              "Трассируемость — это..."
            ],
            "correct_answers": [
              0
            ],
            "points": 1
          },
          {
            "text": "Какой из следующих коммитов в Git лучше всего соответствует практике трассируемости?",
            "options": [
              "fix bug",
              "update files",
              "TASK-123: add password reset endpoint",
              "final version"
            ],
            "correct_answers": [
              2
            ],
            "points": 1
          },
          {
            "text": "Какие из следующих последствий могут возникнуть при накоплении технического долга? Выберите все верные варианты.",
            "options": [
              "Ускорение разработки новых функций",
              "Рост числа ошибок при внесении изменений",
              "Сложность в обучении новых разработчиков",
              "Упрощение архитектуры",
              "Увеличение времени на ревью кода"
            ],
            "correct_answers": [
              1,
              2,
              4
            ],
            "points": 1
          },
          {
            "text": "Сформулируйте одно функциональное требование в формате user story и одно нефункциональное требование для мобильного приложения доставки еды.",
            "options": [
              "Произвольный текстовый ответ",
              "User story: Как ..., я хочу ..., чтобы ...\nНефункциональное: ..."
            ],
            "correct_answers": [
              0
            ],
            "points": 1
          }
        ]
      }
    },
    {
      "id": "6cb540ae-356b-4f8b-9524-9bf71fed89f5",
      "title": "Модуль 2: Сбор и анализ требований",
      "description": "В этом модуле студенты научатся системно подходить к выявлению, анализу и документированию требований к программному обеспечению. На основе практических кейсов они освоят методы взаимодействия с заказчиками, классификацию функциональных и нефункциональных требований, работу с противоречиями и приоритизацией, а также научатся оформлять требования в стандартизированной форме для последующей передачи команде разработки.",
      "learning_objectives": [
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 2,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля 2",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 2: Сбор и анализ требований] --> B[Тема 2.1: Введение в требования к ПО]\n    A --> C[Тема 2.2: Методы сбора требований]\n    A --> D[Тема 2.3: Анализ и приоритизация требований]\n    A --> E[Тема 2.4: Документирование и управление требованиями]\n```",
          "explanation": "Диаграмма отображает структуру модуля 2, показывая основные темы, изучаемые в рамках курса по сбору и анализу требований к программному обеспечению."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 2.1: Введение в требования к ПО\n\n#### Что такое требования? Зачем они нужны?\n\n**Требования к программному обеспечению** — это чётко сформулированные ожидания заинтересованных сторон (стейкхолдеров), описывающие, что система должна делать, как она должна себя вести, какие функции выполнять и в каких условиях работать. Требования являются основой для проектирования, разработки, тестирования и внедрения программного продукта.\n\n**Зачем нужны требования?**\n- Обеспечивают **общее понимание** между заказчиком, аналитиком, разработчиками и тестировщиками.\n- Служат **основой для оценки стоимости и сроков** проекта.\n- Позволяют **избежать недопонимания** и снизить риск ошибок на поздних стадиях разработки.\n- Являются **основой для тестирования** — по ним проверяется, соответствует ли продукт ожиданиям.\n- Обеспечивают **трассируемость** — возможность отследить, как каждое требование реализовано в системе.\n\n---\n\n#### Классификация требований\n\nТребования можно разделить на три основные категории:\n\n1. **Функциональные требования**\n   Описывают, **что система должна делать** — её поведение, функции и возможности.\n   \n   **Примеры:**\n   - Пользователь может авторизоваться в системе, введя логин и пароль.\n   - Система должна рассчитывать итоговую стоимость заказа с учётом скидок и налогов.\n   - Администратор может экспортировать отчёт в формате PDF.\n\n2. **Нефункциональные требования**\n   Описывают **качественные характеристики системы** — как она должна работать.\n   \n   **Основные типы:**\n   - **Производительность**: система должна обрабатывать до 1000 запросов в секунду.\n   - **Безопасность**: пароли пользователей должны храниться в зашифрованном виде.\n   - **Доступность**: система должна быть доступна 99,9% времени в год.\n   - **Масштабируемость**: система должна поддерживать рост числа пользователей до 1 млн.\n   - **Юзабилити**: интерфейс должен быть интуитивно понятным для пользователей без технической подготовки.\n\n3. **Ограничения**\n   Это внешние условия, которые накладываются на разработку.\n   \n   **Примеры:**\n   - Использование определённой технологии (например, Python 3.10).\n   - Соответствие законодательству (например, GDPR).\n   - Сроки сдачи — не позднее 1 декабря 2025 года.\n\n---\n\n#### Уровни требований\n\nТребования формулируются на разных уровнях абстракции:\n\n1. **Бизнес-требования**\n   — Что хочет достичь бизнес? Почему создается система?\n   — Пример: «Снизить время обработки заказов на 30% за счёт автоматизации».\n\n2. **Пользовательские требования**\n   — Какие задачи должны решать пользователи с помощью системы?\n   — Пример: «Менеджер должен иметь возможность просматривать статус всех заказов за текущий день».\n\n3. **Системные требования**\n   — Конкретные технические условия, которые должна выполнять система.\n   — Пример: «Система должна возвращать результат поиска не более чем за 2 секунды при нагрузке до 500 пользователей».\n\n---\n\n#### Примеры хороших и плохих формулировок требований (SMART-критерии)\n\nХорошее требование должно соответствовать **SMART-критериям**:\n- **S**pecific (Конкретное)\n- **M**easurable (Измеримое)\n- **A**chievable (Достижимое)\n- **R**elevant (Релевантное)\n- **T**ime-bound (Ограниченное по времени)\n\n**Плохая формулировка:**\n> «Система должна быть быстрой.»\n— Не измеримо, не конкретно.\n\n**Хорошая формулировка:**\n> «Система должна загружать главную страницу не более чем за 1,5 секунды при подключении по 4G.»\n— Конкретно, измеримо, проверяемо.\n\n**Плохая формулировка:**\n> «Пользователь должен легко пользоваться системой.»\n— Субъективно.\n\n**Хорошая формулировка:**\n> «Новый пользователь должен завершить регистрацию не более чем за 2 минуты без помощи технической поддержки.»\n— Измеримо и проверяемо.\n\n---\n\n#### Связь требований с жизненным циклом разработки\n\nТребования играют ключевую роль на всех этапах жизненного цикла ПО, но по-разному в разных моделях разработки.\n\n1. **Waterfall (каскадная модель)**\n   - Требования **полностью определяются на начальном этапе**.\n   - Документируются в виде детального **SRS (Software Requirements Specification)**.\n   - Изменения вносятся с трудом и требуют пересмотра всех последующих этапов.\n   - Подходит для проектов с чёткими и стабильными требованиями.\n\n2. **Agile (гибкие методологии, например, Scrum)**\n   - Требования **формулируются и уточняются по ходу разработки**.\n   - Используются **юзер-стори** (User Stories) — краткие описания функций с точки зрения пользователя.\n   - Приоритизация требований происходит постоянно (Product Backlog).\n   - Подходит для проектов с изменяющимися или не до конца понятными требованиями.\n\n**Пример юзер-стори:**\n> «Как пользователь, я хочу восстановить пароль по email, чтобы получить доступ к аккаунту, если забыл пароль.»\n\n---\n\n#### Формат занятия: Лекция + интерактивный разбор примеров\n\n**Практическая часть:**\n1. Разбор кейса: интернет-магазин.\n   - Студенты выделяют функциональные и нефункциональные требования.\n   - Классифицируют требования по уровням.\n   - Переписывают «плохие» формулировки в соответствии с SMART.\n\n2. Групповая работа:\n   - Каждая группа получает описание бизнес-идеи (например, приложение для каршеринга).\n   - Формулирует 5 функциональных, 3 нефункциональных требования и 2 ограничения.\n   - Презентация и обсуждение.\n\n---\n\n**Вывод:**\nПонимание и правильная формулировка требований — фундамент успешной разработки ПО. От качества требований зависит, насколько точно будет реализован продукт, удовлетворяющий потребности бизнеса и пользователей."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 2.2: Методы сбора требований\n\n**Цель:** Освоить практические методы взаимодействия с заинтересованными сторонами для выявления требований.\n\nДля успешной разработки программного обеспечения критически важно правильно понять, что именно нужно пользователям и бизнесу. Сбор требований — это первый и один из самых важных этапов в жизненном цикле разработки ПО. Ошибки на этом этапе могут привести к значительным потерям времени, ресурсов и несоответствию конечного продукта ожиданиям заказчика. Ниже рассмотрены основные методы сбора требований, каждый из которых имеет свои преимущества и области применения.\n\n#### 1. Интервью\n\nИнтервью — один из самых распространённых и эффективных способов выявления требований. Он позволяет глубоко понять потребности заинтересованной стороны.\n\n- **Подготовка:** Определите цели интервью, составьте список вопросов (открытых и закрытых), выберите участников (заказчики, конечные пользователи, эксперты).\n- **Ведение:** Поддерживайте дружелюбную атмосферу, слушайте активно, уточняйте непонятные моменты, фиксируйте ключевые высказывания.\n- **Анализ:** После интервью структурируйте полученные данные: выделите функциональные и нефункциональные требования, найдите противоречия, сформулируйте гипотезы для дальнейшей проверки.\n\n> **Совет:** Используйте технику \"5 почему\", чтобы добраться до истинной причины потребности.\n\n#### 2. Опросы и анкетирование\n\nПодходят для сбора информации от большого числа пользователей. Особенно эффективны при оценке удовлетворённости текущей системой или выявлении типичных сценариев использования.\n\n- Разрабатывайте чёткие, нейтральные вопросы.\n- Используйте смешанный формат: шкалы, множественный выбор, открытые поля.\n- Обеспечьте анонимность, если это необходимо, чтобы получить более честные ответы.\n\n> **Ограничение:** Низкий уровень глубины по сравнению с интервью.\n\n#### 3. Фасилитация рабочих сессий (workshops)\n\nРабочие сессии — это организованные встречи с участием нескольких заинтересованных сторон, проводимые под руководством фасилитатора.\n\n- Позволяют быстро согласовать требования.\n- Способствуют выявлению конфликтов интересов на раннем этапе.\n- Используются техники мозгового штурма, приоритизации (например, MoSCoW), построения user story.\n\n> **Успех зависит от подготовки и умения вести группу.**\n\n#### 4. Наблюдение и job shadowing\n\nМетод заключается в наблюдении за пользователем во время выполнения его повседневных задач.\n\n- Позволяет выявить неочевидные, неосознанные потребности.\n- Полезен, когда пользователи не могут чётко сформулировать свои действия или требования.\n- Помогает понять контекст использования системы.\n\n> **Пример:** Наблюдение за администратором вуза при бронировании аудиторий может выявить ручные операции, которые можно автоматизировать.\n\n#### 5. Анализ существующих систем и документации\n\nИзучение текущих процессов, программ, отчётов, регламентов и инструкций помогает понять, как работает система сейчас.\n\n- Выявляет узкие места и области для улучшения.\n- Позволяет избежать дублирования функций.\n- Служит основой для трассируемости требований.\n\n> **Важно:** Документация часто устаревает — всегда сверяйте её с реальной практикой.\n\n#### 6. Работа с пользователями: persona и user journey\n\n- **Persona** — это вымышленный, но реалистичный образ типичного пользователя, включающий его цели, навыки, ограничения и поведение.\n  - Помогает команде разработки «встать на место пользователя».\n  - Пример: *Анна, администратор вуза, 35 лет, работает с графиком аудиторий, часто сталкивается с конфликтами бронирования.*\n\n- **User journey (путь пользователя)** — визуализация всех шагов, которые проходит пользователь при взаимодействии с системой.\n  - Позволяет выявить точки боли и возможности для улучшения.\n  - Включает этапы: цель → поиск → использование → обратная связь.\n\n> Эти методы особенно полезны при проектировании пользовательского интерфейса и UX.\n\n---\n\n### Практическое задание\n\n**Задача:** Провести мини-интервью (10–15 минут) с «заказчиком» (роль исполняет преподаватель или коллега) и выделить требования для простого сервиса — *системы бронирования аудиторий*.\n\n**Шаги:\n**\n1. Подготовьте 5–7 вопросов (включая открытые и уточняющие).\n2. Проведите интервью в формате ролевой игры.\n3. Зафиксируйте полученные требования.\n4. Классифицируйте их на функциональные (например, \"пользователь может забронировать аудиторию на определённое время\") и нефункциональные (например, \"система должна отвечать в течение 2 секунд\").\n5. Представьте результаты в виде таблицы или списка.\n\n**Формат занятия:** Семинар + ролевая игра. После выполнения задания — обсуждение в группе: какие методы помогли, какие требования оказались неочевидными, как избежать недопонимания."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 2.3: Анализ и приоритизация требований\n\n**Цель:** Научиться выявлять противоречия, уточнять неоднозначности и ранжировать требования по важности.\n\n#### Проверка качества требований\n\nПосле сбора требований необходимо провести их анализ на соответствие ряду критериев, чтобы убедиться в готовности к использованию в разработке. Основные критерии:\n\n- **Полнота** — все необходимые функции, ограничения и условия учтены.\n- **Согласованность** — требования не противоречат друг другу.\n- **Реализуемость** — техническая возможность реализации с учетом имеющихся ресурсов и технологий.\n- **Проверяемость** — возможность подтвердить выполнение требования через тестирование или демонстрацию.\n- **Ясность** — отсутствие двусмысленностей и неоднозначных формулировок.\n\nНапример, требование «система должна быть быстрой» является неясным и непроверяемым. Его следует уточнить: «система должна отвечать на запрос пользователя не более чем за 2 секунды при нагрузке до 1000 пользователей одновременно».\n\n#### Методы приоритизации требований\n\nНе все требования одинаково важны. Приоритизация помогает определить, что реализовывать в первую очередь, особенно при ограниченных сроках и ресурсах.\n\n**1. Метод MoSCoW**\n\nРазделяет требования на четыре категории:\n- **Must have** — критически важные, без них система неработоспособна.\n- **Should have** — важные, но не обязательные; реализуются, если есть возможность.\n- **Could have** — желательные, но с низким приоритетом.\n- **Won’t have (this time)** — отложены на будущее.\n\nЧасто используется в гибких методологиях (например, Scrum).\n\n**2. Модель Кано (Kano Model)**\n\nКлассифицирует требования по влиянию на удовлетворённость пользователя:\n- **Основные (Basic)** — ожидаемые функции; их отсутствие вызывает недовольство.\n- **Производительные (Performance)** — чем лучше они реализованы, тем выше удовлетворённость.\n- **Радикальные (Excitement)** — неожиданные функции, вызывающие восторг.\n- **Безразличные** — не влияют на восприятие.\n\nПомогает выделить «must-have» и «delighters» — функции, повышающие лояльность.\n\n**3. Value vs. Effort (Ценность против трудозатрат)**\n\nТребования оцениваются по двум осям:\n- **Ценность для бизнеса/пользователя**\n- **Сложность реализации (трудозатраты)**\n\nНа основе графика выделяют:\n- **Quick Wins** — высокая ценность, низкие затраты (реализовать в первую очередь)\n- **Big Bets** — высокая ценность и высокие затраты (требуют планирования)\n- **Time Wasters** — низкая ценность, высокие затраты (избегать)\n- **Fill-Ins** — низкая ценность, низкие затраты (можно реализовать, если есть ресурсы)\n\n#### Управление конфликтами между требованиями\n\nКонфликты возникают, когда:\n- Требования противоречат друг другу (например, «высокая безопасность» vs. «максимальная скорость»).\n- Разные стейкхолдеры предъявляют взаимоисключающие требования.\n\n**Подходы к разрешению:**\n- Уточнение приоритетов с заказчиком.\n- Поиск компромиссов (например, двухфакторная аутентификация только для чувствительных операций).\n- Документирование принятых решений и обоснований.\n\n#### Трассируемость требований\n\nТрассируемость — это возможность отследить путь требования от первоначальной идеи до реализации и тестирования.\n\n**Матрица трассировки** — таблица, связывающая:\n- Источник требования (например, интервью с заказчиком)\n- Само требование\n- Дизайн/архитектура\n- Реализация (модули кода)\n- Тест-кейсы\n\n**Преимущества:**\n- Контроль изменений\n- Обеспечение покрытия тестами\n- Анализ влияния изменений (impact analysis)\n\nНапример, если изменяется требование, матрица помогает быстро определить, какие части системы и тесты затронуты.\n\n---\n\n**Практическое задание:**\n\n**Групповая работа — анализ «сырых» требований**\n\n1. Получите набор необработанных требований от «заказчика» (см. кейс).\n2. Проведите анализ: устраните неоднозначности, проверьте на полноту и согласованность.\n3. Приоритизируйте требования с помощью метода MoSCoW и модели Кано.\n4. Постройте простую матрицу трассировки (требование → тест-кейс).\n5. Обсудите конфликты и предложите решения.\n\n**Формат:** Групповая работа (3–4 человека) + презентация результатов и общее обсуждение."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 2.4: Документирование и управление требованиями\n\n**Цель:** Научиться оформлять требования в стандартизированной форме и управлять их изменениями.\n\n#### 1. Шаблоны документирования требований\n\nДля эффективной передачи требований команде разработки и обеспечения их однозначного понимания используются стандартизированные формы документирования. Наиболее распространённые из них:\n\n- **SRS (Software Requirements Specification)** — детальный технический документ, описывающий все функциональные и нефункциональные требования к системе. Обычно используется в традиционных (водопадных) моделях разработки. Включает:\n  - Введение (цель, область применения, ссылки)\n  - Описание системы (обзор, контекст)\n  - Функциональные требования (по модулям)\n  - Нефункциональные требования (производительность, безопасность, доступность)\n  - Интерфейсы (пользовательские, внешние системы)\n  - Ограничения и допущения\n\n- **User Story** — краткое описание функциональности с точки зрения пользователя. Используется в гибких методологиях (Agile, Scrum). Формат: \n  > *«Как [роль], я хочу [действие], чтобы [цель]»*\n  \n  Пример: *«Как пользователь, я хочу войти в систему через Google, чтобы не запоминать пароль»*\n\n- **Use Case (Сценарий использования)** — более формализованное описание взаимодействия актёров с системой. Включает:\n  - Название\n  - Актёры\n  - Предусловия\n  - Основной и альтернативные сценарии\n  - Постусловия\n  - Исключения\n\nUse case подходит для сложных процессов, где важно описать последовательность шагов и возможные ветвления.\n\n#### 2. Инструменты документирования и управления требованиями\n\nДля эффективной работы с требованиями используются специализированные инструменты:\n\n- **Jira** — система управления задачами и проектами. Позволяет создавать user stories, вести бэклог, назначать задачи, отслеживать прогресс. Поддерживает интеграцию с Confluence.\n\n- **Confluence** — платформа для совместной документации. Подходит для хранения SRS, use cases, диаграмм, требований и других материалов. Обеспечивает версионность и права доступа.\n\n- **ReqView** — специализированный инструмент для управления требованиями по стандарту DOORS. Поддерживает трассируемость, проверку полноты, экспорт в форматы PDF, Word, Excel. Подходит для проектов с высокими требованиями к документации (например, в авиации, медицине).\n\nВыбор инструмента зависит от методологии разработки, масштаба проекта и требований к аудиту.\n\n#### 3. Управление изменениями требований\n\nВ ходе разработки требования часто меняются. Для контроля изменений используется процесс **управления изменениями**:\n\n- **Change Request (Запрос на изменение)** — формализованная заявка на внесение изменений в требования. Содержит:\n  - Описание изменения\n  - Причину\n  - Автора\n  - Приоритет\n  - Оценку влияния\n\n- **Impact Analysis (Анализ влияния)** — оценка последствий изменения. Отвечает на вопросы:\n  - Какие модули затронуты?\n  - Требуется ли переработка дизайна или архитектуры?\n  - Как изменится срок и бюджет?\n  - Какие риски возникают?\n\nАнализ влияния помогает принимать обоснованные решения: принимать, отклонять или откладывать изменение.\n\n#### 4. Версионность и аудит требований\n\nДля обеспечения прозрачности и контроля используется:\n\n- **Версионность** — фиксация изменений в документах с указанием версии (например, v1.0, v1.1). Позволяет отслеживать историю изменений и возвращаться к предыдущим версиям.\n\n- **Аудит требований** — проверка соответствия документации, полноты, согласованности и трассируемости. Проводится перед ключевыми этапами (например, началом разработки или тестирования).\n\nВерсионность особенно важна при работе в команде и при прохождении регуляторных проверок (например, в банковской или медицинской сфере).\n\n---\n\n### Финальное задание модуля\n\n**Задача:** Подготовить документ SRS (или набор user stories + use cases) для учебного проекта с учётом всех этапов:\n- Сбор требований (интервью, анкетирование)\n- Анализ (классификация, выявление противоречий)\n- Приоритизация (метод MoSCoW или Kano)\n- Документирование (в выбранном формате)\n\n**Формат выполнения:** Практикум + защита задания\n\n**Требования к защите:**\n- Презентация структуры документа\n- Обоснование выбора формата (SRS / user stories / use cases)\n- Демонстрация работы с изменениями (например, как обработали бы change request)\n- Ответы на вопросы от команды и преподавателя\n\n---\n\n**Рекомендации:**\n- Используйте шаблоны из Confluence или ReqView\n- Оформите минимум 5 user stories или 3 use case, либо полный SRS (по выбору)\n- Укажите источники требований и проведите трассировку\n- Покажите, как вы управляете версиями и изменениями\n\nЭтот навык станет основой для дальнейшей работы в команде разработки и взаимодействия с заказчиками."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Рекомендуемые ресурсы:\n\nДля успешного освоения материала модуля и подготовки качественного документа требований рекомендуется использовать следующие источники и инструменты:\n\n- **Karl E. Wiegers, Joy Beatty — \"Software Requirements\" (3rd ed.)** — фундаментальный труд по управлению требованиями, охватывающий все этапы: от сбора до валидации. Книга содержит практические примеры, шаблоны и советы по работе с заказчиками.\n\n- **Alistair Cockburn — \"Writing Effective Use Cases\"** — подробное руководство по написанию эффективных прецедентов (use cases), включая уровни детализации, структуру и стиль изложения. Особенно полезно при проектировании функциональных требований.\n\n- **Шаблон IEEE 830 для SRS (Software Requirements Specification)** — стандарт IEEE, описывающий рекомендованную структуру документа спецификации требований к программному обеспечению. Использование шаблона помогает обеспечить полноту, ясность и согласованность документа.\n\n- **Статьи по методам приоритизации (MoSCoW, Kano)** — материалы, посвящённые методам определения важности требований. MoSCoW (Must have, Should have, Could have, Won’t have) и модель Кано (Kano Model) позволяют эффективно расставлять приоритеты в условиях ограниченных ресурсов.\n\n- **Документация Jira и Confluence** — официальные руководства по использованию инструментов Atlassian для управления требованиями, трассировки изменений и командной работы. Jira подходит для учёта и отслеживания требований, а Confluence — для совместного редактирования и хранения документации.\n\n---\n\n### Оценочные элементы:\n\nОценка по модулю складывается из формативных и суммативных компонентов, направленных на развитие практических навыков и итоговую проверку компетенций:\n\n- **Участие в интервью (формативное)** — оценка активности и качества взаимодействия с заказчиком (или его представителем) при сборе требований. Учитывается умение задавать правильные вопросы, выявлять скрытые потребности и вести запись.\n\n- **Групповое задание по приоритизации (формативное)** — командная работа по классификации и приоритизации набора требований с использованием методов MoSCoW или Kano. Оценивается логика принятия решений, обоснованность и согласованность в группе.\n\n- **Финальный документ требований (суммативное, 60%)** — основной итоговый продукт модуля. Документ должен быть оформлен в соответствии с выбранным шаблоном (например, IEEE 830), содержать полный набор функциональных и нефункциональных требований, прецеденты и, при необходимости, диаграммы. Оценивается полнота, ясность, структурированность и соответствие стандартам.\n\n- **Устная защита документа (суммативное, 40%)** — презентация и обоснование структуры и содержания документа перед преподавателем и/или группой. Проверяется понимание требований, умение аргументировать решения и отвечать на вопросы.\n\nЭти элементы обеспечивают комплексную оценку как индивидуальных, так и командных компетенций, необходимых для успешной работы аналитика в реальных проектах."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Тест по модулю 2: Сбор и анализ требований",
        "max_score": 100,
        "passing_score": 60,
        "questions": [
          {
            "text": "Опишите, как различаются функциональные, нефункциональные требования и ограничения. Приведите по два примера каждого типа применительно к системе бронирования переговорных комнат в IT-компании. Объясните, почему важно разделять эти категории на практике.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Объясните, как применение SMART-критериев помогает улучшить качество формулировок требований. Приведите пример 'плохой' формулировки требования (например, из кейса с бронированием переговорок) и перепишите её в соответствии с SMART. Обоснуйте каждую из пяти характеристик.",
            "options": [],
            "correct_answers": [],
            "points": 12
          },
          {
            "text": "Сравните подходы к работе с требованиями в каскадной (Waterfall) и гибкой (Agile) моделях разработки. Как влияет выбор модели на процессы сбора, документирования и управления изменениями требований? Приведите пример, когда каждая из моделей будет предпочтительнее.",
            "options": [],
            "correct_answers": [],
            "points": 14
          },
          {
            "text": "Опишите, какие методы сбора требований вы бы применили при разработке системы бронирования переговорных комнат. Обоснуйте выбор каждого метода, укажите, с какими стейкхолдерами вы бы работали и какие риски могут возникнуть при использовании этих методов.",
            "options": [],
            "correct_answers": [],
            "points": 13
          },
          {
            "text": "Что такое матрица трассировки требований и зачем она нужна? Постройте фрагмент матрицы (минимум 4 строки), связывающий функциональные требования и прецеденты для системы бронирования переговорок. Объясните, как эта матрица помогает при управлении изменениями и тестировании.",
            "options": [],
            "correct_answers": [],
            "points": 12
          },
          {
            "text": "Приоритизируйте следующие требования к системе бронирования переговорных с помощью метода MoSCoW. Для каждого укажите категорию и кратко обоснуйте свой выбор:\n- Возможность бронирования комнаты на будущее\n- Уведомление о начале встречи\n- Интеграция с календарём Google\n- Отчёт о загруженности переговорок по отделам\n- Двухфакторная аутентификация\n- Возможность отмены бронирования\n- Автоматическое освобождение комнаты при отсутствии пользователя\n- Поддержка мобильного приложения",
            "options": [],
            "correct_answers": [],
            "points": 14
          },
          {
            "text": "Что такое user journey и persona? Создайте одну persona для пользователя системы бронирования переговорных (укажите роль, цели, боли, техническую подготовку). Затем опишите её user journey при бронировании комнаты на важную встречу. Как эта информация может повлиять на проектирование интерфейса и функциональности?",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Объясните, зачем нужна проверка требований на полноту, согласованность и проверяемость. Приведите пример двух требований, которые кажутся корректными по отдельности, но в совокупности содержат противоречие. Как аналитик может выявить и разрешить такой конфликт?",
            "options": [],
            "correct_answers": [],
            "points": 10
          }
        ]
      }
    },
    {
      "id": "70601b76-7d82-4251-8409-055a3ccced00",
      "title": "Модуль 3: Управление изменениями требований",
      "description": "В этом модуле студенты научатся эффективно управлять изменениями в требованиях к программному обеспечению на протяжении всего жизненного цикла разработки. Особое внимание уделяется процессам трассировки, контроля версий, оценке влияния изменений и коммуникации с заинтересованными сторонами. Студенты освоят инструменты и практики, позволяющие минимизировать риски, связанные с изменением требований, и поддерживать согласованность между требованиями, архитектурой и реализацией.",
      "learning_objectives": [
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
        "Применять архитектурные паттерны и обосновывать их выбор.",
        "Документировать архитектурные решения по шаблону C4.",
        "Разрабатывать стратегию тестирования, включая нефункциональные аспекты.",
        "Оценивать качество ПО и управлять техническим долгом.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 3,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля: Управление изменениями требований",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 3: Управление изменениями требований] --> B[Тема 1: Введение в управление изменениями]\n    A --> C[Тема 2: Трассируемость требований]\n    A --> D[Тема 3: Процессы контроля изменений]\n    A --> E[Тема 4: Оценка влияния изменений]\n    A --> F[Тема 5: Инструменты и практики управления изменениями]\n    A --> G[Итоговое задание: Управление изменениями в командном проекте]\n```",
          "explanation": "Диаграмма отображает структуру Модуля 3 в виде направленного графа, показывая основные темы и итоговое задание, вытекающие из центрального модуля. Это помогает визуализировать логическую организацию содержания и последовательность изучения материала."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 1: Введение в управление изменениями\n\n#### Почему изменения требований неизбежны\n\nИзменения требований — неотъемлемая часть разработки программного обеспечения. Они возникают по множеству причин, таких как:\n\n- **Недостаточная проработка требований на начальных этапах.** Часто заказчики не могут сформулировать все свои потребности заранее, особенно в условиях сложных или быстро меняющихся бизнес-процессов.\n- **Изменение внешней среды.** Новые законы, стандарты, технологии или рыночные условия могут потребовать адаптации продукта.\n- **Обратная связь от пользователей.** После демонстрации прототипов или ранних версий продукта появляются уточнения и новые пожелания.\n- **Эволюция бизнеса.** Цели и стратегии заказчика могут меняться, что напрямую влияет на функциональность ПО.\n\nТаким образом, гибкость к изменениям — ключевое качество успешного проекта.\n\n#### Проблемы, вызванные неуправляемыми изменениями\n\nЕсли изменения в требованиях не контролируются, это может привести к серьёзным последствиям:\n\n- **Рост технического долга.** Быстрые правки без должного анализа ухудшают архитектуру и читаемость кода.\n- **Срыв сроков и бюджета.** Неучтённые изменения увеличивают объём работ, что ведёт к задержкам и перерасходу ресурсов.\n- **Потеря согласованности.** Требования, дизайн и реализация начинают расходиться, что затрудняет поддержку и тестирование.\n- **Конфликты между командами.** Без чёткого процесса принятия решений разработчики, аналитики и заказчики могут работать в разных направлениях.\n- **Снижение качества продукта.** Частые и хаотичные изменения повышают вероятность ошибок и ухудшают стабильность системы.\n\n#### Роль управления изменениями в жизненном цикле ПО\n\nУправление изменениями требований — это систематический процесс, охватывающий все стадии жизненного цикла разработки ПО: от анализа и проектирования до реализации, тестирования и сопровождения.\n\nЕго основная цель — обеспечить **контроль, прозрачность и согласованность** изменений. Это позволяет:\n\n- Поддерживать актуальность документации.\n- Минимизировать риски, связанные с внедрением изменений.\n- Обеспечивать трассируемость требований до архитектуры, кода и тестов.\n- Эффективно коммуницировать с заинтересованными сторонами.\n\nУправление изменениями особенно важно в итеративных и гибких методологиях (например, Scrum, Kanban), где изменения являются нормой, но должны быть структурированы.\n\n#### Основные понятия\n\n- **Change Request (Запрос на изменение)** — формальный документ, описывающий предложенное изменение в требованиях, дизайне или реализации. Включает описание изменения, обоснование, приоритет и инициатора.\n\n- **Impact Analysis (Анализ влияния)** — процесс оценки последствий изменения. Определяет, какие компоненты системы затронуты, сколько усилий потребуется, какие риски возникают и как изменение повлияет на сроки, бюджет и качество.\n\n- **Change Control Board (CCB, Комитет по контролю изменений)** — группа лиц (представители заказчика, архитекторы, менеджеры, ведущие разработчики), ответственная за рассмотрение и утверждение запросов на изменение. CCB принимает решения на основе анализа влияния и приоритетов проекта.\n\n#### Связь с архитектурой и техническим долгом\n\nАрхитектура ПО играет ключевую роль в управлении изменениями. Гибкая, модульная архитектура (например, на основе микросервисов или чётко выделенных слоёв) позволяет изолировать изменения и минимизировать их влияние на другие части системы.\n\nОднако каждое изменение может увеличить **технический долг**, особенно если:\n\n- Вносятся быстрые «костыли» вместо качественного рефакторинга.\n- Не обновляется документация или не проводится тестирование.\n- Нарушаются архитектурные принципы (например, единственная ответственность, инверсия зависимостей).\n\nЭффективное управление изменениями помогает контролировать технический долг, обеспечивая, что каждое изменение сопровождается оценкой долгосрочных последствий и, при необходимости, выделением задач по улучшению архитектуры."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 2: Трассируемость требований\n\n#### Что такое трассируемость и зачем она нужна\n\nТрассируемость требований — это способность отслеживать жизненный цикл каждого требования: от его первоначального появления (например, от заинтересованной стороны) через этапы анализа, проектирования, реализации и тестирования до финальной верификации. Другими словами, трассируемость позволяет ответить на вопросы: *«Почему было реализовано это поведение?», «Какие требования покрыты тестами?», «Какое влияние окажет изменение требования на архитектуру и код?»*.\n\n**Зачем нужна трассируемость:**\n- **Контроль изменений**: помогает оценить влияние изменений требований на другие артефакты (например, на модули кода или тесты).\n- **Обеспечение полноты реализации**: гарантирует, что все требования реализованы и протестированы.\n- **Управление рисками**: выявляет «потерянные» или неучтённые требования.\n- **Поддержка аудита и регуляторных требований**: особенно важно в критических системах (медицинское ПО, авионика и т.д.).\n- **Улучшение коммуникации**: обеспечивает прозрачность между командами (аналитики, разработчики, тестировщики).\n\n---\n\n#### Матрица трассируемости: от требований к тестам и архитектуре\n\nМатрица трассируемости — это табличное представление связей между различными артефактами разработки. Обычно строки представляют требования, а столбцы — связанные элементы: архитектурные компоненты, модули кода, тест-кейсы и т.д.\n\n**Пример матрицы трассируемости:**\n\n| ID требования | Описание требования | Архитектурный компонент | Модуль кода | Тест-кейс |\n|---------------|----------------------|--------------------------|-------------|-----------|\n| REQ-001       | Пользователь может войти в систему | Аутентификация | AuthService.java | TC_LOGIN_01 |\n| REQ-002       | Система должна хранить логи действий | Аудит | AuditLogger.py | TC_AUDIT_01 |\n\nТакая матрица позволяет быстро выявить:\n- Какие требования не покрыты тестами.\n- Какие компоненты затрагиваются при изменении требования.\n- Какие требования реализованы в каких модулях.\n\n---\n\n#### Уровни трассируемости (вверх/вниз, прямая/обратная)\n\nТрассируемость может быть организована на разных уровнях и направлениях:\n\n1. **Прямая (forward) трассировка** — от требований вперёд: к проектированию, реализации, тестированию.\n   - *Пример:* «Какие тесты проверяют REQ-001?»\n   - Цель: убедиться, что все требования реализованы и протестированы.\n\n2. **Обратная (backward) трассировка** — от артефактов обратно к требованиям.\n   - *Пример:* «На основе какого требования был написан модуль AuthService.java?»\n   - Цель: понять происхождение реализации, обосновать наличие кода.\n\n3. **Верхняя (upward) трассировка** — от нижележащих артефактов к вышестоящим (аналог обратной).\n   - *Пример:* от теста к требованию.\n\n4. **Нисходящая (downward) трассировка** — от требований к детализированным артефактам (аналог прямой).\n   - *Пример:* от требования к конкретному методу в коде.\n\n---\n\n#### Практическое построение цепочек трассировки\n\nДля построения цепочек трассировки рекомендуется следующий подход:\n\n1. **Присвоение уникальных идентификаторов** всем требованиям (например, REQ-001, NFR-005).\n2. **Использование инструментов поддержки**: Jira, Confluence, DOORS, Polarion, или Git с метками.\n3. **Создание явных ссылок** между артефактами:\n   - В Jira: связь задачи разработки с требованием через «исследует» (implements), «тестируется через» (tested by).\n   - В коде: комментарии вида `// Implements: REQ-001`.\n   - В тестах: указание ID требования в названии теста или метаданных.\n4. **Регулярная проверка полноты** трассировки (например, на этапе ревью или перед релизом).\n\n**Пример цепочки:**\n```\n[REQ-001] → [ARCH: AuthModule] → [CODE: AuthService.login()] → [TEST: TC_LOGIN_01]\n```\n\n---\n\n#### Интеграция трассируемости в процесс разработки\n\nТрассируемость не должна быть «накладной» активностью — она должна быть частью повседневного процесса. Для этого:\n\n- **Включите трассировку в Definition of Done (DoD)**: «Задача считается завершённой, если она связана с требованием и покрыта тестом».\n- **Автоматизируйте, где возможно**: инструменты вроде Jenkins или GitLab CI могут проверять наличие ссылок на требования в коммитах.\n- **Проводите регулярные аудиты трассируемости** — особенно перед релизами.\n- **Обучайте команду** важности трассировки и способам её поддержания.\n- **Используйте шаблоны документов**, где поля для ссылок на требования обязательны.\n\n**Вывод:** Трассируемость — это не просто формальность, а мощный механизм обеспечения качества, контроля изменений и прозрачности разработки. Её систематическое применение снижает риски, упрощает сопровождение и повышает доверие со стороны заказчиков и регуляторов."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 3: Процессы контроля изменений\n\nУправление изменениями требований — ключевой элемент успешной разработки программного обеспечения. Без чётко выстроенных процессов контроля изменений проект может быстро выйти из-под контроля: требования начнут противоречить друг другу, артефакты разработки — рассинхронизируются, а технический долг — расти. В этой теме рассматриваются стандартизированные подходы к управлению изменениями, роли участников, жизненный цикл запроса на изменение и инструментальная поддержка.\n\n#### Стандартизированные процессы: от подачи заявки до внедрения\n\nПроцесс контроля изменений (Change Control Process) — это формализованная последовательность шагов, обеспечивающая управляемое и контролируемое внесение изменений в требования, архитектуру или реализацию ПО. Он включает следующие этапы:\n\n1. **Инициирование запроса на изменение (Change Request, CR)** — любая заинтересованная сторона может инициировать запрос, описав суть изменения, его обоснование и ожидаемое влияние.\n2. **Регистрация и классификация** — запрос фиксируется в системе, присваивается уникальный идентификатор, определяется тип (функциональное/нефункциональное изменение, исправление ошибки и т.д.) и приоритет.\n3. **Анализ влияния (Impact Analysis)** — аналитик и архитектор оценивают последствия изменения: какие требования, компоненты, тесты и документы затронуты, сколько усилий потребуется, есть ли риски.\n4. **Рассмотрение и принятие решения (Review & Approval)** — запрос рассматривается Комитетом по контролю изменений (CCB), который решает, принимать ли его, отклонять или откладывать.\n5. **Реализация** — после утверждения изменение передаётся в работу: разработчики вносят правки, тестировщики обновляют тесты, документация актуализируется.\n6. **Верификация и внедрение** — изменения проверяются, тестируются и внедряются в целевую среду.\n7. **Закрытие запроса** — после успешного внедрения запрос закрывается, все артефакты обновляются, и информация о внесённом изменении фиксируется.\n\n#### Роли в процессе: инициатор, аналитик, архитектор, CCB\n\n- **Инициатор** — лицо или сторона, предлагающая изменение (клиент, пользователь, разработчик). Формулирует запрос и обосновывает его необходимость.\n- **Аналитик** — анализирует запрос, уточняет детали, оценивает влияние на требования, документирует изменения и обеспечивает согласованность.\n- **Архитектор** — оценивает влияние на архитектуру, проверяет соответствие паттернам, масштабируемости и надёжности, предлагает альтернативные решения при необходимости.\n- **Комитет по контролю изменений (Change Control Board, CCB)** — группа лиц (часто включает представителей бизнеса, разработки, тестирования, управления проектом), которая принимает окончательное решение по запросу. CCB обеспечивает баланс между бизнес-потребностями и техническими ограничениями.\n\n#### Жизненный цикл change request\n\nЖизненный цикл запроса на изменение включает следующие статусы:\n\n- **Новый (New)** — запрос подан и зарегистрирован.\n- **На анализе (Under Analysis)** — проводится оценка влияния.\n- **На рассмотрении (Under Review)** — запрос представлен CCB.\n- **Утверждён (Approved)** / **Отклонён (Rejected)** / **Отложен (Deferred)** — принято решение.\n- **В реализации (In Progress)** — изменения вносятся в код и документацию.\n- **Протестирован (Tested)** — изменения проверены.\n- **Внедрён (Implemented)** — изменения развернуты в целевой среде.\n- **Закрыт (Closed)** — процесс завершён, артефакты актуализированы.\n\nТрассируемость на каждом этапе позволяет отслеживать происхождение и статус изменений.\n\n#### Управление версиями требований\n\nТребования, как и код, подвержены изменениям. Управление их версиями необходимо для:\n\n- Поддержания согласованности между версиями ПО и требованиями.\n- Возможности отката к предыдущим версиям.\n- Аудита и отчётности.\n\nДля этого используются:\n\n- Системы контроля версий (например, Git — для текстовых спецификаций).\n- Специализированные инструменты (DOORS, Jama, Polarion), поддерживающие версионность и аудит.\n- Чёткая политика именования версий (например, семантическое версионирование: 1.2.0).\n\nКаждое изменение в требованиях должно быть привязано к конкретному change request и сопровождаться комментарием.\n\n#### Интеграция с системами управления задачами (Jira, Azure DevOps)\n\nСовременные инструменты управления проектами позволяют автоматизировать процессы контроля изменений. Например:\n\n- В **Jira** можно создать тип задачи \"Change Request\", настроить workflow, соответствующий жизненному циклу, и связать его с эпиками, задачами и багами.\n- В **Azure DevOps** аналогично используются Work Items с кастомными состояниями и правилами перехода.\n\nИнтеграция обеспечивает:\n\n- Трассируемость: от требования → к задаче → к коммиту → к тесту.\n- Автоматизацию уведомлений и отчётов.\n- Централизованное хранение всей информации об изменениях.\n\nТаким образом, эффективный процесс контроля изменений — это не просто бюрократия, а необходимая практика для поддержания качества, предсказуемости и прозрачности разработки ПО."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 4: Оценка влияния изменений\n\nПри разработке программного обеспечения изменения требований — неотъемлемая часть процесса. Однако каждое изменение может оказать значительное влияние на различные аспекты проекта: архитектуру, реализацию, тестирование и документацию. Чтобы минимизировать риски и сохранить качество системы, необходимо проводить **оценку влияния изменений (impact analysis)** — систематический процесс анализа последствий предполагаемого изменения.\n\n#### Методы анализа влияния (Impact Analysis)\n\nАнализ влияния помогает определить, какие части системы затронуты изменением, и оценить объём необходимой работы. Основные методы включают:\n\n- **Трассировка требований** — использование матриц трассируемости для отслеживания связей между требованиями, архитектурными решениями, компонентами кода и тестами. Это позволяет быстро выявить все зависимые элементы.\n- **Анализ зависимостей** — изучение архитектурных и кодовых зависимостей (например, с помощью графов вызовов, UML-диаграмм или инструментов статического анализа).\n- **Мозговой штурм с командой** — привлечение разработчиков, тестировщиков и архитекторов для выявления потенциальных последствий на основе экспертной оценки.\n- **Использование CASE-инструментов** — автоматизированные средства (например, Jira с плагинами, DOORS, Jama Connect), которые поддерживают трассировку и анализ влияния.\n\n<tool_call>\n{\"name\": \"knowledge_search\", \"arguments\": {\"search_query\": \"методы анализа влияния изменений в требованиях\", \"category\": \"theory\"}}\nça"
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5: Инструменты и практики управления изменениями\n\nУправление изменениями требований — критически важный аспект разработки программного обеспечения, особенно в условиях динамичной среды, где требования могут изменяться на любом этапе жизненного цикла. Эффективное управление изменениями обеспечивает согласованность между требованиями, архитектурой, реализацией и тестированием, минимизируя риски ошибок, перерасхода бюджета и срывов сроков.\n\n#### Обзор инструментов: Jira, Confluence, Polarion, DOORS\n\nДля поддержки процессов управления изменениями используются специализированные инструменты, которые позволяют централизованно хранить, отслеживать и контролировать требования и их изменения.\n\n- **Jira** (Atlassian) — одна из самых популярных систем управления задачами и проектами. Jira позволяет создавать задачи (issues), связывать их с требованиями, отслеживать статус выполнения и настраивать сложные workflow. Благодаря интеграции с Confluence и другим инструментами, Jira активно используется в гибких методологиях (Agile, Scrum, Kanban).\n\n- **Confluence** — также от Atlassian, служит платформой для совместной документации. В контексте управления требованиями Confluence используется для хранения спецификаций, протоколов встреч, матриц трассировки и отчётов. Интеграция с Jira позволяет напрямую ссылаться на задачи и требования.\n\n- **Polarion ALM** — полнофункциональная система управления жизненным циклом приложений (Application Lifecycle Management), ориентированная на промышленные и регулируемые отрасли (автомобильная, медицинская, аэрокосмическая). Polarion поддерживает трассируемость требований «сверху донизу», управление версиями, аудит изменений и соответствие стандартам (например, ISO 26262, DO-178C).\n\n- **IBM DOORS (Dynamic Object-Oriented Requirements System)** — классический инструмент для управления требованиями, широко используемый в крупных инженерных проектах. DOORS обеспечивает мощные возможности по версионированию, трассировке и анализу требований. Современная версия — DOORS Next — построена на веб-платформе и поддерживает интеграцию с другими инструментами IBM ELM (Engineering Lifecycle Management).\n\n#### Настройка workflow для управления изменениями\n\nWorkflow (или жизненный цикл задачи) — это последовательность статусов и переходов, через которые проходит требование или запрос на изменение (Change Request). Правильно настроенный workflow обеспечивает контроль над процессом и предотвращает неконтролируемые изменения.\n\nТипичный workflow для управления изменениями включает следующие статусы:\n\n1. **Инициировано** — подан запрос на изменение.\n2. **На оценке** — аналитик или комитет по контролю изменений (Change Control Board, CCB) оценивает влияние изменения.\n3. **Утверждено / Отклонено** — решение по запросу.\n4. **В работе** — разработка или проектирование изменений.\n5. **Протестировано** — проверка реализации.\n6. **Завершено** — изменение внедрено и документировано.\n\nПереходы между статусами могут быть защищены правами доступа и требовать комментариев, прикрепления артефактов или согласования.\n\n<tool_call>\n{\"name\": \"knowledge_search\", \"arguments\": {\"search_query\": \"примеры workflow в Jira для управления изменениями требований\", \"category\": \"materials\"}}\n</tool_call>"
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Итоговое задание: Управление изменениями в командном проекте\n\nВ рамках данного итогового задания студенты применяют полученные знания и навыки из Модуля 3 на практике, работая в командах над мини-проектом по разработке программного обеспечения. Задание моделирует реальные условия разработки, где требования не остаются неизменными, а эволюционируют в ходе проекта. Цель — отработать процессы управления изменениями требований, обеспечить трассируемость, оценить влияние изменений и поддерживать согласованность между всеми артефактами проекта.\n\n#### Этапы выполнения задания:\n\n1. **Получение первоначальных требований**\n   Каждая команда получает набор начальных функциональных и нефункциональных требований к системе (например, разработка веб-приложения для управления задачами). Требования должны быть задокументированы в структурированном виде (например, в виде таблицы или с использованием шаблона user story).\n\n2. **Моделирование изменений требований**\n   Преподаватель или команда имитирует поступление новых или изменённых требований. Примеры изменений:\n   - Добавление новой роли пользователя (например, «Менеджер»).\n   - Изменение способа аутентификации (переход на OAuth).\n   - Ужесточение требований к производительности (время отклика < 500 мс).\n   - Добавление требования к локализации (поддержка 3 языков).\n\n3. **Анализ влияния изменений**\n   Для каждого изменения команда проводит анализ влияния (impact analysis), включая:\n   - Оценку затронутых компонентов системы.\n   - Определение рисков (технических, временных, ресурсных).\n   - Оценку влияния на архитектуру, тестирование и документацию.\n   - Прогнозирование влияния на сроки и бюджет.\n\n4. **Обновление матрицы трассируемости**\n   Команда обновляет матрицу трассируемости требований, отражая:\n   - Связи между новыми/изменёнными требованиями и архитектурными элементами.\n   - Связи с тестовыми сценариями и реализованным кодом.\n   - Статус реализации и проверки каждого требования.\n\n5. **Оформление запроса на изменение (Change Request)**\n   Каждое изменение оформляется как формальный **Change Request**, включающий:\n   - Описание изменения.\n   - Инициатора и дату подачи.\n   - Обоснование необходимости.\n   - Результаты анализа влияния.\n   - Рекомендации по реализации.\n   - Подписи утверждающих сторон (в учебном контексте — имитация согласования).\n\n6. **Обновление архитектурной документации (по шаблону C4)**\n   На основе внесённых изменений команда актуализирует архитектурные диаграммы и описания в соответствии с методологией C4:\n   - Контекст (C1), Контейнеры (C2), Компоненты (C3), Код (C4).\n   - Документируются изменения в структуре, взаимодействиях, технологическом стеке.\n\n7. **Подготовка итогового отчёта**\n   Команда представляет финальный отчёт, содержащий:\n   - Перечень всех изменений и их статус.\n   - Анализ последствий изменений для проекта.\n   - Выводы по эффективности процесса управления изменениями.\n   - Рекомендации по улучшению процессов в будущих проектах.\n\n#### Критерии оценки:\n- Полнота и качество анализа влияния изменений.\n- Актуальность и корректность матрицы трассируемости.\n- Формальность и полнота оформления Change Request.\n- Соответствие обновлённой архитектурной документации стандарту C4.\n- Чёткость и структурированность итогового отчёта.\n- Командная работа и распределение ответственности.\n\n#### Цель задания:\nНаучиться управлять изменениями в условиях динамичной среды разработки, минимизируя риски, поддерживая качество и согласованность артефактов, а также развивать навыки коммуникации и согласования решений с заинтересованными сторонами."
        }
      ],
      "assignment": {
        "assignment_type": "github",
        "version": 0,
        "title": "Практическое задание: Управление изменениями требований в командном проекте",
        "max_score": 100,
        "passing_score": 70,
        "repository_task": "https://github.com/edu-swe/module-3-change-management",
        "repository_rules": "https://github.com/edu-swe/course-rules",
        "required_branch": "main"
      }
    },
    {
      "id": "4a0ef399-c21c-4f18-ad2c-0c9007a8f738",
      "title": "Модуль 4: Архитектура ПО: основные понятия",
      "description": "В этом модуле студенты познакомятся с фундаментальными концепциями архитектуры программного обеспечения. Будут рассмотрены ключевые аспекты проектирования систем с учётом масштабируемости, надёжности и поддерживаемости. Особое внимание уделено практическому применению архитектурных паттернов, документированию решений по методологии C4 и управлению качеством архитектуры. Модуль закладывает основу для системного подхода к разработке ПО и подготовки к работе в командной среде.",
      "learning_objectives": [
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
        "Применять архитектурные паттерны и обосновывать их выбор.",
        "Документировать архитектурные решения по шаблону C4.",
        "Разрабатывать стратегию тестирования, включая нефункциональные аспекты.",
        "Оценивать качество ПО и управлять техническим долгом.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 4,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля 4: Архитектура ПО",
          "mermaid_code": "```mermaid\n%%{init: {'theme': 'neutral'}}%%\ngraph TD\n    A[Модуль 4: Архитектура ПО: основные понятия] --> B[Тема 4.1: Введение в архитектуру ПО]\n    A --> C[Тема 4.2: Требования к системе: функциональные и нефункциональные]\n    A --> D[Тема 4.3: Архитектурные паттерны и стили]\n    A --> E[Тема 4.4: Документирование архитектуры: C4 Model]\n    A --> F[Тема 4.5: Качество ПО и технический долг]\n    A --> G[Тема 4.6: Командная работа и управление изменениями]\n\n    B --> B1[Что такое архитектура ПО? Роль архитектора]\n    B --> B2[Этапы жизненного цикла ПО: от идеи до эксплуатации]\n    B --> B3[Архитектурные решения и их влияние на систему]\n\n    C --> C1[Сбор и анализ требований: методы и инструменты]\n    C --> C2[Функциональные требования: use case, user stories]\n    C --> C3[Нефункциональные требования: производительность, безопасность, доступность]\n    C --> C4[Трассируемость требований]\n\n    D --> D1[Обзор архитектурных стилей: монолит, микросервисы, событийная архитектура]\n    D --> D2[Сравнение паттернов: MVC, Layered, CQRS, Hexagonal]\n    D --> D3[Выбор архитектуры: обоснование и trade-offs]\n    D --> D4[Практическое задание: проектирование архитектуры для типовой системы]\n\n    E --> E1[Принципы документирования архитектуры]\n    E --> E2[C4 Model: уровни Context, Container, Component, Code]\n    E --> E3[Инструменты: Structurizr, PlantUML]\n    E --> E4[Практика: создание C4-диаграмм для учебного проекта]\n\n    F --> F1[Метрики качества ПО: coupling, cohesion, cyclomatic complexity]\n    F --> F2[Оценка архитектурного здоровья]\n    F --> F3[Технический долг: виды, оценка, управление]\n    F --> F4[Стратегии тестирования: unit, integration, E2E, нагрузочное тестирование]\n\n    G --> G1[Командная разработка: роли, коммуникация, ревью архитектуры]\n    G --> G2[Управление изменениями: change requests, impact analysis]\n    G --> G3[Инструменты: Jira, Confluence, Git]\n    G --> G4[Итоговый проект: разработка архитектуры системы с полной документацией и стратегией тестирования]\n```",
          "explanation": "Данная диаграмма в формате Mermaid представляет структуру модуля 4 в виде древовидной блок-схемы (flowchart TD). Она отражает иерархию тем и подтем, раскрывающих ключевые аспекты архитектуры программного обеспечения. Диаграмма помогает визуализировать логическую структуру модуля и взаимосвязь между его компонентами, что способствует лучшему пониманию и планированию обучения."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "Модуль построен по принципу «от теории к практике», что позволяет студентам не только изучить ключевые концепции архитектуры программного обеспечения, но и сразу применить их в реальных сценариях. Каждая тема модуля включает лекционную часть, в которой рассматриваются фундаментальные понятия и современные подходы к проектированию ПО. Далее следуют примеры из реальных проектов, демонстрирующие, как те или иные архитектурные решения применяются в промышленной разработке — от выбора паттернов до управления техническим долгом.\n\nПрактические задания охватывают все ключевые аспекты архитектурной деятельности: сбор и анализ требований, проектирование системы с учётом нефункциональных характеристик (масштабируемость, надёжность, поддерживаемость), документирование решений по методологии C4 и разработка стратегии тестирования. Особое внимание уделено командной работе: студенты учатся взаимодействовать в распределённой среде, использовать инструменты трассируемости требований и управления изменениями, а также обосновывать свои архитектурные решения.\n\nЗавершается каждая тема рефлексией — студенты анализируют выполненные задания, оценивают эффективность выбранных решений и формулируют выводы, способствующие глубокому усвоению материала. Такой подход формирует системное мышление и готовит к реальным вызовам, с которыми сталкиваются архитекторы ПО в профессиональной среде."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "Итоговый проект модуля направлен на комплексное применение всех изученных тем и навыков, позволяя студентам продемонстрировать своё понимание архитектуры программного обеспечения в реалистичном контексте. Проект предполагает разработку архитектурной документации для условной системы — например, онлайн-платформы для курсов (аналога Coursera или Stepik).\n\nВ рамках проекта необходимо выполнить следующие ключевые этапы:\n\n1. **Сбор и анализ требований**\n   - Определение функциональных требований (например, регистрация пользователей, просмотр курсов, сдача заданий, выдача сертификатов).\n   - Формулировка нефункциональных требований: масштабируемость, доступность, безопасность, производительность, поддерживаемость.\n\n2. **Проектирование архитектуры системы**\n   - Выбор подходящего архитектурного паттерна (например, микросервисная архитектура, слоистая архитектура или событийно-ориентированная архитектура) с обоснованием выбора.\n   - Учёт требований к надёжности, отказоустойчивости и масштабируемости при проектировании.\n\n3. **Документирование архитектурных решений по методологии C4**\n   - Создание C4-диаграмм на четырёх уровнях:\n     - **Контекст (C1)** — система в окружении пользователей и внешних систем.\n     - **Контейнеры (C2)** — основные компоненты системы (веб-приложение, API, база данных, шина сообщений и т.д.).\n     - **Компоненты (C3)** — ключевые модули внутри контейнеров.\n     - **Код (C4)** — детализация на уровне классов (по необходимости).\n\n4. **Разработка стратегии тестирования**\n   - Планирование тестирования на всех уровнях: модульное, интеграционное, сквозное.\n   - Учёт нефункциональных аспектов: нагрузочное тестирование, тестирование безопасности, проверка отказоустойчивости.\n\n5. **Оценка качества ПО и управление техническим долгом**\n   - Идентификация потенциальных источников технического долга (например, упрощённые решения в ущерб архитектуре, отсутствие тестов).\n   - Предложение мер по минимизации и управлению долгом (рефакторинг, автоматизация, документирование).\n\nПроект позволяет интегрировать теоретические знания в практическую работу, формируя у студентов системное мышление и навыки архитектора ПО. Результатом станет полная архитектурная документация, пригодная для презентации команде разработчиков и стейкхолдерам."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Практическое задание: Разработка архитектуры онлайн-платформы для обучения",
        "max_score": 100,
        "passing_score": 70,
        "questions": [
          {
            "text": "Опишите, как вы будете собирать и анализировать функциональные и нефункциональные требования для онлайн-платформы обучения (аналог Coursera). Какие методы и инструменты вы примените? Приведите примеры как минимум трёх функциональных и трёх нефункциональных требований, обосновав их важность для системы.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Выберите архитектурный паттерн (например, микросервисы, слоистая архитектура, событийно-ориентированная архитектура) для проектирования платформы. Обоснуйте свой выбор, указав, какие нефункциональные требования он помогает удовлетворить, а также опишите возможные trade-offs (компромиссы) и риски.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Постройте диаграмму C4 уровня 'Контекст' (C1) для системы. Опишите основные внешние пользователи (акторы) и взаимодействующие внешние системы (например, платежные шлюзы, системы рассылок, SSO). Объясните, как данная диаграмма помогает стейкхолдерам понять систему в целом.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Разработайте диаграмму C4 уровня 'Контейнеры' (C2). Определите ключевые контейнеры (например, веб-фронтенд, мобильное приложение, API-шлюз, микросервисы, базы данных, брокер сообщений). Опишите технологический стек каждого контейнера и взаимодействие между ними.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "На уровне 'Компоненты' (C3) выберите один из контейнеров (например, микросервис управления курсами) и детализируйте его. Опишите ключевые компоненты внутри этого контейнера, их ответственность и взаимодействие. Какие принципы проектирования (например, SOLID, разделение ответственностей) вы применили?",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Разработайте стратегию тестирования для системы. Включите в неё типы тестов: модульные, интеграционные, сквозные (E2E), нагрузочные и тесты безопасности. Объясните, на каких уровнях и для каких компонентов они применяются, и как способствуют обеспечению качества ПО.",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Оцените потенциальные источники технического долга в предложенной архитектуре. Какие решения могут быть приняты в ущерб долгосрочной поддерживаемости? Предложите конкретные меры по управлению техническим долгом (например, рефакторинг, автоматизированное тестирование, документирование).",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Как вы будете организовывать командную разработку и управление изменениями в проекте? Опишите, какие инструменты (например, Jira, Confluence, Git) вы будете использовать и как обеспечите трассируемость требований и архитектурных решений.",
            "options": [],
            "correct_answers": [],
            "points": 5
          },
          {
            "text": "Проведите самоанализ выполненного задания: какие аспекты архитектурного проектирования оказались наиболее сложными? Какие решения вы бы изменили при наличии дополнительной информации или времени? Как данный опыт повлиял на ваше понимание роли архитектора ПО?",
            "options": [],
            "correct_answers": [],
            "points": 5
          }
        ]
      }
    },
    {
      "id": "f286acc3-f914-4e21-866b-524a2b21a0f3",
      "title": "Модуль 5: Архитектурные стили и паттерны",
      "description": "В этом модуле студенты углубляются в понимание архитектурных решений в разработке программного обеспечения. На основе знаний о жизненном цикле ПО и требованиях, полученных в предыдущих модулях, они учатся проектировать масштабируемые, надёжные и поддерживаемые системы. Акцент делается на применении архитектурных стилей и паттернов, их сравнении и обосновании выбора в зависимости от контекста проекта. Студенты осваивают документирование архитектуры по шаблону C4, учатся оценивать качество архитектурных решений и управлять техническим долгом. Модуль завершается командным проектом, в котором студенты проектируют архитектуру реального приложения с полной трассировкой от требований до тестирования.",
      "learning_objectives": [
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
        "Применять архитектурные паттерны и обосновывать их выбор.",
        "Документировать архитектурные решения по шаблону C4.",
        "Разрабатывать стратегию тестирования, включая нефункциональные аспекты.",
        "Оценивать качество ПО и управлять техническим долгом.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 5,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля 5: Архитектурные стили и паттерны",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 5: Архитектурные стили и паттерны] --> B[Тема 1: Введение в архитектуру ПО]\n    A --> C[Тема 2: Архитектурные стили]\n    A --> D[Тема 3: Архитектурные паттерны]\n    A --> E[Тема 4: Документирование архитектуры (C4)]\n    A --> F[Тема 5: Оценка качества и технический долг]\n    A --> G[Тема 6: Командный проект: проектирование архитектуры приложения]\n```",
          "explanation": "Диаграмма отображает структуру модуля 5, показывая, как основной модуль разбивается на шесть ключевых тем. Каждая тема представляет собой логический блок содержания, ведущий к финальному командному проекту."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 1: Введение в архитектуру ПО\n\nАрхитектура программного обеспечения (ПО) — это фундаментальное представление системы, определяющее её структуру, компоненты, их взаимодействие и принципы организации. Она играет ключевую роль на всех этапах жизненного цикла разработки ПО и служит основой для принятия технических решений, управления сложностью и обеспечения долгосрочной поддержки системы.\n\n#### Роль архитектуры в жизненном цикле ПО\n\nАрхитектура ПО не является изолированным этапом, а пронизывает весь жизненный цикл разработки:\n\n- **Анализ требований**: архитектор участвует в выявлении и интерпретации как функциональных, так и нефункциональных требований, транслируя их в архитектурные ограничения и решения.\n- **Проектирование**: на этом этапе формируется структура системы — выбираются компоненты, определяются их интерфейсы и взаимодействия.\n- **Реализация**: разработчики следуют архитектурным решениям, что обеспечивает согласованность кода и соответствие общей структуре.\n- **Тестирование**: архитектура помогает определить стратегию тестирования, особенно в части интеграционных и нагрузочных тестов.\n- **Сопровождение и эволюция**: хорошая архитектура упрощает внесение изменений, добавление новых функций и рефакторинг.\n\nТаким образом, архитектура выступает как «мост» между бизнес-требованиями и технической реализацией.\n\n#### Основные цели архитектурного проектирования\n\nАрхитектурное проектирование направлено на достижение трёх ключевых целей:\n\n1. **Масштабируемость** — способность системы эффективно справляться с ростом нагрузки (пользователей, данных, транзакций). Это достигается за счёт горизонтального или вертикального масштабирования, а также использования распределённых архитектур (например, микросервисов).\n\n2. **Надёжность** — способность системы продолжать корректно функционировать даже при частичных сбоях. Обеспечивается через механизмы резервирования, отказоустойчивость, мониторинг и автоматическое восстановление.\n\n3. **Поддерживаемость** — лёгкость внесения изменений, исправления ошибок и добавления новых функций. Достигается за счёт модульности, чёткого разделения ответственностей, документации и следования устоявшимся паттернам.\n\nЭти цели часто конфликтуют между собой, и задача архитектора — находить разумный компромисс, исходя из контекста проекта.\n\n#### Связь архитектуры с требованиями\n\nАрхитектура напрямую зависит от требований к системе:\n\n- **Функциональные требования** определяют, *что* должна делать система. Они влияют на выбор компонентов и их взаимодействие. Например, требование «пользователь может загружать файлы» может повлиять на проектирование сервиса хранения и API для загрузки.\n\n- **Нефункциональные требования** (NF-требования) определяют *качество* системы: производительность, безопасность, доступность, удобство сопровождения и т.д. Именно они в большей степени формируют архитектурные решения. Например, требование «система должна обрабатывать 10 000 запросов в секунду» напрямую ведёт к выбору распределённой архитектуры и кэширования.\n\nАрхитектура служит механизмом *реализации* этих требований и позволяет *документировать*, *проверять* и *тестировать* их выполнение.\n\n#### Архитектор ПО: роли и ответственность\n\nАрхитектор ПО — это технический лидер, отвечающий за стратегические решения в области проектирования системы. Его ключевые роли включают:\n\n- **Принятие архитектурных решений**: выбор стилей, паттернов, технологий и платформ.\n- **Коммуникация**: взаимодействие с заказчиками, аналитиками, разработчиками и DevOps для согласования требований и решений.\n- **Документирование архитектуры**: использование стандартов, таких как C4, для создания понятных и актуальных диаграмм и описаний.\n- **Оценка рисков и технического долга**: выявление потенциальных проблем на ранних этапах и предложение мер по их устранению.\n- **Менторство и поддержка команды**: помощь разработчикам в понимании архитектуры и следовании ей.\n\nАрхитектор не только проектирует систему, но и несёт ответственность за её долгосрочное здоровье.\n\n#### Обзор процесса архитектурного проектирования\n\nПроцесс архитектурного проектирования включает следующие этапы:\n\n1. **Сбор и анализ требований** — выявление ключевых функциональных и нефункциональных требований.\n2. **Определение архитектурных целей** — формулировка приоритетов (например, производительность важнее простоты).\n3. **Выбор архитектурного стиля** — например, монолит, микросервисы, событийная архитектура.\n4. **Разработка структуры системы** — определение компонентов, их интерфейсов и взаимодействий.\n5. **Применение паттернов проектирования** — использование проверенных решений для типовых задач (например, шлюз API, реестр служб).\n6. **Документирование архитектуры** — создание диаграмм и текстовых описаний по шаблону C4.\n7. **Оценка и рецензирование** — анализ архитектуры на соответствие требованиям, проведение архитектурных совещаний (архитектурных ревью).\n8. **Итерация и эволюция** — адаптация архитектуры по мере изменения требований и появления новых данных.\n\nЭтот процесс итеративен и тесно связан с Agile-подходами, где архитектура развивается постепенно, а не проектируется полностью «заранее».\n\nВ следующих темах мы подробно рассмотрим конкретные архитектурные стили и паттерны, а также инструменты их документирования и оценки."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 2: Архитектурные стили\n\n#### Что такое архитектурный стиль? Классификация\n\nАрхитектурный стиль — это набор принципов, шаблонов и ограничений, определяющих структуру программной системы. Он описывает, как компоненты системы взаимодействуют между собой, как организованы данные и управление, а также какие общие паттерны используются при проектировании. Архитектурный стиль задаёт «архитектурный язык», который помогает разработчикам и архитекторам эффективно коммуницировать, проектировать и оценивать системы.\n\nКлассификация архитектурных стилей может быть выполнена по разным критериям:\n- **По степени централизации**: централизованные (например, монолит) vs. децентрализованные (микросервисы, event-driven).\n- **По способу взаимодействия компонентов**: синхронные (HTTP, RPC) vs. асинхронные (сообщения, события).\n- **По уровню масштабируемости и модульности**: жёстко связанные vs. слабо связанные системы.\n- **По способу развертывания**: единое развертывание vs. независимые сервисы.\n\nРассмотрим основные архитектурные стили, применяемые в современной разработке ПО.\n\n#### Монолитная архитектура: плюсы и минусы\n\nМонолитная архитектура — это подход, при котором всё приложение (все компоненты: пользовательский интерфейс, бизнес-логика, доступ к данным) реализованы как единое приложение, собираемое и развертываемое как один модуль.\n\n**Преимущества**:\n- Простота разработки и отладки на ранних этапах.\n- Единая кодовая база упрощает управление зависимостями.\n- Простое развертывание (один артефакт).\n- Высокая производительность за счёт отсутствия сетевых вызовов между компонентами.\n\n**Недостатки**:\n- Сложность масштабирования: масштабируется вся система целиком.\n- Высокая связанность компонентов — изменения в одной части могут повлиять на всю систему.\n- Долгое время сборки и тестирования.\n- Технический долг накапливается быстрее.\n- Сложность внедрения новых технологий.\n\nМонолит подходит для небольших проектов или MVP, но становится проблемой при росте команды и функциональности.\n\n#### Многоуровневая архитектура (n-tier)\n\nМногоуровневая архитектура — это разновидность монолита, в которой компоненты разделены по уровням (слоям), каждый из которых отвечает за определённую функциональность. Наиболее распространённая — трёхуровневая архитектура:\n\n1. **Представление (Presentation Layer)** — пользовательский интерфейс.\n2. **Бизнес-логика (Business Logic Layer)** — обработка данных, правила домена.\n3. **Уровень данных (Data Access Layer)** — работа с базой данных.\n\n**Преимущества**:\n- Чёткое разделение ответственностей.\n- Упрощение тестирования и поддержки.\n- Возможность замены отдельных слоёв без переписывания всей системы.\n\n**Недостатки**:\n- Всё ещё централизованная система.\n- Масштабирование — по всей системе.\n- Риск «тонких» или «толстых» слоёв при плохом проектировании.\n\nЭтот стиль часто используется в корпоративных приложениях и является промежуточным шагом между монолитом и микросервисами.\n\n#### Микросервисы: принципы, преимущества, сложности\n\nМикросервисная архитектура — это подход, при котором приложение состоит из множества небольших, независимо развертываемых сервисов, каждый из которых отвечает за одну бизнес-функцию.\n\n**Принципы**:\n- **Автономность**: каждый сервис независим в разработке, развертывании и масштабировании.\n- **Слабая связанность**: сервисы взаимодействуют через чётко определённые API (чаще всего REST, gRPC).\n- **Организация по бизнес-доменам** (Domain-Driven Design).\n- **Технологическая независимость**: разные сервисы могут использовать разные технологии.\n\n**Преимущества**:\n- Высокая масштабируемость: можно масштабировать отдельные сервисы.\n- Гибкость в выборе технологий.\n- Упрощение непрерывной интеграции и доставки (CI/CD).\n- Лучшая устойчивость: сбой одного сервиса не обязательно приводит к падению всей системы.\n\n**Сложности**:\n- Увеличение сложности управления инфраструктурой (оркестрация, мониторинг, логирование).\n- Необходимость в надёжной сети и механизмах обработки отказов.\n- Проблемы с согласованностью данных (распределённые транзакции).\n- Сложность тестирования интеграций.\n- Высокие требования к зрелости команды и DevOps-практикам.\n\nМикросервисы оправданы в крупных, сложных системах с высокой нагрузкой и частыми изменениями.\n\n#### Event-driven архитектура\n\nEvent-driven (ориентированная на события) архитектура — это стиль, при котором компоненты взаимодействуют через события: один компонент публикует событие, другие — подписываются и реагируют на него.\n\n**Ключевые элементы**:\n- **Издатели (Producers)** — генерируют события.\n- **Брокер событий** — Kafka, RabbitMQ, AWS SNS/SQS.\n- **Подписчики (Consumers)** — обрабатывают события.\n\n**Преимущества**:\n- Высокая асинхронность и производительность.\n- Слабая связанность компонентов.\n- Возможность масштабирования потребителей.\n- Поддержка сложных сценариев: логирование, аналитика, уведомления.\n\n**Недостатки**:\n- Сложность отладки и трассировки.\n- Проблемы с порядком обработки событий.\n- Необходимость в надёжном брокере и механизмах повторной обработки.\n\nЧасто используется в сочетании с микросервисами для построения реактивных и масштабируемых систем.\n\n#### Serverless и архитектура на основе функций\n\nServerless (или FaaS — Function as a Service) — это архитектурный стиль, при котором разработчик пишет функции, которые выполняются в ответ на события, а управление серверами берёт на себя облачный провайдер (например, AWS Lambda, Azure Functions).\n\n**Характеристики**:\n- Функции запускаются по событию (HTTP-запрос, сообщение в очереди, таймер).\n- Автоматическое масштабирование (вплоть до нуля).\n- Оплата по факту выполнения.\n\n**Преимущества**:\n- Отсутствие забот об инфраструктуре.\n- Высокая масштабируемость и отказоустойчивость.\n- Низкие затраты при низкой нагрузке.\n- Быстрое развертывание.\n\n**Недостатки**:\n- Ограничения по времени выполнения и ресурсам.\n- «Холодный старт» — задержка при первом вызове.\n- Сложность управления состоянием.\n- Vendor lock-in (привязка к провайдеру).\n\nServerless подходит для обработки событий, ETL-процессов, API с низкой нагрузкой, но не всегда — для долгоживущих приложений с высокой нагрузкой.\n\n#### Сравнение стилей: как выбрать подходящий?\n\nВыбор архитектурного стиля зависит от множества факторов:\n\n| Критерий | Монолит | Многоуровневый | Микросервисы | Event-driven | Serverless |\n|---------|--------|----------------|--------------|--------------|----------|\n| **Сложность разработки** | Низкая | Средняя | Высокая | Высокая | Средняя |\n| **Масштабируемость** | Низкая | Средняя | Высокая | Высокая | Очень высокая |\n| **Отказоустойчивость** | Низкая | Средняя | Высокая | Высокая | Высокая |\n| **Скорость разработки** | Высокая | Средняя | Низкая (на старте) | Средняя | Высокая |\n| **Затраты на инфраструктуру** | Низкие | Средние | Высокие | Высокие | Зависят от нагрузки |\n| **Поддержка CI/CD** | Простая | Средняя | Сложная | Сложная | Простая |\n\n**Рекомендации по выбору**:\n- **MVP, стартап, маленькая команда** → монолит или многоуровневая архитектура.\n- **Крупная система, высокая нагрузка, независимые команды** → микросервисы.\n- **Реактивные сценарии, обработка потоков данных** → event-driven.\n- **Редкие события, обработка файлов, таймеры** → serverless.\n\nВажно помнить: нет «идеального» стиля. Выбор должен основываться на **требованиях к системе**, **команде**, **инфраструктуре** и **бизнес-целях**. Часто в реальных проектах используется **гибридный подход** — например, микросервисы с event-driven взаимодействием или serverless-функции в рамках монолита.\n\nКлючевой принцип: **начинайте просто, масштабируйтесь по мере необходимости**."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 3: Архитектурные паттерны\n\n#### Понятие архитектурного паттерна\n\nАрхитектурный паттерн — это обобщённое, многократно используемое решение типовой проблемы проектирования программной архитектуры. В отличие от паттернов проектирования на уровне кода (например, Singleton или Factory), архитектурные паттерны определяют структуру всей системы или её крупных компонентов. Они задают организацию взаимодействия между модулями, распределение ответственностей и поток данных.\n\nПрименение архитектурных паттернов позволяет:\n- Повысить предсказуемость и стабильность системы\n- Упростить масштабирование и поддержку\n- Обеспечить соответствие нефункциональным требованиям (производительность, надёжность, безопасность)\n- Ускорить разработку за счёт повторного использования проверенных решений\n\nВыбор паттерна зависит от требований к системе: нагрузки, уровня доступности, сложности бизнес-логики, команды разработки и других факторов.\n\n---\n\n#### Паттерны проектирования слоя представления: MVC, MVP, MVVM\n\nЭти паттерны применяются на уровне пользовательского интерфейса и помогают разделить ответственность между отображением данных, логикой представления и бизнес-логикой.\n\n**MVC (Model-View-Controller)**\n- **Model** — отвечает за данные и бизнес-логику.\n- **View** — отображает данные из модели.\n- **Controller** — обрабатывает пользовательский ввод, обновляет модель и выбирает представление.\n\nПрименяется в веб-фреймворках (например, Ruby on Rails, ASP.NET MVC). Недостаток — тесная связность между View и Controller.\n\n**MVP (Model-View-Presenter)**\n- **Presenter** выступает как посредник между View и Model.\n- View не обращается к Model напрямую, а только через Presenter.\n- Упрощает тестирование, так как логика представления вынесена в Presenter.\n\nЧасто используется в desktop- и мобильных приложениях.\n\n**MVVM (Model-View-ViewModel)**\n- **ViewModel** — абстракция View, содержащая данные и команды.\n- Поддерживает привязку данных (data binding), что позволяет автоматически синхронизировать View и ViewModel.\n- Широко применяется в современных фронтенд-фреймворках (Angular, Vue, WPF).\n\nMVVM особенно эффективен при разработке с использованием реактивных подходов.\n\n---\n\n#### Паттерны распределённых систем: CQRS, Event Sourcing, Saga\n\nЭти паттерны решают сложности, возникающие в распределённых системах: согласованность данных, масштабируемость и отказоустойчивость.\n\n**CQRS (Command Query Responsibility Segregation)**\n- Разделяет операции на **запросы** (read) и **команды** (write).\n- Использует разные модели для чтения и записи данных.\n- Позволяет оптимизировать производительность: например, реплицировать read-модель для масштабирования чтения.\n- Часто комбинируется с Event Sourcing.\n\n**Event Sourcing**\n- Вместо хранения текущего состояния система хранит последовательность событий (events).\n- Текущее состояние восстанавливается путём воспроизведения событий.\n- Обеспечивает полную аудиторию, упрощает отладку и позволяет реализовать временные запросы (time-travel debugging).\n- Требует дополнительной инфраструктуры (например, event store).\n\n**Saga**\n- Паттерн управления длинными транзакциями в распределённой системе.\n- Каждый шаг транзакции выполняется локально, с компенсирующими действиями при сбое.\n- Два вида: **choreography** (без централизованного управления) и **orchestration** (с координатором).\n- Пример: оформление заказа с резервированием товара, оплатой и доставкой.\n\n---\n\n#### Паттерны масштабируемости: Load Balancing, Caching, Sharding\n\nЭти паттерны помогают системе справляться с ростом нагрузки.\n\n**Load Balancing (балансировка нагрузки)**\n- Распределяет входящие запросы между несколькими экземплярами сервиса.\n- Повышает доступность и производительность.\n- Типы: round-robin, least connections, IP hash и др.\n- Может быть реализована на уровне DNS, сети (L4) или приложения (L7).\n\n**Caching (кеширование)**\n- Хранение результатов вычислений или данных в быстром хранилище (в памяти).\n- Уменьшает нагрузку на базу данных и ускоряет ответы.\n- Стратегии: cache-aside, read-through, write-through, write-behind.\n- Примеры: Redis, Memcached.\n\n**Sharding (горизонтальное разделение данных)**\n- Разделение базы данных на независимые части (шарды), распределённые по разным серверам.\n- Каждый шард содержит часть данных (например, по пользователю или региону).\n- Позволяет масштабировать хранилище данных.\n- Сложность: сложные запросы по нескольким шардам, управление распределёнными транзакциями.\n\n---\n\n#### Паттерны отказоустойчивости: Circuit Breaker, Retry, Bulkhead\n\nОбеспечивают устойчивость системы к временным сбоям и перегрузкам.\n\n**Circuit Breaker (предохранитель)**\n- Мониторит количество сбоев при вызове внешнего сервиса.\n- При превышении порога — временно блокирует вызовы (переходит в состояние «открыт»).\n- Через некоторое время переходит в «полуоткрытое» состояние для проверки доступности.\n- Предотвращает каскадные сбои.\n- Реализован в библиотеках: Hystrix (Java), Polly (.NET).\n\n**Retry (повторная попытка)**\n- Автоматически повторяет вызов при временной ошибке (например, таймаут).\n- Часто используется с экспоненциальной задержкой (exponential backoff).\n- Важно ограничивать количество попыток, чтобы не усугубить перегрузку.\n\n**Bulkhead (переборка)**\n- Изолирует компоненты системы, чтобы сбой в одном не повлиял на другие.\n- Пример: выделение отдельного пула потоков для каждого внешнего сервиса.\n- Вдохновлён архитектурой кораблей: если одна переборка затоплена, корабль остаётся на плаву.\n\n---\n\n#### Выбор и комбинирование паттернов в реальных сценариях\n\nНа практике редко используется один паттерн. Современные системы строятся на основе комбинации нескольких паттернов.\n\n**Пример: интернет-магазин**\n- **MVC/MVVM** — для фронтенда и API-контроллеров.\n- **CQRS + Event Sourcing** — для управления заказами и инвентарём.\n- **Saga** — для согласованности операций оформления заказа.\n- **Caching + Load Balancing** — для масштабирования каталога товаров.\n- **Sharding** — по регионам или категориям.\n- **Circuit Breaker + Retry** — при взаимодействии с платежным шлюзом.\n\n**Критерии выбора паттернов**:\n- Требования к доступности (SLA)\n- Ожидаемая нагрузка\n- Сложность бизнес-логики\n- Опыт команды\n- Инфраструктурные ограничения\n\nВажно не «перегружать» систему паттернами: каждый добавляет сложность. Решение должно быть **обоснованным** и **измеримым**.\n\nДокументирование архитектурных решений (например, по шаблону C4) помогает команде понимать, почему выбраны те или иные паттерны, и облегчает дальнейшее развитие системы."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 4: Документирование архитектуры (C4 Model)\n\n#### Зачем документировать архитектуру?\n\nДокументирование архитектуры программной системы — это критически важный этап в разработке ПО, обеспечивающий понимание, согласованность и поддерживаемость системы на всех этапах её жизненного цикла. Без чёткой архитектурной документации команды сталкиваются с рисками:\n\n- **Потеря знаний** при уходе разработчиков;\n- **Несогласованность** в принятии решений;\n- **Сложности в масштабировании** и внесении изменений;\n- **Затруднённая передача системы** новым участникам проекта;\n- **Рост технического долга** из-за отсутствия прозрачности.\n\nАрхитектурная документация помогает:\n- Объяснить структуру системы заинтересованным сторонам (стейкхолдерам);\n- Обеспечить согласованность между командами;\n- Поддерживать соответствие между требованиями и реализацией;\n- Упростить процесс тестирования и аудита;\n- Обеспечить трассируемость решений от требований до кода.\n\n---\n\n#### Обзор модели C4: Context, Containers, Components, Code\n\n**C4 Model** — это иерархический подход к визуализации и документированию архитектуры ПО, предложенный Саймоном Брауном. Название C4 происходит от четырёх уровней детализации: **Context**, **Containers**, **Components**, **Code**.\n\n1. **Level 1: Context (Контекст)**\n   - Наиболее высокий уровень абстракции.\n   - Показывает систему в окружении: пользователи (акторы), внешние системы, интеграции.\n   - Отвечает на вопрос: *«Что делает система и как она взаимодействует с миром?»*\n   - Пример: веб-приложение «Онлайн-магазин» взаимодействует с клиентами, платежными шлюзами, CRM и системой доставки.\n\n2. **Level 2: Containers (Контейнеры)**\n   - Декомпозиция системы на **контейнеры** — это отдельные процессы или исполняемые модули (например, веб-приложение, API, база данных, сообщения).\n   - Каждый контейнер может быть развёрнут независимо.\n   - Указываются технологии (например, React, Spring Boot, PostgreSQL).\n   - Показываются межконтейнерные взаимодействия (HTTP, REST, gRPC, очереди).\n\n3. **Level 3: Components (Компоненты)**\n   - Детализация контейнера: какие компоненты внутри него и как они взаимодействуют.\n   - Компонент — это логическая группа классов, отвечающая за определённую функциональность (например, `OrderService`, `UserRepository`).\n   - Уровень полезен для разработчиков: помогает понять внутреннюю структуру модуля.\n\n4. **Level 4: Code (Код)**\n   - Наиболее детализированный уровень: диаграммы классов, последовательности, UML.\n   - Генерируется автоматически из кода (например, через PlantUML или инструменты анализа кода).\n   - Используется редко в общей документации, но полезно для сложных алгоритмов или критических участков.\n\n> **Важно**: не все уровни нужны всегда. Обычно используют первые три, а уровень Code — по требованию.\n\n---\n\n#### Создание диаграмм C4 с помощью PlantUML или Structurizr\n\nДля построения диаграмм C4 используются специализированные инструменты:\n\n- **PlantUML** — текстовый язык для описания диаграмм. Поддерживает C4 через расширения.\n  ```plantuml\n  !include <c4/c4.puml>\n  \n  Person(customer, \"Клиент\")\n  System(shop, \"Онлайн-магазин\")\n  System_Ext(payment, \"Платёжный шлюз\", \"Stripe\")\n  \n  Rel(customer, shop, \"Покупает через\")\n  Rel(shop, payment, \"Обрабатывает оплату\")\n  \n  ' Уровень Context\n  \n  ShowLegend\n  ```\n  Преимущества: лёгкий вес, версионирование в Git, интеграция с Markdown.\n\n- **Structurizr** — облачный и локальный инструмент, разработанный Саймоном Брауном, непосредственно поддерживающий C4.\n  - Позволяет создавать, хранить и совместно редактировать диаграммы.\n  - Поддерживает экспорт в JSON, встраивание в документацию.\n  - Интеграция с кодом на Java/C# для автоматической генерации диаграмм.\n\nВыбор инструмента зависит от масштаба проекта и потребностей в совместной работе.\n\n---\n\n#### Интеграция документации с требованиями и трассируемость\n\nАрхитектурная документация не должна существовать в вакууме. Она должна быть **связана с требованиями**:\n\n- Каждый архитектурный элемент (контейнер, компонент) должен быть обоснован **функциональным или нефункциональным требованием**.\n- Например, требование «Система должна обрабатывать 1000 запросов в секунду» обосновывает выбор микросервисной архитектуры и горизонтального масштабирования.\n\n**Трассируемость** — это возможность проследить путь от требования до реализации:\n\n| Требование | Архитектурное решение | Тест |\n|------------|------------------------|------|\n| RQ-001: Аутентификация через OAuth | Контейнер `Auth Service` на Spring Security | Тест безопасности |\n| NFR-003: Время отклика < 500 мс | Кэширование через Redis | Нагрузочное тестирование |\n\nИнструменты вроде Jira, Confluence, GitLab или специализированные системы (DOORS, Jama) позволяют строить такие матрицы трассировки.\n\n---\n\n#### Примеры документирования реальных систем\n\n**Пример 1: Банковская система**\n- **Контекст**: клиенты, мобильное приложение, система перевода, внешние банки, регуляторы.\n- **Контейнеры**: Mobile App (React Native), Core Banking API (Java/Spring), Database (Oracle), Messaging (Kafka).\n- **Компоненты в Core Banking API**: `AccountService`, `TransactionProcessor`, `FraudDetection`.\n- Обоснование: NFR по безопасности → шифрование, аудит, двухфакторная аутентификация.\n\n**Пример 2: Система доставки еды**\n- **Контекст**: пользователи, курьеры, рестораны, push-уведомления.\n- **Контейнеры**: Frontend (Vue.js), Order API (Node.js), GeoService (Python), PostgreSQL, Redis.\n- **Компоненты в Order API**: `OrderValidator`, `PaymentGateway`, `NotificationClient`.\n- Трассировка: требование «Уведомление о прибытии курьера» → `NotificationClient` → интеграция с Firebase.\n\n> Такая документация позволяет быстро вводить новых разработчиков, проводить аудит и рефакторинг.\n\n---\n\n**Вывод**: C4 Model — это мощный, гибкий и понятный подход к документированию архитектуры. Он обеспечивает прозрачность, поддерживает коммуникацию между стейкхолдерами и помогает управлять сложностью современных систем. Интеграция с требованиями и использование современных инструментов делает C4 незаменимым в профессиональной разработке ПО."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5: Оценка качества и технический долг\n\nКачество программного обеспечения (ПО) — это комплексная характеристика, определяющая, насколько система соответствует ожиданиям пользователей, требованиям и стандартам. В современной разработке недостаточно просто создать работающее приложение — важно, чтобы оно было надёжным, безопасным, масштабируемым и легко поддерживаемым. Для систематической оценки качества используется международный стандарт **ISO/IEC 25010**, который определяет восемь основных характеристик качества ПО:\n\n1. **Функциональная пригодность** — способность ПО предоставлять нужные функции.\n2. **Производительность** — поведение системы при заданной нагрузке (время отклика, пропускная способность).\n3. **Совместимость** — способность взаимодействовать с другими системами.\n4. **Используемость** — удобство интерфейса и простота освоения.\n5. **Надёжность** — устойчивость к сбоям и способность восстанавливаться.\n6. **Эффективность** — рациональное использование ресурсов (память, процессор).\n7. **Сопровождаемость** — простота модификации, анализа и исправления кода.\n8. **Переносимость** — возможность развертывания в разных средах.\n\nЭти характеристики помогают формализовать нефункциональные требования и использовать **метрики качества**, такие как:\n- Покрытие кода тестами\n- Цикломатическая сложность (Cyclomatic Complexity)\n- Количество дефектов на 1000 строк кода (KLOC)\n- Время отклика API\n- Время восстановления после сбоя (MTTR)\n\n#### Оценка архитектуры: архитектурные дринки и атаки на архитектуру\n\nДля оценки архитектурных решений используются методы, направленные на выявление узких мест и рисков. Два важных подхода — **архитектурные дринки** и **атаки на архитектуру**.\n\n- **Архитектурные дринки (Architecture Drinks)** — это регулярные короткие сессии (например, раз в спринт), где команда анализирует текущее состояние архитектуры, обсуждает риски и принимает решения по улучшению. Это способ поддерживать архитектуру в «тонусе».\n\n- **Атаки на архитектуру (Architecture Attacks)** — метод, при котором команда симулирует сценарии, которые могут нарушить работу системы: резкий рост нагрузки, отказ сервиса, потеря данных, DDoS-атака и т.д. Цель — проверить, насколько архитектура устойчива к стрессу и как быстро система может восстановиться.\n\nТакие практики позволяют заранее выявлять слабые места и проектировать более устойчивые системы.\n\n#### Что такое технический долг: виды, измерение, управление\n\n**Технический долг** — это метафора, введённая Уордом Каннингемом, описывающая последствия выбора быстрого, но неоптимального решения в разработке. Как финансовый долг, технический долг требует «процентов» — дополнительных усилий на поддержку, исправление и рефакторинг в будущем.\n\n**Виды технического долга**:\n- **Сознательный** — команда осознанно идёт на упрощение ради срочного релиза.\n- **Бессознательный** — долг возникает из-за нехватки знаний или опыта.\n- **Принудительный** — вызван внешними ограничениями (сроки, бюджет, legacy-системы).\n- **Стратегический** — долг, накопленный с целью быстрого выхода на рынок (MVP).\n\n**Измерение технического долга** возможно через:\n- Оценку времени, необходимого для рефакторинга\n- Количество «закостырей» в коде\n- Уровень технических предупреждений (warnings)\n- Индекс технического долга (в инструментах вроде SonarQube)\n\n**Управление техническим долгом** включает:\n- Регулярный рефакторинг\n- Включение задач по улучшению архитектуры в бэклог\n- Оценку долга на этапе планирования спринтов\n- Использование метрик для мониторинга\n\n#### Архитектурный штраф (Architecture Erosion)\n\n**Архитектурный штраф** — это постепенное ухудшение архитектуры из-за накопления технического долга, отклонений от проектных решений и отсутствия контроля. Со временем система становится сложной, хрупкой и трудной для изменения.\n\nПричины архитектурного штрафа:\n- Отсутствие документации архитектуры\n- Несоблюдение архитектурных ограничений\n- Быстрые изменения без анализа последствий\n- Отсутствие код-ревью и архитектурного аудита\n\nПрофилактика:\n- Регулярные архитектурные ревью\n- Использование шаблонов C4 для документирования\n- Автоматизированная проверка архитектурных правил\n\n#### Инструменты анализа кода и архитектуры\n\nДля контроля качества и предотвращения технического долга используются специализированные инструменты:\n\n- **SonarQube** — один из самых популярных инструментов для анализа кода. Позволяет выявлять баги, уязвимости, «запахи кода» (code smells), отслеживать покрытие тестами и рассчитывать индекс технического долга.\n\n- **NDepend** — мощный инструмент для .NET-разработки, позволяющий анализировать зависимости, визуализировать архитектуру, проверять соблюдение правил и отслеживать метрики.\n\n- **ArchUnit** — библиотека для Java, позволяющая писать юнит-тесты для архитектуры (например, «Слой DAO не должен зависеть от контроллеров»).\n\n- **Dependency-Cruiser** — инструмент для анализа зависимостей в JavaScript/TypeScript-проектах.\n\n- **Structure101** — средство для визуализации и управления архитектурой на уровне модулей и компонентов.\n\nЭти инструменты помогают поддерживать архитектуру в чистоте, автоматически выявлять отклонения и предотвращать архитектурный штраф.\n\n#### Заключение\n\nОценка качества и управление техническим долгом — ключевые аспекты устойчивой разработки ПО. Использование стандарта ISO 25010, регулярные архитектурные ревью, атаки на архитектуру и инструменты анализа позволяют поддерживать высокое качество системы на протяжении всего её жизненного цикла. Осознанное управление техническим долгом помогает избегать кризисов масштабируемости и поддерживаемости, делая разработку более предсказуемой и эффективной."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 6: Командный проект: проектирование архитектуры приложения\n\nВ рамках данного модуля студенты применяют все полученные знания на практике в командном проекте — проектировании архитектуры реального веб-приложения. В качестве примера может быть выбрано приложение для системы бронирования (например, бронирования отелей, автостоянок, переговорных комнат и т.п.). Проект охватывает полный цикл архитектурного проектирования: от сбора требований до презентации и рефлексии.\n\n#### 1. Постановка задачи: разработка архитектуры для веб-приложения\n\nЦель проекта — спроектировать масштабируемую, надёжную и поддерживаемую архитектуру веб-приложения. Команда должна:\n- Определить контекст системы и её пользователей.\n- Выделить ключевые функции приложения.\n- Учесть ограничения и ожидания заказчика.\n- Обеспечить трассируемость решений от требований до архитектурных и тестовых артефактов.\n\nПример: система бронирования должна позволять пользователям просматривать доступные ресурсы, бронировать их, отменять бронирование, получать уведомления, а администраторам — управлять ресурсами и просматривать отчёты.\n\n#### 2. Сбор и анализ требований (функциональных и нефункциональных)\n\n**Функциональные требования** описывают, что система должна делать:\n- Регистрация и аутентификация пользователей.\n- Поиск и фильтрация доступных ресурсов.\n- Создание, редактирование и отмена бронирования.\n- Уведомления (email/SMS) о подтверждении и напоминаниях.\n- Административная панель для управления ресурсами и бронированиями.\n\n**Нефункциональные требования** определяют, *насколько хорошо* система должна работать:\n- **Производительность**: время отклика не более 2 секунд при нагрузке до 10 000 пользователей.\n- **Масштабируемость**: поддержка роста числа пользователей и ресурсов.\n- **Надёжность**: доступность 99,9% (uptime).\n- **Безопасность**: защита персональных данных, аутентификация через OAuth 2.0, защита от XSS и SQL-инъекций.\n- **Поддерживаемость**: чёткая модульная структура, документация, возможность быстрого внесения изменений.\n\nТребования должны быть задокументированы и прослеживаться через все этапы проектирования.\n\n#### 3. Выбор архитектурного стиля и паттернов\n\nНа основе требований команда выбирает подходящий архитектурный стиль. Возможные варианты:\n\n- **Микросервисная архитектура** — если требуется высокая масштабируемость, независимое развертывание и технологическая гетерогенность.\n- **Монолит с многослойной архитектурой** — если приложение небольшое, а требования к масштабированию умеренные.\n- **Событийно-ориентированная архитектура** — если важна асинхронная обработка (например, уведомления, логирование).\n\nПример выбора паттернов:\n- **API Gateway** — для маршрутизации запросов в микросервисах.\n- **CQRS** — для разделения операций чтения и записи при высокой нагрузке на чтение.\n- **Сторонний кэш (Redis)** — для ускорения доступа к часто запрашиваемым данным.\n- **Реестр сервисов (Service Discovery)** — в распределённой системе.\n\nВыбор должен быть обоснован: какие требования он удовлетворяет и какие компромиссы влечёт.\n\n<tool_call>\n{\"name\": \"knowledge_search\", \"arguments\": {\"search_query\": \"примеры диаграмм C4 для веб-приложения бронирования\", \"category\": \"materials\"}}\n</tool_call>"
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Архитектурная документация для веб-приложения по бронированию переговорных комнат",
        "max_score": 100,
        "passing_score": 70,
        "questions": [
          {
            "text": "Соберите и задокументируйте функциональные и нефункциональные требования к системе бронирования переговорных комнат. Приведите минимум по 5 требований каждого типа, сформулированных в измеримой и проверяемой форме. Объясните, как каждое нефункциональное требование повлияет на архитектурные решения.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Обоснуйте выбор архитектурного стиля (например, микросервисы, монолит, event-driven) для данного приложения. Укажите, какие требования (из предыдущего пункта) стали определяющими при выборе. Опишите компромиссы, на которые вы идёте, и возможные риски выбранного стиля.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Выберите два архитектурных паттерна (например, CQRS, API Gateway, Circuit Breaker, Event Sourcing) и опишите, как они будут применены в вашей системе. Укажите конкретные компоненты или сервисы, где они используются, и объясните, какие проблемы они решают (например, масштабируемость, отказоустойчивость, сложность бизнес-логики).",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Постройте диаграммы C4 трёх уровней: Context, Containers и Components. Для уровня Context опишите взаимодействие системы с внешними акторами и сервисами. На уровне Containers укажите основные исполняемые модули (например, веб-фронтенд, API, база данных, почтовый сервис), их технологии и протоколы взаимодействия. На уровне Components выберите один из контейнеров и детализируйте его внутренние компоненты (например, BookingService, NotificationService).",
            "options": [],
            "correct_answers": [],
            "points": 20
          },
          {
            "text": "Разработайте стратегию тестирования системы. Включите в неё: подход к модульному и интеграционному тестированию, план нагрузочного тестирования (какие сценарии, метрики, инструменты), а также стратегию безопасностного тестирования (например, проверка на XSS, SQL-инъекции, аутентификация). Объясните, как тестирование учитывает нефункциональные требования.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Оцените потенциальный технический долг, который может возникнуть при реализации выбранной архитектуры. Приведите минимум три примера (например, сложность отладки распределённых транзакций, зависимость от внешнего брокера сообщений, дублирование данных между сервисами). Предложите конкретные меры по минимизации или управлению этим долгом (например, регулярные архитектурные ревью, использование инструментов анализа кода, документирование решений).",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Как вы обеспечите трассируемость решений от требований до архитектуры и тестирования? Приведите пример матрицы трассировки для двух функциональных и двух нефункциональных требований, указав, какое архитектурное решение и тестовое покрытие их реализуют. Объясните, как такая матрица помогает в управлении проектом и поддержке системы в будущем.",
            "options": [],
            "correct_answers": [],
            "points": 10
          }
        ]
      }
    },
    {
      "id": "a163432b-61ba-4577-950b-b6d3b9c6d4e0",
      "title": "Модуль 6: Проектирование масштабируемых систем",
      "description": "В этом модуле студенты освоят системный подход к разработке программного обеспечения, научатся проектировать архитектуру сложных систем с учётом масштабируемости, надёжности и поддерживаемости. На практических кейсах они пройдут все ключевые этапы — от сбора требований до документирования архитектурных решений и оценки качества ПО. Особое внимание уделено применению архитектурных паттернов, управлению техническим долгом и командной работе с использованием современных инструментов.",
      "learning_objectives": [
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
        "Применять архитектурные паттерны и обосновывать их выбор.",
        "Документировать архитектурные решения по шаблону C4.",
        "Разрабатывать стратегию тестирования, включая нефункциональные аспекты.",
        "Оценивать качество ПО и управлять техническим долгом.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 6,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля 6: Проектирование масштабируемых систем",
          "mermaid_code": "```mermaid\n%%{init: {'theme': 'neutral'}}%%\ngraph TD\n    A[Модуль 6: Проектирование масштабируемых систем] --> B[Тема 1: Жизненный цикл ПО и управление требованиями]\n    A --> C[Тема 2: Архитектурные паттерны и проектирование системы]\n    A --> D[Тема 3: Документирование архитектуры (C4)]\n    A --> E[Тема 4: Качество ПО и технический долг]\n    A --> F[Тема 5: Командная разработка и инструменты поддержки]\n\n    B --> B1[Лекция: Модели жизненного цикла ПО]\n    B --> B2[Практика: Сбор и анализ требований]\n    B --> B3[Задание: Документ «Спецификация требований»]\n\n    C --> C1[Лекция: Архитектурные стили и паттерны]\n    C --> C2[Практика: Выбор архитектуры для кейса]\n    C --> C3[Задание: Проектирование системы (диаграммы)]\n\n    D --> D1[Лекция: Моделирование архитектуры — C4]\n    D --> D2[Практика: Построение C4-диаграмм]\n    D --> D3[Задание: Документ «Архитектурное решение по C4»]\n\n    E --> E1[Лекция: Качество ПО и технический долг]\n    E --> E2[Практика: Оценка качества через метрики]\n    E --> E3[Задание: Отчёт по оценке качества и план снижения долга]\n\n    F --> F1[Лекция: Инструменты трассируемости и управления изменениями]\n    F --> F2[Практика: Работа с Jira/GitLab]\n    F --> F3[Итоговый проект: Командная разработка архитектуры системы]\n```",
          "explanation": "Диаграмма в формате Mermaid типа flowchart (TD — сверху вниз) отображает структуру модуля 6, показывая иерархию тем, лекций, практических занятий и заданий. Это помогает визуализировать логическую последовательность обучения и соответствие целей содержанию."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 1: Жизненный цикл ПО и управление требованиями\n\n#### Лекция: Модели жизненного цикла ПО\n\nРазработка программного обеспечения — это сложный процесс, требующий системного подхода. Одним из ключевых элементов такого подхода является понимание **жизненного цикла ПО** — последовательности этапов, через которые проходит программный продукт от идеи до вывода из эксплуатации.\n\nСуществует несколько моделей жизненного цикла, каждая из которых подходит для определённых типов проектов и условий:\n\n1. **Waterfall (Каскадная модель)**\n   - Линейная модель, в которой этапы (анализ требований, проектирование, реализация, тестирование, внедрение, сопровождение) выполняются последовательно.\n   - Подходит для проектов с чётко определёнными и стабильными требованиями.\n   - Недостаток: низкая гибкость — изменения на поздних этапах обходятся дорого.\n\n2. **Iterative (Итерационная модель)**\n   - Разработка ведётся циклами (итерациями). На каждой итерации создаётся работающая версия системы, которая постепенно улучшается.\n   - Позволяет уточнять требования в процессе разработки.\n   - Подходит для крупных проектов с частично определёнными требованиями.\n\n3. **Agile (Гибкая модель)**\n   - Основана на итерациях короткой продолжительности (спринтах), с постоянным взаимодействием с заказчиком.\n   - Акцент на адаптивность, быструю доставку ценности и обратную связь.\n   - Популярные фреймворки: Scrum, Kanban.\n   - Подходит для динамичных проектов, где требования часто меняются.\n\n4. **DevOps**\n   - Не просто модель разработки, а культура и практика, объединяющая разработку (Dev) и эксплуатацию (Ops).\n   - Включает непрерывную интеграцию (CI), непрерывное развертывание (CD), автоматизированное тестирование и мониторинг.\n   - Цель — ускорить доставку качественного ПО в продакшн и повысить надёжность системы.\n\nВыбор модели зависит от:\n- Стабильности требований\n- Размера и сложности проекта\n- Срочности доставки\n- Уровня взаимодействия с заказчиком\n- Необходимости масштабирования и поддержки\n\n#### Управление требованиями\n\nТребования — это основа архитектуры и реализации ПО. Их правильное выявление и документирование напрямую влияет на успех проекта.\n\n**Требования делятся на два типа:**\n\n1. **Функциональные требования**\n   - Описывают, *что* система должна делать.\n   - Пример: «Пользователь может авторизоваться с помощью email и пароля».\n   - Отвечают на вопрос: «Какие функции должна выполнять система?»\n\n2. **Нефункциональные требования**\n   - Определяют *качество* системы — её характеристики производительности, безопасности, надёжности и т.д.\n   - Примеры:\n     - «Система должна обрабатывать до 10 000 запросов в секунду» (производительность)\n     - «Время отклика API не должно превышать 200 мс» (латентность)\n     - «Данные пользователей должны шифроваться при хранении» (безопасность)\n     - «Система должна быть доступна 99.9% времени» (надёжность)\n\nНефункциональные требования особенно важны при проектировании масштабируемых систем, так как они напрямую влияют на выбор архитектурных решений (например, использование кэширования, балансировки нагрузки, репликации баз данных и т.д.).\n\n#### Практика: Анализ кейса\n\n**Задача:** Рассмотрим систему электронной коммерции (интернет-магазин).\n\n**Функциональные требования:**\n- Пользователь может просматривать каталог товаров\n- Пользователь может добавлять товары в корзину\n- Пользователь может оформлять заказ\n- Администратор может управлять товарами (добавлять, редактировать, удалять)\n\n**Нефункциональные требования:**\n- Система должна поддерживать до 50 000 одновременных пользователей\n- Время загрузки главной страницы — не более 1.5 секунд\n- Данные о платежах должны храниться в зашифрованном виде\n- Резервное копирование данных — каждые 6 часов\n- Система должна быть доступна 24/7 (высокая доступность)\n\n#### Задание: Подготовка спецификации требований\n\n**Цель задания:** На основе выбранного проекта (например, сервис доставки еды, платформа онлайн-обучения) подготовить документ «Спецификация требований», включающий:\n\n1. Краткое описание системы\n2. Список функциональных требований (в формате: ID, описание, приоритет)\n3. Список нефункциональных требований (по категориям: производительность, безопасность, доступность, масштабируемость и др.)\n4. Диаграмму прецедентов (Use Case Diagram) — по желанию\n\n**Формат:** PDF или Markdown-документ.\n\n#### Итог\n\nК концу этой темы студенты:\n- Понимают различия между моделями жизненного цикла ПО и умеют выбирать подходящую.\n- Умеют выявлять и классифицировать функциональные и нефункциональные требования.\n- Понимают, как требования влияют на архитектуру системы.\n- Формализуют требования в виде структурированного документа.\n\nЭто фундамент для дальнейшего проектирования масштабируемых и надёжных систем."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 2: Архитектурные паттерны и проектирование системы\n\n#### Введение\n\nПри проектировании программных систем ключевую роль играет выбор архитектурного паттерна — фундаментального шаблона организации компонентов системы, их взаимодействия и распределения ответственностей. Правильный выбор архитектуры напрямую влияет на такие важные качества системы, как **масштабируемость**, **отказоустойчивость**, **поддерживаемость** и **время выхода на рынок**. В этом разделе рассматриваются основные архитектурные стили, их особенности, преимущества и недостатки, а также практические рекомендации по их применению.\n\n---\n\n#### Основные архитектурные стили\n\n##### 1. Монолитная архитектура\n\n**Описание:**\nВсе компоненты приложения (веб-интерфейс, бизнес-логика, доступ к данным) объединены в единое приложение, которое развертывается как один процесс.\n\n**Преимущества:**\n- Простота разработки, тестирования и развертывания на ранних этапах.\n- Единая кодовая база, упрощающая отладку.\n- Высокая производительность за счёт отсутствия сетевых вызовов между компонентами.\n\n**Недостатки:**\n- Сложность масштабирования: масштабируется вся система целиком, даже если нагрузка только на один модуль.\n- Высокая связанность компонентов — изменения в одной части могут повлиять на всю систему.\n- Долгое время сборки и развертывания при росте кодовой базы.\n- Технический долг накапливается быстрее при отсутствии дисциплины.\n\n**Когда использовать:**\n- Небольшие проекты или MVP.\n- Команды с ограниченными ресурсами.\n- Системы с предсказуемой нагрузкой и простой логикой.\n\n---\n\n##### 2. Микросервисная архитектура\n\n**Описание:**\nПриложение разбивается на небольшие независимые сервисы, каждый из которых отвечает за одну бизнес-функцию и может разрабатываться, развертываться и масштабироваться отдельно.\n\n**Преимущества:**\n- Высокая масштабируемость: можно масштабировать только нагруженные сервисы.\n- Независимость команд: каждая команда может работать над своим сервисом.\n- Гибкость технологического стека: разные сервисы могут использовать разные языки и базы данных.\n- Повышенная отказоустойчивость: сбой одного сервиса не обязательно приводит к падению всей системы.\n\n**Недостатки:**\n- Сложность управления распределённой системой (сетевые задержки, согласованность данных, мониторинг).\n- Необходимость в сложной инфраструктуре (оркестраторы, service mesh, API Gateway).\n- Усложнённое тестирование и отладка.\n- Риск чрезмерной фрагментации.\n\n**Когда использовать:**\n- Крупные системы с высокой нагрузкой.\n- Организации с несколькими командами, работающими параллельно.\n- Проекты, требующие гибкости и быстрого внесения изменений.\n\n---\n\n##### 3. Event-Driven Architecture (архитектура, ориентированная на события)\n\n**Описание:**\nКомпоненты взаимодействуют через асинхронные события. Один компонент публикует событие, другие — подписываются и реагируют на него.\n\n**Преимущества:**\n- Высокая декомпозиция и слабая связанность.\n- Хорошо масштабируется под высокую нагрузку.\n- Поддерживает реальное время и реактивные сценарии.\n- Упрощает интеграцию новых компонентов.\n\n**Недостатки:**\n- Сложность отладки и отслеживания потока данных.\n- Проблемы с согласованностью и порядком событий.\n- Требует надёжного брокера сообщений (например, Kafka, RabbitMQ).\n\n**Когда использовать:**\n- Системы с высокой асинхронной нагрузкой (например, уведомления, аналитика, обработка заказов).\n- Интеграция разнородных систем.\n- Реактивные приложения (чаты, IoT, стриминг).\n\n---\n\n##### 4. Serverless-архитектура (FaaS — Function as a Service)\n\n**Описание:**\nРазработчик пишет функции, которые выполняются в ответ на события. Управление серверами берёт на себя облачный провайдер (например, AWS Lambda, Azure Functions).\n\n**Преимущества:**\n- Автоматическое масштабирование до нуля.\n- Оплата только за время выполнения.\n- Минимальные затраты на инфраструктуру.\n- Быстрое развертывание.\n\n**Недостатки:**\n- Ограниченное время выполнения и ресурсы.\n- Холодные старты могут увеличивать задержку.\n- Сложность управления состоянием.\n- Зависимость от провайдера (vendor lock-in).\n\n**Когда использовать:**\n- Кратковременные задачи (обработка файлов, триггеры по событиям).\n- Спайковые нагрузки.\n- Прототипирование и MVP.\n\n---\n\n#### Практическое сравнение на примере e-commerce системы\n\nРассмотрим, как можно реализовать интернет-магазин в разных архитектурах:\n\n| Аспект | Монолит | Микросервисы | Event-Driven | Serverless |\n|--------|--------|--------------|--------------|------------|\n| **Разделение на модули** | Каталог, корзина, оплата — в одном приложении | Отдельные сервисы: CatalogService, PaymentService и т.д. | События: `OrderCreated`, `PaymentProcessed` | Функции: `processPayment`, `sendConfirmation` |\n| **Масштабируемость** | Вся система | По отдельности | По шине событий | По функциям |\n| **Отказоустойчивость** | Низкая (падение одного модуля — падение всего приложения) | Средняя (зависит от реализации) | Высокая (асинхронность) | Высокая (автомасштабирование) |\n| **Сложность разработки** | Низкая | Высокая | Средняя | Низкая/средняя |\n| **Инфраструктурные затраты** | Низкие | Высокие | Средние | Зависят от нагрузки |\n\n---\n\n#### Как выбрать архитектуру: методология принятия решений\n\n1. **Оцените требования:**\n   - Функциональные: что должна делать система?\n   - Нефункциональные: масштабируемость, доступность, безопасность, задержки.\n\n2. **Проанализируйте команду и ресурсы:**\n   - Есть ли опыт работы с распределёнными системами?\n   - Достаточно ли DevOps-поддержки?\n\n3. **Учтите жизненный цикл проекта:**\n   - Это MVP или зрелая система?\n   - Планируется ли быстрый рост?\n\n4. **Оцените технический долг:**\n   - Микросервисы могут уменьшить долг в долгосрочной перспективе, но увеличивают его на старте.\n\n5. **Используйте архитектурные драйверы:**\n   - Например, если критична задержка — избегайте serverless из-за холодных стартов.\n\n---\n\n#### Задание для студентов\n\n**Кейс:** Разработайте архитектуру для платформы онлайн-обучения (аналог Coursera), где пользователи могут проходить курсы, сдавать тесты, получать сертификаты, а преподаватели — загружать материалы.\n\n**Задачи:**\n1. Выберите подходящий архитектурный стиль.\n2. Обоснуйте выбор с учётом масштабируемости, отказоустойчивости и поддерживаемости.\n3. Постройте **контекстную диаграмму (C4 Level 1)** и **диаграмму контейнеров (C4 Level 2)**.\n4. Укажите ключевые сервисы/компоненты и их взаимодействие.\n\n**Рекомендации по выполнению:**\n- Используйте шаблон C4 для документирования.\n- Учтите сценарии: высокая нагрузка во время запуска курса, асинхронная проверка заданий, уведомления.\n- Подумайте о возможных расширениях (мобильное приложение, интеграция с LMS).\n\n---\n\n#### Заключение\n\nВыбор архитектурного паттерна — это компромисс между простотой, производительностью и гибкостью. Нет универсального решения: монолит может быть идеален для стартапа, а микросервисы — избыточны. Важно понимать цели проекта, его ограничения и будущее развитие. Современные системы часто используют **гибридные подходы** — например, микросервисы с event-driven взаимодействием или serverless-функции внутри монолита для тяжелых задач.\n\nГлавное — проектировать осознанно, документировать решения и быть готовым к эволюции архитектуры по мере роста системы."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 3: Документирование архитектуры (C4)\n\n#### Введение\n\nЭффективное документирование архитектуры программной системы — ключевой элемент успешной разработки, особенно в масштабируемых и распределённых проектах. Без чёткой и понятной архитектурной документации сложно обеспечить согласованность между разработчиками, архитекторами, тестировщиками, менеджерами и другими стейкхолдерами. Для решения этой задачи был разработан метод **C4 Model**, который предлагает иерархический подход к описанию архитектуры ПО.\n\nМетод C4 был предложен Саймоном Брауном (Simon Brown) как простой, но мощный способ визуализации и документирования архитектуры программных систем. Он основан на идее постепенного углубления в детали — от общего контекста до конкретного кода.\n\n#### Уровни модели C4\n\nМодель C4 включает четыре уровня абстракции:\n\n1. **Контекст (Context)**\n   - На этом уровне описывается система в целом и её взаимодействие с внешними пользователями (акторами) и другими системами.\n   - Диаграмма контекста отвечает на вопрос: *«Что делает система и кто с ней взаимодействует?»*\n   - Пример: веб-приложение «Онлайн-магазин» взаимодействует с покупателями, администраторами, платежными шлюзами и службой доставки.\n   - Используется для коммуникации с бизнес-стейкхолдерами и нетехнической аудиторией.\n\n2. **Контейнеры (Containers)**\n   - Контейнер — это отдельное окружение выполнения, которое содержит один или несколько компонентов.\n   - Примеры контейнеров: веб-приложение (на React), бэкенд API (на Node.js), база данных (PostgreSQL), сообщения (RabbitMQ).\n   - Диаграмма контейнеров показывает технологический стек и взаимодействие между основными частями системы.\n   - Отвечает на вопрос: *«Из каких крупных частей состоит система и как они общаются?»*\n   - Важно указывать протоколы взаимодействия (HTTP, gRPC, WebSocket и т.д.).\n\n3. **Компоненты (Components)**\n   - На этом уровне детализируются контейнеры: какие компоненты находятся внутри каждого контейнера и как они взаимодействуют.\n   - Компонент — это логическая группа классов, отвечающая за определённую функциональность (например, `OrderService`, `PaymentGateway`, `UserRepository`).\n   - Диаграмма компонентов помогает разработчикам понять внутреннюю структуру системы.\n   - Отвечает на вопрос: *«Что делает каждый контейнер и из каких частей он состоит?»*\n   - Часто сопровождается описанием API, интерфейсов и зависимостей.\n\n4. **Код (Code)**\n   - Самый низкий уровень — исходный код.\n   - Может включать диаграммы классов UML, последовательности вызовов (sequence diagrams) или фрагменты кода.\n   - Используется для объяснения сложных алгоритмов, паттернов проектирования или критически важных участков реализации.\n   - Пример: диаграмма последовательности при оформлении заказа.\n\n#### Преимущества C4\n\n- **Прозрачность**: каждый уровень понятен своей аудитории — от бизнеса до разработчиков.\n- **Масштабируемость**: легко адаптируется под системы любой сложности.\n- **Поддерживаемость**: документация остаётся актуальной, если обновлять диаграммы при изменениях.\n- **Коммуникация**: уменьшает недопонимание между участниками проекта.\n- **Трассируемость**: позволяет связывать архитектурные решения с требованиями и задачами.\n\n#### Практическое применение\n\nПри построении C4-моделей рекомендуется:\n\n- Начинать с уровня **Контекст** и последовательно углубляться.\n- Использовать простые инструменты: [Structurizr](https://structurizr.com), [Mermaid](https://mermaid.js.org/), Draw.io или даже PowerPoint.\n- Дополнять диаграммы текстовым описанием: назначение, технологии, ограничения, риски.\n- Версионировать документацию (например, через Git).\n\n#### Пример: Онлайн-магазин\n\n1. **Контекст**: Покупатель, Админ → Онлайн-магазин → Платёжный шлюз, Служба доставки.\n2. **Контейнеры**: Веб-фронтенд (React), API-сервер (Node.js), БД (PostgreSQL), Очередь задач (RabbitMQ).\n3. **Компоненты в API-сервере**: `OrderController`, `PaymentService`, `InventoryRepository`.\n4. **Код**: Диаграмма последовательности `createOrder()` с вызовами валидации, блокировки товара, оплаты.\n\n#### Заключение\n\nМетод C4 — это не просто набор диаграмм, а **структурированный подход к архитектурной коммуникации**. Он помогает командам проектировать, обсуждать и поддерживать сложные системы, минимизируя риски недопонимания и технического долга. Владение C4 — важный навык архитектора и senior-разработчика в современной разработке ПО."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 4: Качество ПО и технический долг\n\nКачество программного обеспечения (ПО) — это совокупность характеристик, определяющих, насколько система соответствует ожиданиям пользователей, требованиям и стандартам. В условиях масштабируемых систем качество становится критически важным фактором, поскольку ошибки, неэффективный код или слабая архитектура могут привести к серьёзным последствиям: сбоям в работе, высоким затратам на поддержку, уязвимостям и трудностям при развитии системы.\n\n#### Атрибуты качества ПО\n\nАтрибуты качества (или нефункциональные требования) определяют, *как* система должна работать. Ключевые атрибуты включают:\n\n- **Производительность** — скорость отклика, пропускная способность, использование ресурсов. Например, система должна обрабатывать 1000 запросов в секунду при задержке не более 200 мс.\n- **Безопасность** — защита от несанкционированного доступа, утечек данных, атак (например, SQL-инъекции, XSS). Включает аутентификацию, авторизацию, шифрование и аудит.\n- **Поддерживаемость** — лёгкость внесения изменений, исправления ошибок и добавления новых функций. Высокая поддерживаемость достигается за счёт чистого кода, документации и модульной архитектуры.\n- **Надёжность** — способность системы работать без сбоев в течение заданного времени.\n- **Масштабируемость** — возможность системы эффективно расти под нагрузкой (по горизонтали или вертикали).\n- **Доступность** — время, в течение которого система доступна для пользователей (например, 99.9% uptime).\n- **Производительность разработки** — скорость, с которой команда может реализовывать новые функции без ухудшения качества.\n\nЭти атрибуты должны быть определены на этапе сбора требований и измеримы, чтобы можно было отслеживать их выполнение.\n\n#### Метрики кода\n\nДля объективной оценки качества ПО используются метрики кода — количественные показатели, отражающие состояние исходного кода. Основные метрики:\n\n- **Cyclomatic Complexity (Цикломатическая сложность)** — измеряет количество независимых путей выполнения в коде. Высокое значение (>10–15) указывает на сложные, труднотестируемые и поддерживаемые функции. Упрощение логики и декомпозиция помогают снизить сложность.\n- **Code Coverage (Покрытие кода тестами)** — процент строк, ветвей или путей кода, охваченных автоматическими тестами. Высокое покрытие (>80%) снижает риск регрессий, но не гарантирует отсутствие багов.\n- **Code Duplication (Дублирование кода)** — наличие одинаковых или похожих фрагментов кода. Дублирование усложняет поддержку и увеличивает риск ошибок.\n- **Maintainability Index (Индекс поддерживаемости)** — комбинированная метрика, учитывающая сложность, размер и покрытие тестами. Чем выше индекс, тем проще поддерживать код.\n- **Technical Debt Ratio** — оценка объёма технического долга в процентах от времени, необходимого на полную переработку кода.\n\nИнструменты анализа кода (например, SonarQube, CodeClimate) автоматически вычисляют эти метрики и помогают выявлять «горячие» участки кода.\n\n#### Технический долг\n\n**Технический долг** — это компромисс, при котором команда сознательно или бессознательно выбирает быстрое, но неоптимальное решение, чтобы ускорить доставку функциональности. Как и финансовый долг, технический долг требует «процентов» — в будущем придётся тратить больше времени на исправление, рефакторинг или устранение последствий.\n\n**Причины возникновения технического долга:**\n- Сжатые сроки разработки\n- Отсутствие тестов\n- Плохая архитектура\n- Устаревшие технологии\n- Недостаточная документация\n- Отсутствие код-ревью\n\n**Типы технического долга:**\n- **Сознательный** — команда понимает, что решение временное, и планирует его улучшить.\n- **Бессознательный** — команда не осознаёт низкое качество кода (например, из-за неопытности).\n- **Стратегический** — долг принимается как часть бизнес-решения (например, для быстрого выхода на рынок).\n- **Наследуемый** — долг, доставшийся от предыдущих версий системы или команд.\n\n**Управление техническим долгом** включает:\n- **Идентификацию** — регулярный анализ кода и архитектуры.\n- **Классификацию и приоритизацию** — оценка рисков и влияния на систему.\n- **Планирование погашения** — выделение времени на рефакторинг в спринтах.\n- **Мониторинг** — отслеживание динамики долга с помощью метрик.\n\n#### Практический подход\n\nНа практике студенты будут анализировать реальный или учебный проект с помощью инструментов статического анализа. Задача — собрать метрики (Cyclomatic Complexity, Code Coverage и др.), выявить участки с высоким техническим долгом и предложить план улучшений.\n\n**Пример отчёта по оценке качества и плану улучшений:**\n\n1. **Выявленные проблемы:**\n   - Функция `calculateTax()` имеет цикломатическую сложность 25.\n   - Покрытие модуля `auth` тестами — 45%.\n   - Обнаружено 15 дублирующихся блоков кода.\n\n2. **Рекомендации:**\n   - Разбить `calculateTax()` на подфункции.\n   - Дописать модульные тесты для `auth`, цель — 80% покрытия.\n   - Вынести дублирующий код в общие утилиты.\n\n3. **План погашения технического долга:**\n   - Выделить 20% времени в каждом спринте на рефакторинг.\n   - Ввести обязательное код-ревью и анализ кода в CI/CD.\n   - Провести технический аудит каждые 3 месяца.\n\n#### Заключение\n\nКачество ПО — не разовое достижение, а непрерывный процесс. Управление техническим долгом позволяет поддерживать систему в здоровом состоянии, снижать риски и обеспечивать устойчивое развитие. Студенты, освоившие эти навыки, смогут не только выявлять риски качества, но и предлагать обоснованные меры по их устранению, что делает их ценными участниками команд разработки масштабируемых систем."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5: Командная разработка и инструменты поддержки\n\nЭффективная командная разработка программного обеспечения невозможна без использования современных инструментов и чётко выстроенных процессов. В условиях масштабируемых систем, где участвует множество специалистов — от аналитиков и архитекторов до разработчиков и тестировщиков — критически важно обеспечить прозрачность, согласованность и контроль изменений на всех этапах жизненного цикла ПО. В этом помогают такие практики, как **трассируемость требований** и **управление изменениями (change management)**, а также специализированные инструменты, ставшие стандартами в отрасли.\n\n#### Ключевые инструменты командной разработки\n\n1. **Jira** (Atlassian)\n   - Платформа для управления проектами и задачами.\n   - Позволяет создавать и отслеживать задачи (issues), организовывать их в эпики, спринты, релизы.\n   - Поддерживает гибкие методологии (Agile, Scrum, Kanban).\n   - Обеспечивает **трассируемость**: каждое требование может быть связано с задачей, а задача — с коммитом, пул-реквестом и тестом.\n   - Интегрируется с Confluence, GitLab, Bitbucket и CI/CD-системами.\n\n2. **GitLab**\n   - Платформа для управления репозиториями, CI/CD, код-ревью и безопасностью.\n   - Поддерживает полный DevOps-цикл: от написания кода до деплоя.\n   - Включает встроенные средства для **управления изменениями**: ветки, merge requests, пайплайны, автоматические тесты.\n   - Позволяет привязывать коммиты к задачам из Jira или внутренним issue, обеспечивая сквозную трассировку.\n\n3. **Confluence** (Atlassian)\n   - Централизованная платформа для документирования.\n   - Используется для хранения требований, архитектурных решений, протоколов встреч, руководств.\n   - Поддерживает совместную работу, версионность и привязку к страницам из Jira.\n   - Позволяет создавать **архитектурные дорожные карты** и **документы по шаблону C4**.\n\n#### Трассируемость требований\n\nТрассируемость — это способность отслеживать путь требования от его первоначальной формулировки до реализации и тестирования. Это критически важно для:\n\n- Обеспечения полноты реализации.\n- Анализа влияния изменений (impact analysis).\n- Аудита и соответствия стандартам (например, ISO, DO-178C).\n- Управления техническим долгом.\n\n**Как реализуется трассируемость**:\n- Каждое требование нумеруется и фиксируется в Jira или Confluence.\n- Задача разработки создаётся на основе требования и ссылается на него.\n- Коммит в GitLab содержит ссылку на задачу (например, `Closes PROJ-123`).\n- Тесты (юнит, интеграционные) также связаны с задачей.\n- В итоге формируется цепочка: **Требование → Задача → Код → Тест → Релиз**.\n\n#### Управление изменениями (Change Management)\n\nИзменения в требованиях или архитектуре неизбежны. Без контроля они ведут к хаосу, техническому долгу и ошибкам. Change management включает:\n\n- **Формальное одобрение изменений** через Change Request (CR).\n- **Оценку влияния** (impact analysis) на архитектуру, сроки, ресурсы.\n- **Документирование решений** в Confluence или архитектурных заметках (ADR — Architecture Decision Records).\n- **Контроль через пул-реквесты и код-ревью** в GitLab.\n- **Версионирование архитектуры** и артефактов.\n\n#### Практическое применение\n\nВ рамках практики студенты симулируют командную разработку:\n- Формируют команду (аналитик, архитектор, разработчик, тестировщик).\n- Получают набор требований.\n- Оформляют их в Jira, создают эпики и задачи.\n- Документируют архитектурное решение в Confluence по шаблону C4.\n- Реализуют прототип архитектуры в GitLab с ветками, MR и CI.\n- Проводят код-ревью и утверждение изменений.\n\n#### Итоговое задание\n\nСтуденты работают в командах над **итоговым проектом** — разработкой архитектуры масштабируемой системы (например, сервиса доставки заказов). Проект включает:\n- Сбор и анализ требований.\n- Проектирование архитектуры с обоснованием выбора паттернов.\n- Документирование по C4.\n- Реализацию сквозной трассировки в Jira + GitLab + Confluence.\n- Управление изменениями через ADR и пул-реквесты.\n\n**Результат**: команда демонстрирует системный подход, использует промышленные инструменты и готова к работе в реальных проектах."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Итоговый проект\n\n**Описание:**\nИтоговый проект модуля представляет собой командную работу по проектированию масштабируемой и надёжной системы — например, платформы онлайн-обучения (аналог Coursera или Stepik). Проект охватывает все ключевые этапы системного подхода к разработке программного обеспечения и позволяет студентам применить полученные знания на практике в реалистичном контексте.\n\n**Цель проекта:**\nСоздать архитектурное решение, которое не только удовлетворяет функциональным требованиям, но и учитывает нефункциональные аспекты: масштабируемость, отказоустойчивость, безопасность, производительность и поддерживаемость.\n\n---\n\n### Этапы выполнения проекта:\n\n1. **Сбор и анализ требований**\n   - Определение целевой аудитории (студенты, преподаватели, администраторы).\n   - Формулировка **функциональных требований**: регистрация, просмотр курсов, прохождение уроков, сдача тестов, выдача сертификатов, модерация контента.\n   - Определение **нефункциональных требований**: \n     - Поддержка до 100 000 активных пользователей.\n     - Время отклика API не более 500 мс при пиковой нагрузке.\n     - Доступность 99.9% (SLA).\n     - Защита персональных данных (соответствие GDPR).\n   - Документирование требований с использованием трассируемости (например, в Confluence или Notion).\n\n2. **Выбор архитектурного стиля и паттернов**\n   - Обоснованный выбор архитектуры: например, **микросервисная архитектура** для гибкости и независимого развёртывания.\n   - Применение архитектурных паттернов:\n     - **CQRS** для разделения операций чтения и записи (например, в системе аналитики курсов).\n     - **Event Sourcing** для отслеживания изменений состояния (например, прогресса пользователя).\n     - **API Gateway** для маршрутизации и аутентификации.\n     - **Circuit Breaker** для повышения отказоустойчивости.\n   - Обоснование выбора технологического стека (например, Kubernetes для оркестрации, Kafka для обмена событиями).\n\n3. **Построение C4-диаграмм**\n   - Создание иерархии диаграмм по методологии **C4 Model**:\n     - **Контекст (C1)**: система в окружении (пользователи, внешние сервисы: платежи, email, аналитика).\n     - **Контейнеры (C2)**: основные приложения и сервисы (веб-фронтенд, API Gateway, сервис пользователей, сервис курсов, базы данных).\n     - **Компоненты (C3)**: внутри ключевых сервисов (например, компоненты аутентификации, хранения видео, генерации сертификатов).\n     - **Код (C4)**: опционально — примеры диаграмм классов или последовательностей для критических модулей.\n   - Использование инструментов: Structurizr, PlantUML, Mermaid.js или Draw.io.\n\n4. **Оценка качества и технического долга**\n   - Проведение **архитектурного анализа** с использованием методов, таких как ATAM (Architecture Tradeoff Analysis Method).\n   - Оценка рисков: задержки при масштабировании, сложность отладки распределённых транзакций.\n   - Идентификация технического долга:\n     - Временные решения (например, монолитный модуль, который позже нужно разбить).\n     - Отсутствие unit-тестов в некоторых сервисах.\n     - Устаревшие зависимости.\n   - Разработка плана погашения долга (roadmap на 3–6 месяцев).\n\n5. **Документирование и презентация решения**\n   - Полная архитектурная документация в репозитории (Git/Confluence):\n     - Описание архитектуры.\n     - Диаграммы C4.\n     - Обоснование решений (архитектурные дневники).\n     - План тестирования (включая нагрузочное и безопасность).\n   - Подготовка презентации (10–15 минут):\n     - Проблема и контекст.\n     - Архитектурные решения.\n     - Как учтены нефункциональные требования.\n     - Работа команды и распределение ролей.\n     - Выводы и возможные улучшения.\n\n---\n\n### Формат сдачи:\n- **Презентация** (в формате PDF или Google Slides).\n- **Репозиторий с документацией** (например, на GitHub/GitLab с README, диаграммами и пояснениями, или в Confluence с чёткой структурой).\n\n### Критерии оценки:\n| Критерий | Описание |\n|---------|----------|\n| **Полнота покрытия требований** | Все функциональные и нефункциональные требования учтены и реализованы в архитектуре. |\n| **Обоснованность архитектурных решений** | Выбор паттернов, технологий и стиля архитектуры логичен и подкреплён аргументами. |\n| **Качество документирования (C4)** | Диаграммы понятны, соответствуют уровню детализации C4, сопровождаются пояснениями. |\n| **Учёт нефункциональных требований** | Архитектура явно поддерживает масштабируемость, безопасность, производительность и т.д. |\n| **Работа в команде и использование инструментов** | Чёткое распределение задач, использование систем контроля версий, трассируемость изменений, совместная работа в Confluence/Git. |\n\n---\n\n### Ожидаемый результат:\nСтуденты демонстрируют **комплексное понимание процесса проектирования ПО** — от идеи до архитектурной документации. Они готовы к участию в реальных проектах в качестве архитекторов, tech lead’ов или senior-разработчиков, способных принимать взвешенные решения и отвечать за качество системы в долгосрочной перспективе."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Модуль 6: Проектирование масштабируемых систем",
        "max_score": 100,
        "passing_score": 60,
        "questions": [
          {
            "text": "Опишите ключевые различия между каскадной (Waterfall), итерационной и Agile-моделями жизненного цикла ПО. В каких условиях каждая из них наиболее эффективна? Приведите примеры проектов, где использование каждой модели будет оправдано.",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Какие нефункциональные требования критически важны при проектировании масштабируемой системы? Выберите три таких требования и объясните, как они влияют на выбор архитектурных решений (например, использование балансировщиков нагрузки, кэширования, репликации баз данных и т.д.).",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Сравните монолитную и микросервисную архитектуры с точки зрения масштабируемости, отказоустойчивости, сложности разработки и управления техническим долгом. В каких случаях переход от монолита к микросервисам оправдан, а в каких — может привести к избыточной сложности?",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Объясните, как метод C4 Model способствует эффективной коммуникации между участниками проекта (архитекторами, разработчиками, менеджерами, заказчиками). Опишите содержание и назначение каждого из четырёх уровней C4 (Контекст, Контейнеры, Компоненты, Код).",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Что такое технический долг в разработке ПО? Опишите его типы (сознательный, бессознательный, стратегический, наследуемый) и объясните, почему игнорирование технического долга может привести к катастрофическим последствиям в долгосрочной перспективе. Какие практики помогают управлять и постепенно погашать технический долг?",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Представьте, что вы архитектор системы электронной коммерции с высокой нагрузкой. Какие архитектурные паттерны (например, CQRS, Event Sourcing, API Gateway, Circuit Breaker) вы бы применили и почему? Опишите сценарии, в которых каждый из этих паттернов принесёт наибольшую пользу.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Как инструменты Jira, GitLab и Confluence поддерживают процессы трассируемости требований и управления изменениями в командной разработке? Опишите, как строится сквозная цепочка от требования до реализации и тестирования с использованием этих инструментов.",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Почему метрики кода (например, цикломатическая сложность, покрытие тестами, дублирование кода) важны для оценки качества ПО? Как они помогают выявлять участки с высоким техническим долгом? Приведите пример интерпретации метрик для конкретного модуля системы.",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "В чём заключается компромисс при выборе архитектурного стиля для системы? Почему не существует универсального решения, подходящего для всех проектов? Приведите пример, когда простая монолитная архитектура может быть предпочтительнее сложной микросервисной.",
            "options": [],
            "correct_answers": [],
            "points": 15
          }
        ]
      }
    },
    {
      "id": "16c23c8d-2cb9-4fac-8e91-51d12d97dd11",
      "title": "Модуль 7: Архитектура программного обеспечения и управление качеством",
      "description": "В этом модуле студенты освоят системный подход к проектированию и разработке программного обеспечения. На основе полученных знаний о жизненном цикле ПО, сборе требований и архитектурных паттернах они научатся проектировать масштабируемые, надёжные и поддерживаемые системы, документировать архитектурные решения по шаблону C4, разрабатывать стратегию тестирования, оценивать качество ПО и управлять техническим долгом. Особое внимание уделено командной работе, трассируемости требований и управлению изменениями в архитектуре.",
      "learning_objectives": [
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
        "Применять архитектурные паттерны и обосновывать их выбор.",
        "Документировать архитектурные решения по шаблону C4.",
        "Разрабатывать стратегию тестирования, включая нефункциональные аспекты.",
        "Оценивать качество ПО и управлять техническим долгом.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 7,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля 7: Архитектура ПО и управление качеством",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 7: Архитектура ПО и управление качеством] --> B[Тема 1: Жизненный цикл ПО и управление требованиями]\n    A --> C[Тема 2: Проектирование архитектуры и архитектурные паттерны]\n    A --> D[Тема 3: Документирование архитектуры (C4)]\n    A --> E[Тема 4: Стратегия тестирования и качество ПО]\n    A --> F[Тема 5: Управление техническим долгом и изменениями]\n    \n    B --> B1[Лекция: Модели жизненного цикла (Waterfall, Agile, DevOps)]\n    B --> B2[Практика: Сбор и анализ требований для учебного проекта]\n    B --> B3[Задание: Документирование функциональных и нефункциональных требований]\n    \n    C --> C1[Лекция: Принципы хорошей архитектуры: масштабируемость, надёжность, поддерживаемость]\n    C --> C2[Лекция: Архитектурные паттерны (монолит, микросервисы, событийная архитектура и др.)]\n    C --> C3[Практика: Выбор и обоснование архитектуры для кейса]\n    \n    D --> D1[Лекция: Моделирование архитектуры с помощью C4]\n    D --> D2[Практика: Построение диаграмм C4 (C1–C4) для реального проекта]\n    D --> D3[Задание: Подготовка архитектурной документации по шаблону C4]\n    \n    E --> E1[Лекция: Стратегия тестирования: unit, integration, E2E, нагрузочное, безопасность]\n    E --> E2[Лекция: Метрики качества ПО (надёжность, производительность, поддерживаемость)]\n    E --> E3[Практика: Разработка плана тестирования с учётом нефункциональных требований]\n    \n    F --> F1[Лекция: Технический долг: виды, оценка, управление]\n    F --> F2[Лекция: Трассируемость требований и управление изменениями]\n    F --> F3[Практика: Работа в команде: рефакторинг, code review, управление архитектурными изменениями]\n    F --> F4[Итоговый проект: Командная разработка архитектуры и документации для учебного приложения]\n```",
          "explanation": "Данная диаграмма в формате Mermaid (flowchart TD) визуализирует структуру модуля 7, показывая иерархию тем, лекций, практических занятий и заданий. Она помогает студентам понять логическую последовательность изучения материала и взаимосвязь между компонентами модуля."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Общая структура модуля\n\nМодуль построен вокруг практического проектирования архитектуры программной системы. Каждая тема последовательно ведёт студентов от понимания жизненного цикла и требований к проектированию, документированию и оценке качества. В финале — командный проект, интегрирующий все навыки.\n\n**Формат занятий:**\n- Лекции (онлайн или запись)\n- Практические занятия (в аудитории/виртуально)\n- Групповые обсуждения и разбор кейсов\n- Индивидуальные и командные задания\n- Использование инструментов: Jira, Confluence, Draw.io, Structurizr, SonarQube, Git\n\n**Ожидаемые результаты от студентов:**\n- Полная архитектурная документация по C4\n- План тестирования с нефункциональными аспектами\n- Оценка качества и технического долга\n- Презентация архитектурного решения с обоснованием выбора паттернов\n\n**Примечание:** Модуль 8 будет посвящён *Безопасности в архитектуре*, поэтому здесь безопасность затрагивается только как нефункциональное требование и аспект тестирования."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Рекомендации для авторов контента\n\n1. **Язык и стиль:** Используйте доступный, но профессиональный тон изложения. Избегайте излишнего академизма и сложных теоретических конструкций без пояснений. Объясняйте термины на понятных примерах. Например, при обсуждении масштабируемости можно привести кейс интернет-магазина, который сталкивается с ростом нагрузки во время распродаж — как архитектурные решения помогают справляться с этим.\n\n2. **Практическая направленность:** Каждая лекция должна включать практическое задание, ориентированное на активное обучение. Например:\n   - **Case study:** Проанализировать архитектуру сервиса бронирования отелей: выявить компоненты, оценить соответствие требованиям, предложить улучшения.\n   - **Role play:** Разыграть сценарий согласования архитектурного решения между аналитиком, разработчиком и архитектором.\n   - **Peer review:** Обменяться архитектурными диаграммами по модели C4 и провести взаимную оценку.\n\n3. **Интеграция инструментов:** Включайте задания с использованием реальных инструментов разработки:\n   - **Jira:** Создать эпики и задачи, привязать их к требованиям, настроить трассируемость.\n   - **Confluence:** Оформить архитектурное решение по шаблону C4, добавить обоснование выбора паттерна.\n   - **Git:** Зафиксировать изменение архитектуры, создать ветку, описать мотивацию в коммите.\n   - **SonarQube:** Проанализировать код на наличие технического долга, интерпретировать отчёт и предложить действия.\n\n4. **Поддержка командной работы:** Предусмотрите групповые задания с чётким распределением ролей. Например, в проекте по проектированию системы доставки еды:\n   - **Архитектор** отвечает за выбор паттерна и построение диаграмм C4.\n   - **Аналитик** собирает и документирует требования.\n   - **Тестировщик** разрабатывает стратегию тестирования, включая производительность и отказоустойчивость.\n   Каждый участник должен иметь понятные критерии выполнения задачи.\n\n5. **Обратная связь:** Для всех заданий предоставьте подробные критерии оценки (rubrics). Включите примеры:\n   - **Хорошее решение:** Чёткая диаграмма C4, обоснованный выбор микросервисной архитектуры, трассировка требований в Jira.\n   - **Плохое решение:** Отсутствие уровней в C4, игнорирование нефункциональных требований, несогласованные изменения в архитектуре без документирования.\n\n6. **Связь с предыдущими знаниями:** Опираясь на опыт студентов в ООП и веб-разработке, переводите фокус с уровня кода на системный. Например, вместо обсуждения наследования в классах — обсуждение взаимодействия сервисов и границ ответственности. Подчеркните, что теперь важно не только «как написать код», но и «как построить систему».\n\n7. **Связь с последующим модулем:** В последней теме модуля сделайте акцент на безопасности как на ключевом нефункциональном требовании. Обсудите, как выбор архитектуры влияет на безопасность (например, аутентификация в микросервисах, шифрование данных). Это плавно подводит к Модулю 8, посвящённому кибербезопасности и защите данных."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Практическое задание: Проектирование архитектуры системы доставки еды",
        "max_score": 100,
        "passing_score": 60,
        "questions": [
          {
            "text": "Опишите жизненный цикл разработки программного обеспечения, выберите подходящую модель (Waterfall, Agile, DevOps) для проекта системы доставки еды и обоснуйте свой выбор с учётом требований к скорости выхода на рынок, частым изменениям функциональности и необходимой надёжности. Какие этапы жизненного цикла будут особенно критичны в данном случае и почему?",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Соберите и структурируйте функциональные и нефункциональные требования для системы доставки еды. Приведите не менее 5 функциональных требований (например, регистрация пользователя, оформление заказа) и 5 нефункциональных (например, время отклика, масштабируемость, безопасность). Объясните, как каждое нефункциональное требование повлияет на архитектурные решения.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Выберите подходящий архитектурный паттерн (монолит, микросервисы, событийная архитектура и др.) для системы доставки еды. Обоснуйте свой выбор, сравнив преимущества и недостатки минимум двух паттернов с учётом собранных требований. Укажите, какие компоненты системы будут выделены в отдельные сервисы или модули и по каким критериям.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Постройте диаграммы архитектуры по модели C4 (уровни C1–C4) для выбранной архитектуры. Опишите каждый уровень: контекст (C1), контейнеры (C2), компоненты (C3), код (C4). Объясните, как использование модели C4 помогает команде разработчиков, тестировщиков и стейкхолдерам понимать систему.",
            "options": [],
            "correct_answers": [],
            "points": 20
          },
          {
            "text": "Разработайте стратегию тестирования для системы доставки еды. Включите в план unit-тесты, интеграционные тесты, E2E-тесты, нагрузочное тестирование и тестирование безопасности. Объясните, какие инструменты вы бы использовали для каждого типа тестов и как нефункциональные требования (например, производительность, отказоустойчивость) будут проверяться.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Оцените потенциальные источники технического долга в вашей архитектуре (например, упрощённая реализация аутентификации, отсутствие мониторинга, дублирование кода). Предложите стратегию управления техническим долгом: как вы будете его выявлять, документировать, приоритизировать и устранять в рамках итераций разработки?",
            "options": [],
            "correct_answers": [],
            "points": 10
          },
          {
            "text": "Опишите, как вы будете обеспечивать трассируемость требований в проекте. Какие инструменты (например, Jira, Confluence) вы используете? Как будет организована привязка требований к задачам, архитектурным решениям и тестам? Как команда будет реагировать на изменение требования (например, добавление оплаты криптовалютой) с точки зрения управления изменениями?",
            "options": [],
            "correct_answers": [],
            "points": 10
          }
        ]
      }
    },
    {
      "id": "d25c71fd-fd67-4efa-a7a6-a1e1ef242d36",
      "title": "Модуль 8: Документирование архитектуры ПО с использованием C4 Model",
      "description": "В этом модуле студенты осваивают системный подход к документированию архитектуры программного обеспечения с использованием C4 Model — современного и широко применяемого метода визуализации архитектуры ПО. На основе полученных ранее знаний о жизненном цикле разработки, сборе требований и проектировании архитектуры, студенты учатся структурированно представлять архитектурные решения на разных уровнях детализации: от контекста системы до кода. Особое внимание уделяется практическому применению C4 Model для улучшения коммуникации в команде, поддержки принятия архитектурных решений и обеспечения трассируемости между требованиями, архитектурой и реализацией.",
      "learning_objectives": [
        "Документировать архитектурные решения по шаблону C4.",
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
        "Применять архитектурные паттерны и обосновывать их выбор.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 8,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля 8: Документирование архитектуры ПО с использованием C4 Model",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 8: Документирование архитектуры ПО с использованием C4 Model] --> B[Тема 8.1: Введение в документирование архитектуры]\n    A --> C[Тема 8.2: Уровни C4 Model — Контекст и Контейнеры]\n    A --> D[Тема 8.3: Компоненты и Код в C4 Model]\n    A --> E[Тема 8.4: Инструменты и практики применения C4]\n    A --> F[Тема 8.5: Интеграция C4 с процессами разработки]\n```",
          "explanation": "Диаграмма отображает структуру модуля 8 в виде древовидной блок-схемы, показывая, как основной модуль разбивается на пять тем. Каждая тема представляет собой логический блок содержания, посвящённый определённому аспекту применения C4 Model в документировании архитектуры программного обеспечения."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 8.1: Введение в документирование архитектуры\n\nДокументирование архитектуры программного обеспечения — это не просто формальность, а критически важный элемент успешной разработки ПО. Оно служит основой для эффективной коммуникации между всеми участниками проекта: разработчиками, архитекторами, тестировщиками, менеджерами и даже бизнес-заказчиками. Хорошо оформленная архитектурная документация позволяет передавать знания о системе, поддерживать её в актуальном состоянии и обеспечивать преемственность при смене команды или масштабировании проекта.\n\n#### Почему важно документировать архитектуру?\n\n1. **Коммуникация** — архитектурная документация помогает всем заинтересованным сторонам понимать, как устроена система, какие компоненты в неё входят и как они взаимодействуют. Это особенно важно в крупных или распределённых командах.\n2. **Поддержка и сопровождение** — без документации поддержка системы становится сложной и рискованной. Разработчики тратят время на «расшифровку» кода, что увеличивает вероятность ошибок.\n3. **Передача знаний** — документация снижает зависимость от отдельных специалистов, уменьшая риски, связанные с их уходом из проекта (так называемый «эффект бритвы»).\n\n#### Проблемы традиционной документации\n\nНа практике архитектурная документация часто игнорируется или становится бесполезной из-за следующих причин:\n- **Устаревание** — документы не обновляются при изменениях в системе.\n- **Избыточность** — создаются слишком подробные и сложные документы, которые никто не читает.\n- **Отсутствие актуальности** — документация не отражает реальное состояние системы.\n- **Отсутствие целевой аудитории** — документы пишутся «для галочки», а не для конкретных читателей.\n\n#### Обзор подходов к документированию\n\nСуществует несколько современных подходов, призванных решить эти проблемы:\n- **ADR (Architecture Decision Records)** — фиксация ключевых архитектурных решений с обоснованием, датой и статусом. Позволяет отслеживать эволюцию архитектуры.\n- **Views and Beyond** — метод, предложенный Филиппом Крюгликом, предлагает описывать архитектуру с разных точек зрения (логическая, процессная, развертывания и др.) в зависимости от потребностей аудитории.\n- **C4 Model** — иерархический подход к визуализации архитектуры на четырёх уровнях: Контекст, Контейнеры, Компоненты и Код. Позволяет постепенно углубляться в детали, не перегружая читателя.\n\n#### Принципы хорошей архитектурной документации\n\n- **Актуальность** — документация должна отражать текущее состояние системы.\n- **Минимальность** — включать только ту информацию, которая действительно нужна.\n- **Ориентация на аудиторию** — разные документы создаются для разных читателей (технических и нетехнических).\n- **Поддерживаемость** — документы должны быть простыми в обновлении и интегрированы в процесс разработки.\n\nВ следующих темах мы подробно рассмотрим C4 Model как один из наиболее практичных и современных подходов к документированию архитектуры ПО."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 8.2: Уровни C4 Model — Контекст и Контейнеры\n\n**Цель:** Научиться описывать систему на высоком уровне с помощью уровней *Context* и *Container* в рамках C4 Model.\n\n#### Общая структура C4 Model: 4 уровня абстракции\n\nC4 Model — это иерархический подход к визуализации архитектуры программного обеспечения, предложенный Саймоном Брауном. Он состоит из четырёх уровней детализации, что позволяет постепенно «погружаться» от общего к частному:\n\n1. **Контекст (Context)** — самый высокий уровень абстракции.\n2. **Контейнеры (Containers)** — логическая структура системы.\n3. **Компоненты (Components)** — внутренняя структура контейнеров.\n4. **Код (Code)** — конкретная реализация (классы, функции и т.д.).\n\nВ этой теме мы сосредоточимся на первых двух уровнях.\n\n#### Уровень 1: Контекст (System Context)\n\nДиаграмма контекста показывает **систему в её окружении**: кто и с чем взаимодействует. Она отвечает на вопрос: *«Что делает система и с кем она взаимодействует?»*\n\n**Основные элементы диаграммы:**\n- **Система** — центральный объект (например, «Приложение для управления задачами»).\n- **Акторы** — пользователи, внешние системы, интеграции (например, «Пользователь», «Служба уведомлений», «Календарь Google»).\n- **Связи** — стрелки, обозначающие взаимодействие (например, «создаёт задачи», «отправляет уведомления»).\n\n**Цель:** Дать всем заинтересованным сторонам (включая нетехнических) общее понимание системы.\n\n#### Уровень 2: Контейнеры (Containers)\n\nКонтейнер — это **высокоуровневый исполняемый компонент**, который должен быть запущен отдельно. Контейнеры представляют логическую архитектуру системы.\n\n**Типичные контейнеры:**\n- Веб-приложение (например, React, Angular)\n- Backend API (например, Spring Boot, Node.js)\n- База данных (PostgreSQL, MongoDB)\n- Служба сообщений (Kafka, RabbitMQ)\n- Фронтенд для мобильных устройств\n\n**Что показывает диаграмма контейнеров:**\n- Какие контейнеры есть в системе.\n- Как они взаимодействуют между собой.\n- Какие технологии используются в каждом контейнере.\n\n**Пример обозначений:**\n- Прямоугольник — контейнер, внутри: название + технология.\n- Стрелки — направление вызовов/взаимодействий, с подписью (например, «HTTP/JSON»).\n\n#### Пример: Интернет-магазин\n\n**Контекст:**\n- Система: «Интернет-магазин»\n- Акторы: Покупатель, Администратор, Платёжная система, Служба доставки\n\n**Контейнеры:**\n- Веб-фронтенд (React)\n- API Gateway (Node.js)\n- Сервис заказов (Spring Boot)\n- Сервис оплаты (Python)\n- База данных (PostgreSQL)\n- Kafka (для событий)\n\n#### Рекомендации по стилю диаграмм\n- Используйте простые формы и понятные подписи.\n- Избегайте излишней детализации на уровне контекста и контейнеров.\n- Подписывайте протоколы и форматы данных (например, REST/JSON, gRPC).\n- Используйте инструменты: Structurizr, Draw.io, PlantUML, Mermaid.\n\n> 💡 **Совет:** Диаграммы должны быть понятны как разработчикам, так и бизнес-аналитикам. Чёткость важнее красоты."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 8.3: Комоненты и Код в C4 Model\n\nC4 Model — это иерархический подход к визуализации архитектуры программного обеспечения, который позволяет представлять систему на разных уровнях детализации. После рассмотрения контекста системы (уровень 1) и её контейнеров (уровень 2), следующим шагом становится детализация до **уровня компонентов (уровень 3)** и, при необходимости, до **уровня кода (уровень 4)**. Эти уровни особенно важны для разработчиков, архитекторов и технических лидов, поскольку они напрямую связаны с реализацией архитектурных решений.\n\n#### Уровень 3: Компоненты — логические модули внутри контейнера\n\nНа третьем уровне C4 Model фокус смещается на **внутреннюю структуру контейнера**. Компонент — это логическая часть внутри контейнера, отвечающая за определённую функциональность. Например, в контейнере *Backend API* могут быть выделены следующие компоненты:\n\n- **User Management Service** — управление пользователями;\n- **Order Processing Service** — обработка заказов;\n- **Notification Service** — отправка уведомлений;\n- **Data Access Layer** — взаимодействие с базой данных;\n- **Authentication Module** — аутентификация и авторизация.\n\nКаждый компонент:\n- Имеет чётко определённую ответственность;\n- Взаимодействует с другими компонентами через чётко заданные интерфейсы;\n- Может быть реализован как отдельный модуль, пакет или пространство имён в коде.\n\nДиаграмма компонентов показывает:\n- Какие компоненты существуют внутри контейнера;\n- Как они взаимодействуют между собой (например, через HTTP, сообщения, вызовы методов);\n- Какие технологии используются (например, REST, gRPC, очереди);\n- Где хранятся данные (например, через ссылки на базы данных).\n\n#### Связь компонентов с архитектурными паттернами\n\nСтруктура компонентов напрямую отражает выбранный **архитектурный паттерн**. Например:\n\n- **MVC (Model-View-Controller)**: компоненты могут быть разделены на *Controller*, *Service*, *Repository* — что соответствует слоям приложения.\n- **CQRS (Command Query Responsibility Segregation)**: могут быть выделены отдельные компоненты для команд (*Command Handlers*) и запросов (*Query Handlers*), а также отдельные модели данных.\n- **Микросервисы**: хотя микросервисы обычно моделируются как отдельные контейнеры, внутри каждого микросервиса может быть своя внутренняя компонентная структура (например, слои: API Gateway, Business Logic, Persistence).\n- **Слоистая архитектура**: компоненты группируются по слоям — Presentation, Business, Data Access.\n\nТаким образом, диаграмма компонентов помогает **визуализировать и обосновать выбор архитектурного паттерна**, а также служит инструментом для обсуждения и рецензирования архитектуры.\n\n#### Уровень 4: Код — как использовать C4 для навигации по исходному коду\n\nЧетвёртый уровень C4 Model — **диаграммы кода** — представляет собой детализацию компонентов до уровня классов, интерфейсов, модулей и их взаимосвязей. Этот уровень не всегда документируется вручную, но может быть полезен в следующих случаях:\n\n- Обучение новых разработчиков;\n- Анализ сложных модулей;\n- Поддержка рефакторинга;\n- Аудит архитектуры.\n\nПример: компонент *Order Processing Service* может быть представлен как диаграмма классов UML, где показаны:\n- `OrderService`, `OrderValidator`, `OrderRepository`;\n- Их методы и связи (наследование, агрегация, зависимость);\n- Используемые паттерны проектирования (например, *Factory*, *Observer*).\n\n#### Обратная генерация диаграмм из кода\n\nРучное поддержание диаграмм на уровне кода может быть трудоёмким. Для автоматизации используются инструменты, которые **генерируют диаграммы на основе анализа исходного кода**:\n\n- **PlantUML + инструменты анализа кода (например, jQAssistant, Structurizr)**: позволяют писать правила для извлечения структуры кода и визуализации её в виде диаграмм.\n- **Structurizr**: поддерживает интеграцию с Java, .NET и другими стеками, позволяет автоматически строить диаграммы компонентов и кода на основе аннотаций или статического анализа.\n- **Doxygen, Sphinx, JSDoc** — генерируют документацию с диаграммами (включая UML), особенно полезны в сочетании с PlantUML.\n\nПример использования:\n```java\n@Component\npublic class OrderService {\n    @Autowired\n    private OrderRepository repository;\n    \n    public Order createOrder(OrderDTO dto) { ... }\n}\n```\n\nС помощью jQAssistant и PlantUML можно автоматически сгенерировать диаграмму, где `OrderService` связан с `OrderRepository`, а также показать зависимости между пакетами.\n\n#### Ограничения и лучшие практики детализации\n\n**Ограничения**:\n- **Передокументирование**: чрезмерная детализация до уровня кода может привести к устареванию диаграмм.\n- **Сложность поддержки**: диаграммы уровня 4 требуют постоянной синхронизации с кодом.\n- **Избыточность**: не все компоненты требуют детального описания.\n\n**Лучшие практики**:\n- Документируйте компоненты **только для ключевых модулей**.\n- Используйте **автоматическую генерацию** диаграмм там, где это возможно.\n- Поддерживайте **согласованность** между диаграммами и кодом через CI/CD.\n- Фокусируйтесь на **архитектурно значимых решениях**, а не на каждом классе.\n- Используйте **легенды и метаданные** (например, технологию, ответственного разработчика, уровень риска).\n\n#### Задания\n\n1. **Выберите один из контейнеров** (например, *Backend API*) и **разработайте диаграмму компонентов** (уровень 3). Укажите:\n   - Названия компонентов;\n   - Их ответственность;\n   - Технологии;\n   - Взаимодействия между компонентами.\n\n2. **Сопоставьте компоненты с классами/модулями в коде**. Например:\n   - Компонент *User Management Service* → пакет `com.example.users`, классы `UserService`, `UserRepository`.\n   - Компонент *Authentication Module* → `AuthController`, `JwtTokenProvider`.\n\n3. **Напишите краткое пояснение**, как диаграмма компонентов помогает новому разработчику освоиться в проекте. Пример:\n   > Диаграмма компонентов позволяет новому разработчику быстро понять, из каких частей состоит система, за что отвечает каждый модуль, как они взаимодействуют и какие технологии используются. Это сокращает время на вхождение в проект, снижает риск ошибок при внесении изменений и упрощает коммуникацию в команде."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 8.4: Инструменты и практики применения C4\n\nДля эффективного использования C4 Model в реальных проектах важно не только понимать концепции уровней модели (Контекст, Контейнеры, Компоненты, Код), но и освоить инструменты и практики, позволяющие создавать, поддерживать и интегрировать диаграммы в процесс разработки ПО.\n\n#### Обзор инструментов для работы с C4 Model\n\nСуществует ряд инструментов, поддерживающих создание C4-диаграмм:\n\n- **Structurizr** — один из самых мощных инструментов, разработанный создателем C4 Model Саймоном Брауном. Позволяет создавать, хранить и визуализировать диаграммы в облаке или локально. Поддерживает полную иерархию C4, экспорт в различные форматы и интеграцию с кодом через DSL и API.\n\n- **PlantUML** — текстовый инструмент для генерации диаграмм на основе описания. Поддерживает UML и C4 через специальные библиотеки (например, `C4-PlantUML`). Позволяет хранить диаграммы в виде кода, что упрощает версионирование и совместную работу.\n\n- **Mermaid** — популярный инструмент для рендеринга диаграмм прямо в Markdown. Поддерживает базовые типы диаграмм (включая flowchart, sequence, class), а также позволяет визуализировать C4-модели с помощью пользовательских стилей и синтаксиса.\n\n- **Draw.io (diagrams.net)** — графический редактор с открытым исходным кодом. Удобен для ручного создания диаграмм, поддерживает шаблоны C4 и интеграцию с Confluence, Git и Google Drive.\n\n- **Archi** — бесплатный инструмент на основе ArchiMate, который можно адаптировать для C4-моделирования. Подходит для архитекторов, работающих в рамках enterprise-архитектуры.\n\n#### Автоматизация и генерация диаграмм\n\nОдной из передовых практик является **генерация диаграмм из кода или документации**. Например, с помощью инструментов вроде Structurizr можно автоматически строить диаграммы на основе аннотаций в коде или конфигурационных файлов. Это снижает риск расхождения между архитектурой и реализацией.\n\nТакже можно использовать скрипты для извлечения структуры микросервисов, баз данных и API из документации (OpenAPI, Swagger) и автоматического обновления диаграмм.\n\n#### Интеграция C4 в документацию\n\nC4-диаграммы должны быть частью **живой документации**. Их можно встраивать в:\n\n- **Markdown-файлы** в репозиториях Git (с использованием PlantUML или Mermaid);\n- **Confluence** — с помощью встраивания изображений или интеграции с Structurizr;\n- **Wiki-системы и внутренние порталы** — для обеспечения доступа всей команде.\n\nРекомендуется хранить диаграммы рядом с кодом (в папке `/docs`) и обновлять их при каждом значимом изменении архитектуры.\n\n#### Поддержание актуальности диаграмм\n\nДиаграммы теряют ценность, если устаревают. Чтобы этого избежать:\n\n- Ввести **процесс ревью архитектуры** при каждом изменении (например, в рамках pull request);\n- Назначить **ответственного архитектора** за обновление диаграмм;\n- Включить обновление диаграмм в **Definition of Done** для задач по архитектуре;\n- Использовать **автоматизированные проверки** (например, CI-пайплайны, предупреждающие о несоответствии).\n\n#### Шаблоны и стили оформления\n\nДля единообразия рекомендуется использовать:\n\n- Единые цветовые схемы (например, по типу элемента: пользователи, внешние системы, микросервисы);\n- Стандартизированные иконки и шрифты;\n- Шаблоны диаграмм для каждого уровня C4;\n- Описание легенды и условных обозначений в документации.\n\nСтандартизация улучшает читаемость и ускоряет восприятие архитектуры новыми членами команды.\n\n---\n\n> **Практический совет**: Начните с простого — используйте PlantUML или Mermaid в Markdown. Это позволит быстро внедрить C4 в ваш процесс без сложной настройки инфраструктуры."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 8.5: Интеграция C4 с процессами разработки\n\n**Цель:** Научиться использовать C4 Model как часть жизненного цикла разработки ПО.\n\n---\n\n#### C4 как инструмент коммуникации\n\nC4 Model — это не просто способ визуализации архитектуры, а мощный инструмент коммуникации между всеми участниками процесса разработки. Благодаря своей иерархической структуре (контекст, контейнеры, компоненты, код), C4 позволяет каждому стейкхолдеру видеть систему на нужном уровне детализации:\n\n- **Заказчики и бизнес-аналитики** — работают с диаграммой уровня *Контекст (Level 1)*, чтобы понимать, как система взаимодействует с внешними пользователями и другими системами.\n- **Архитекторы и технические лидеры** — используют диаграммы *Контейнеров (Level 2)* и *Компонентов (Level 3)* для проектирования и обсуждения структуры системы.\n- **Разработчики** — углубляются до уровня *Кода (Level 4)*, чтобы понимать реализацию компонентов.\n- **Тестировщики** — используют диаграммы для понимания границ системы, интеграционных точек и потоков данных, что помогает в проектировании тестовых сценариев.\n\nТакой многоуровневый подход снижает вероятность недопонимания и делает архитектурные обсуждения более продуктивными.\n\n---\n\n#### Трассируемость: связь диаграмм с требованиями, user stories, задачами в Jira\n\nОдно из ключевых преимуществ C4 Model — возможность установить **трассируемость** между архитектурой и требованиями. Это означает, что каждое архитектурное решение может быть связано с конкретным требованием или user story.\n\nНапример:\n- User story: «Пользователь может экспортировать отчёт в PDF» → может быть связана с компонентом `ReportService` на диаграмме компонентов.\n- Нефункциональное требование: «Система должна обрабатывать 1000 запросов в секунду» → может быть отражено в выборе архитектуры контейнеров (например, использование микросервисов и балансировки нагрузки).\n\nВ инструментах вроде **Jira** или **Confluence** можно:\n- Добавлять ссылки на C4-диаграммы в описание эпиков и задач.\n- Использовать теги или кастомные поля для привязки задач к уровням C4.\n- Вести «карту трассируемости» — таблицу, где каждая строка связывает требование, архитектурный элемент и задачу.\n\nЭто помогает отслеживать, какие требования реализованы, какие архитектурные решения приняты, и как они влияют на систему.\n\n---\n\n#### Использование C4 при ревью архитектуры и планировании релизов\n\nC4-диаграммы активно используются на архитектурных ревью:\n- На уровне **Контекста** проверяется соответствие системы бизнес-целям.\n- На уровне **Контейнеров** обсуждаются технологии, взаимодействие сервисов, безопасность.\n- На уровне **Компонентов** анализируется модульность, зависимости, потенциальные узкие места.\n\nПри **планировании релизов** C4 помогает:\n- Оценить сложность изменений (например, затронет ли новая фича несколько контейнеров).\n- Выявить риски интеграции.\n- Определить, какие команды будут задействованы (если система распределена между несколькими командами).\n\n---\n\n#### Управление техническим долгом: как C4 помогает выявлять архитектурные проблемы\n\nC4 Model позволяет визуализировать технический долг на архитектурном уровне. Например:\n- **Циклические зависимости** между компонентами становятся очевидны на диаграмме.\n- **Нарушение слоёв** (например, прямой вызов базы данных из UI) легко обнаруживается.\n- **Устаревшие технологии** можно пометить на диаграмме (например, красным цветом или стереотипом `«legacy»`).\n\nРегулярное обновление C4-диаграмм помогает:\n- Фиксировать архитектурные решения.\n- Планировать рефакторинг.\n- Обосновывать необходимость выделения времени на устранение технического долга.\n\n---\n\n#### Пример кейса: рефакторинг системы с использованием C4\n\n**Ситуация:** Монолитная система с высокой связанностью, трудно масштабируемая, с частыми сбоями при обновлениях.\n\n**Шаги с использованием C4:**\n1. Построена диаграмма **Контейнеров**, выявлены основные модули: `UI`, `Business Logic`, `Database`.\n2. На диаграмме **Компонентов** обнаружены циклические зависимости и отсутствие чёткой модульности.\n3. Принято решение о переходе к микросервисной архитектуре.\n4. Создана новая диаграмма **Контейнеров**, где монолит разбит на сервисы: `OrderService`, `PaymentService`, `NotificationService`.\n5. Каждый сервис описан на уровне компонентов, определены API и форматы обмена.\n6. Связаны user stories и задачи в Jira с новыми архитектурными элементами.\n\n**Результат:** Упрощено понимание системы, улучшена масштабируемость, сокращено время внедрения изменений.\n\n---\n\n### Задания\n\n1. **Создать карту трассируемости:** Сопоставьте элементы C4-диаграммы (например, компоненты) с требованиями из предоставленного backlog. Используйте таблицу: `Требование → Уровень C4 → Элемент → Задача в Jira`.\n\n2. **Симуляция архитектурного обсуждения:** В команде из 3–4 человек проведите обсуждение предложенного изменения в системе, используя C4-диаграммы. Зафиксируйте обсуждение в виде отчёта или аудиозаписи (по согласованию с преподавателем).\n\n3. **Подготовить презентацию (5–7 слайдов):** «Как C4 Model улучшает качество и прозрачность разработки ПО». Включите примеры из практики, преимущества для разных ролей, и как C4 интегрируется в процессы разработки.\n\n---\n\n**Вывод:** Интеграция C4 Model в процессы разработки превращает архитектуру из статического документа в живой, управляемый актив. Это повышает прозрачность, улучшает коммуникацию и помогает принимать обоснованные технические решения на всех этапах жизненного цикла ПО."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Итоговое задание по модулю\n\n**Тема:** Разработка архитектурной документации с использованием C4 Model\n\n**Цель задания:**\n\nНа основе полученных знаний о методе C4 Model и процессах архитектурного проектирования, разработать полный комплект архитектурной документации для условной системы — **платформы онлайн-обучения** (например, аналога Coursera или Stepik). Задание направлено на применение системного подхода к визуализации и документированию архитектуры ПО, а также на развитие навыков архитектурного мышления, обоснования решений и командной коммуникации.\n\n---\n\n### Задачи\n\n1. **Разработать C4-диаграммы на всех уровнях детализации:**\n   - **Контекст (Context):** показать систему в окружении — пользователей, внешние системы (платежные шлюзы, SSO, аналитика и т.д.).\n   - **Контейнеры (Containers):** определить основные исполняемые компоненты системы (веб-приложение, мобильное приложение, API-бэкенд, базы данных, микросервисы и т.п.) и их взаимодействие.\n   - **Компоненты (Components):** выбрать один ключевой контейнер (например, «Сервис управления курсами») и детализировать его внутреннюю структуру — основные компоненты, их ответственность и связи.\n\n2. **Подготовить Архитектурное Решение (ADR):**\n   - Оформить одно или несколько архитектурных решений в формате ADR (Architectural Decision Record).\n   - Обосновать выбор архитектурного паттерна (например, микросервисы vs монолит, REST vs GraphQL, использование CQRS и т.д.).\n   - Указать влияние решения на нефункциональные требования (масштабируемость, безопасность, надёжность).\n\n3. **Создать инструкцию по поддержанию документации:**\n   - Описать процесс обновления C4-диаграмм при внесении изменений в архитектуру.\n   - Указать, кто отвечает за актуальность документации (архитектор, разработчик, техлид).\n   - Предложить интеграцию с CI/CD или системой управления задачами (например, автоматическая генерация диаграмм из кода или обновление при мерже в main).\n\n---\n\n### Формат сдачи\n\n1. **Git-репозиторий**, содержащий:\n   - Диаграммы в текстовом формате (рекомендуется **PlantUML** или **Mermaid**).\n   - Markdown-файлы с описанием диаграмм, ADR и инструкцией.\n   - Структура репозитория:\n     ```\n     docs/\n     ├── c4-model/\n     │   ├── context.puml\n     │   ├── containers.puml\n     │   └── components-course-service.mmd\n     ├── adr/\n     │   └── adr-001-microservices-decision.md\n     └── documentation-guide.md\n     ```\n\n2. **Презентация (10 минут)** для защиты перед «техническим советом» (преподаватель и одногруппники), включающая:\n   - Краткий обзор системы и требований.\n   - Демонстрацию ключевых диаграмм.\n   - Обоснование архитектурных решений.\n   - Подход к поддержанию документации.\n\n---\n\n### Критерии оценки\n\n| Критерий | Описание | Макс. балл |\n|---------|---------|----------|\n| **Полнота и корректность диаграмм** | Все уровни C4 присутствуют, корректно отражают структуру системы, используются правильные обозначения | 30 |\n| **Ясность и логичность обоснований** | ADR написан чётко, с аргументацией, учётом альтернатив и последствий | 25 |\n| **Интеграция с требованиями и процессами** | Связь между диаграммами, требованиями и архитектурными решениями прослеживается | 20 |\n| **Качество документации и презентации** | Документация структурирована, легко читается; презентация логична, укладывается в время, отвечает на вопросы | 25 |\n| **Итого** | | **100** |\n\n---\n\n### Рекомендации\n\n- Используйте инструменты визуализации: [Structurizr](https://structurizr.com/), [Mermaid Live Editor](https://mermaid.live/), [PlantUML Server](https://www.plantuml.com/plantuml/).\n- Придерживайтесь принципа «прогрессивного раскрытия деталей» — не перегружайте диаграммы.\n- Связывайте элементы диаграмм с требованиями (например, «компонент X реализует требование REQ-12»).\n- Обсуждайте решения в команде, если задание выполняется группой.\n\n---\n\n**Важно:** Это задание — итоговое, оно интегрирует знания всех предыдущих модулей: от сбора требований до проектирования и документирования. Подходите к нему как к реальному архитектурному проекту в профессиональной среде."
        }
      ],
      "assignment": {
        "assignment_type": "github",
        "version": 0,
        "title": "Практическое задание: Разработка архитектурной документации с использованием C4 Model",
        "max_score": 100,
        "passing_score": 70,
        "repository_task": "https://github.com/edu-arch/c4-module-assignment",
        "repository_rules": "https://github.com/edu-arch/c4-module-assignment/blob/main/.github/CONTRIBUTING.md",
        "required_branch": "main"
      }
    },
    {
      "id": "ed8646a4-2d5c-4e05-b745-edf75c4e1136",
      "title": "Модуль 9: Проектирование и архитектура программного обеспечения",
      "description": "В этом модуле студенты освоят системный подход к разработке программного обеспечения, научатся проектировать архитектуру ПО, управлять требованиями и документировать архитектурные решения. Модуль закладывает основы для понимания жизненного цикла разработки и подготовки к тестированию ПО, которое будет изучаться в следующем модуле.",
      "learning_objectives": [
        "Понимать жизненный цикл разработки ПО и применять его этапы на практике.",
        "Собирать, анализировать и документировать функциональные и нефункциональные требования.",
        "Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.",
        "Применять архитектурные паттерны и обосновывать их выбор.",
        "Документировать архитектурные решения по шаблону C4.",
        "Разрабатывать стратегию тестирования, включая нефункциональные аспекты.",
        "Оценивать качество ПО и управлять техническим долгом.",
        "Работать в команде, использовать инструменты трассируемости и управления изменениями."
      ],
      "order": 9,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля 9: Проектирование и архитектура ПО",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 9: Проектирование и архитектура ПО] --> B[Тема 1: Жизненный цикл разработки ПО]\n    A --> C[Тема 2: Сбор и анализ требований]\n    A --> D[Тема 3: Проектирование архитектуры ПО]\n    A --> E[Тема 4: Архитектурные паттерны]\n    A --> F[Тема 5: Документирование архитектуры (C4)]\n    A --> G[Тема 6: Качество ПО и технический долг]\n    A --> H[Тема 7: Командная работа и управление изменениями]\n    B --> B1[Модели жизненного цикла: Waterfall, Iterative, Agile, DevOps]\n    B --> B2[Этапы ЖЦ: анализ, проектирование, реализация, тестирование, сопровождение]\n    C --> C1[Функциональные и нефункциональные требования]\n    C --> C2[Методы сбора: интервью, анкетирование, user stories]\n    C --> C3[Моделирование требований: Use Case, BPMN]\n    D --> D1[Принципы хорошей архитектуры: масштабируемость, надёжность, поддерживаемость]\n    D --> D2[Уровни абстракции: компоненты, сервисы, слои]\n    E --> E1[Монолит vs Микросервисы]\n    E --> E2[Паттерны: MVC, Layered, CQRS, Event-Driven]\n    E --> E3[Выбор паттерна под задачу]\n    F --> F1[Модель C4: Контекст, Контейнеры, Компоненты, Код]\n    F --> F2[Инструменты: Structurizr, PlantUML]\n    G --> G1[Метрики качества ПО: coupling, cohesion, cyclomatic complexity]\n    G --> G2[Технический долг: виды, оценка, управление]\n    G --> G3[Статический анализ кода]\n    H --> H1[Трассируемость требований]\n    H --> H2[Управление изменениями: change requests, impact analysis]\n    H --> H3[Инструменты: Jira, Confluence, Git]\n```",
          "explanation": ""
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "Модуль 9 посвящён системному подходу к разработке программного обеспечения и подготовке к тестированию. Студенты, уже имеющие опыт программирования, получат навыки проектирования архитектуры, управления требованиями и документирования решений. Особое внимание уделено практическому применению знаний в командной работе.\n\nВ этом модуле рассматриваются ключевые аспекты жизненного цикла разработки ПО — от сбора требований до архитектурного проектирования и подготовки к тестированию. Вы научитесь различать функциональные и нефункциональные требования, грамотно их анализировать и документировать, а также применять проверенные архитектурные паттерны, обосновывая свой выбор с учётом масштабируемости, надёжности и поддерживаемости системы.\n\nОсобое внимание уделяется навыку документирования архитектурных решений по шаблону C4 (Context, Containers, Components, Code), что позволяет командам эффективно коммуницировать и поддерживать прозрачность архитектуры на всех уровнях. Также вы освоите инструменты трассируемости требований и управления изменениями, что критически важно при работе в команде.\n\nМодуль закладывает прочную основу для последующего изучения тестирования ПО, включая разработку стратегии тестирования и оценку качества программного продукта. Вы научитесь оценивать технический долг и управлять им, чтобы обеспечить долгосрочную устойчивость и развитие проекта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Введение в проектирование и архитектуру программного обеспечения\n\nВы уже умеете писать код, создавать приложения, работать с базами данных и даже тестировать свои решения. Однако, когда проект вырастает из отдельного скрипта или небольшого веб-приложения до системы, в которой участвуют десятки компонентов, команд и пользователей, простого знания языка программирования становится недостаточно. Именно здесь на помощь приходит **системный подход к разработке программного обеспечения**.\n\n#### Почему проектирование важно?\n\nПредставьте, что вы строите дом. Вы же не начинаете с укладки кирпичей без чертежа, верно? Точно так же и в разработке ПО: без чёткого плана — архитектуры — проект быстро превращается в «спагетти-код», который невозможно поддерживать, масштабировать или тестировать.\n\nАрхитектура ПО — это **высокоуровневая структура системы**, которая определяет:\n- Какие компоненты будут в системе;\n- Как они взаимодействуют между собой;\n- Какие технологии будут использоваться;\n- Как система будет масштабироваться и обеспечивать надёжность.\n\n#### Жизненный цикл разработки ПО\n\nРазработка программного обеспечения — это не просто написание кода. Это процесс, состоящий из нескольких этапов, известных как **жизненный цикл ПО**. Наиболее распространённые модели:\n\n- **Каскадная модель (Waterfall)** — этапы идут строго последовательно: анализ требований → проектирование → реализация → тестирование → внедрение → сопровождение.\n- **Итеративная и инкрементная модель** — система строится по частям, каждая итерация приближает нас к полному решению.\n- **Agile (гибкие методологии)** — акцент на быструю доставку функциональности, постоянную обратную связь и адаптацию к изменениям.\n\nВыбор модели зависит от характера проекта, сроков, требований и команды.\n\n#### Требования к системе\n\nПеред тем как проектировать архитектуру, нужно понять, **что именно должна делать система**. Требования делятся на:\n\n- **Функциональные** — что система должна уметь делать (например, «пользователь может зарегистрироваться через email»).\n- **Нефункциональные** — как система должна себя вести (например, «система должна обрабатывать 1000 запросов в секунду» или «время отклика не должно превышать 200 мс»).\n\nУмение собирать, анализировать и документировать требования — ключевой навык архитектора.\n\n#### Архитектурные паттерны\n\nАрхитектурные паттерны — это проверенные решения типовых задач проектирования. Например:\n\n- **Монолит** — всё в одном приложении (просто, но сложно масштабировать).\n- **Микросервисы** — система разбита на независимые сервисы (гибко, но сложнее в управлении).\n- **Слоистая архитектура** — разделение на слои (например, представление, бизнес-логика, данные).\n\nВыбор паттерна зависит от требований к масштабируемости, надёжности и скорости разработки.\n\n#### Документирование архитектуры: C4 Model\n\nКак объяснить команде, как устроена система? Для этого используется **C4 Model** — методология документирования архитектуры на четырёх уровнях:\n\n1. **Контекст** — система в окружении (пользователи, внешние системы).\n2. **Контейнеры** — основные части приложения (веб-приложение, база данных, API).\n3. **Компоненты** — внутри контейнеров (сервисы, контроллеры, репозитории).\n4. **Код** — диаграммы классов, UML (при необходимости).\n\nЭто помогает всем участникам проекта — от разработчиков до менеджеров — понимать структуру системы.\n\n#### Качество ПО и технический долг\n\nКачество программного обеспечения оценивается по таким характеристикам, как:\n\n- Надёжность\n- Производительность\n- Безопасность\n- Поддерживаемость\n\n**Технический долг** — это компромиссы, которые мы принимаем ради скорости (например, плохой код, отсутствие тестов). Если его не контролировать, он приводит к замедлению разработки и росту ошибок.\n\n#### Что будет в этом модуле?\n\nВы научитесь:\n- Собирать и анализировать требования;\n- Выбирать и обосновывать архитектурные решения;\n- Документировать архитектуру по C4;\n- Оценивать качество ПО;\n- Управлять изменениями и техническим долгом.\n\nЭтот модуль — мост между умением писать код и умением строить сложные, надёжные и масштабируемые системы."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Тест по модулю 9: Проектирование и архитектура программного обеспечения",
        "max_score": 100,
        "passing_score": 70,
        "questions": [
          {
            "text": "Опишите ключевые различия между функциональными и нефункциональными требованиями. Приведите по два примера каждого типа требований для системы онлайн-заказа еды и объясните, как каждое из них влияет на архитектурные решения.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Сравните каскадную (Waterfall) и гибкую (Agile) модели жизненного цикла разработки ПО. В каких типах проектов каждая из них наиболее эффективна? Обоснуйте свой ответ с учётом управления требованиями, сроков и рисков.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Объясните, почему выбор архитектурного паттерна является критически важным этапом проектирования. Проанализируйте, в каких случаях предпочтительнее использовать монолитную архитектуру, а в каких — микросервисы. Приведите конкретные примеры систем и обоснуйте ваш выбор с точки зрения масштабируемости, сложности развертывания и поддерживаемости.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Опишите модель C4 документирования архитектуры ПО. На примере веб-приложения для управления задачами (to-do list с совместной работой) постройте краткое описание каждого из четырёх уровней (Контекст, Контейнеры, Компоненты, Код). Как такая многоуровневая документация помогает команде разработчиков и другим стейкхолдерам?",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Что такое технический долг в разработке ПО? Опишите три вида технического долга (например, связанного с кодом, архитектурой, тестированием) и предложите стратегии управления каждым из них. Как игнорирование технического долга может повлиять на долгосрочную устойчивость проекта?",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Рассмотрим систему электронного университета, где студенты могут записываться на курсы, преподаватели — выставлять оценки, а администраторы — управлять расписанием. Спроектируйте Use Case-диаграмму (в текстовом описании): выделите основных акторов, их цели и взаимодействия с системой. Какие нефункциональные требования вы бы предложили для такой системы и почему?",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Почему важно обеспечивать трассируемость требований в процессе разработки? Опишите, как инструменты вроде Jira и Confluence могут быть использованы для поддержки трассируемости и управления изменениями. Как анализ влияния изменений (impact analysis) помогает минимизировать риски при внесении правок в архитектуру?",
            "options": [],
            "correct_answers": [],
            "points": 10
          }
        ]
      }
    }
  ],
  "final_assessment": null
}