import { initApp } from "../general/createModules.js";

const data = {
  creator_id: 1779915071,
  status: "review",
  image_url: null,
  title: "Инженерия программного обеспечения",
  description:
    "Курс учит студентов IT-направлений мыслить как инженеры ПО: проектировать архитектуру, управлять сложностью и принимать обоснованные решения на основе реальных требований, а не гипотез. Основной акцент — на переходе от учебных проектов к практике без излишнего усложнения.",
  learning_objectives: [
    "Понимать жизненный цикл программного обеспечения и этапы разработки",
    "Уметь читать и проектировать архитектуру на уровне компонентов",
    "Научиться проектировать собственные проекты без излишнего усложнения (overengineering)",
    "Понять, как принимать архитектурные решения на основе текущих, а не гипотетических требований",
    "Развить навык оценки контекста и принятия взвешенных инженерных решений",
    "Осознать разницу между качественной архитектурой и избыточной сложностью",
    "Научиться выделять границы модульности и компонентов в приложении",
  ],
  modules: [
    {
      title: "Модуль 0: Жизненный цикл ПО и основы инженерии",
      description:
        "Введение в системное мышление в разработке ПО. Студенты осознают разницу между написанием кода и инженерным подходом к созданию программного обеспечения. Модуль формирует фундамент для проектирования архитектуры, понимания контекста и принятия взвешенных решений.",
      order: 0,
      assignment: {
        assignment_type: "test",
        title: "Тест по теме: Жизненный цикл программного обеспечения",
        max_score: 3,
        passing_score: 2,
        questions: [
          {
            text: "Опишите основные этапы жизненного цикла программного обеспечения (ЖЦ ПО) и кратко объясните, какая цель преследуется на каждом из них. Какие последствия могут быть, если пропустить один из этапов, например, этап тестирования?",
            options: [
              "Пропуск этапа тестирования не влияет на качество ПО, если разработчики опытные",
              "Пропуск тестирования может привести к выходу ПО с критическими ошибками, что повлияет на репутацию и безопасность",
              "Тестирование можно заменить этапом проектирования",
            ],
            correct_answers: [1],
            points: 1,
          },
          {
            text: "В чём принципиальное различие между программированием и инженерией программного обеспечения? Приведите пример, когда простое программирование может оказаться недостаточным, и объясните, почему в этом случае требуется именно инженерный подход.",
            options: [
              "Программирование — это написание кода, а инженерия ПО — только управление командой разработчиков",
              "Инженерия ПО включает в себя только тестирование и документирование, а программирование — это реализация",
              "Инженерия ПО — это системный подход, включающий планирование, анализ требований, проектирование, тестирование и сопровождение, тогда как программирование — лишь часть этого процесса",
            ],
            correct_answers: [2],
            points: 1,
          },
          {
            text: "Команда разработчиков получила от заказчика описание функциональности нового приложения для учёта рабочего времени. Сейчас они анализируют, какие именно данные нужно собирать, как пользователи будут взаимодействовать с системой, какие ограничения существуют (например, интеграция с существующими системами). На каком этапе жизненного цикла ПО находится проект? Обоснуйте свой ответ.",
            options: [
              "Этап программирования",
              "Этап сопровождения",
              "Этап анализа требований",
            ],
            correct_answers: [2],
            points: 1,
          },
        ],
        version: 0,
      },
      content_blocks: [
        {
          content_type: "video",
          platform: "RuTube",
          title:
            "От идеи к системе: история провала стартапа из-за отсутствия инженерного подхода",
          url: "https://rutube.ru/video/1a2b3c4d5e6f7g8h9i0j/",
          discussion_questions: [
            "Что, по вашему мнению, стало основной причиной краха приложения?",
          ],
          duration_seconds: 118,
          key_moments: [],
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            "Вы умеете писать код. Вы делали MVC-приложения, использовали Git, возможно, даже разворачивали что-то на сервере. Но задумывались ли вы, почему в реальных проектах так много времени тратится не на код, а на обсуждения, схемы, документы и встречи?\n\n**Инженерия ПО — это не только написание кода, а системный подход к созданию и поддержке программного обеспечения.**\n\nКогда мы говорим о *программировании*, мы чаще всего имеем в виду процесс написания инструкций для компьютера — реализацию логики, алгоритмов, интерфейсов. Это важная, но лишь одна из составляющих *инженерии программного обеспечения*.\n\n### Программирование vs. Инженерия ПО: в чём разница?\n\n| Аспект | Программирование | Инженерия ПО |\n|--------|------------------|-------------|\n| **Фокус** | Написание кода, реализация функций | Создание надёжной, масштабируемой, поддерживаемой системы |\n| **Цель** | Решить конкретную задачу | Решить задачу с учётом долгосрочных последствий |\n| **Масштаб** | Отдельный модуль, функция | Вся система, её компоненты, взаимодействия |\n| **Подход** | Часто интуитивный, творческий | Системный, дисциплинированный, основанный на методологиях |\n| **Инструменты** | Языки программирования, редакторы кода | Методологии разработки, UML, архитектурные шаблоны, метрики качества |\n\n### Почему одного программирования недостаточно?\n\nПредставьте, что вы строите дом. Вы можете отлично класть кирпичи (это как писать код), но если не продумана фундамент, планировка, электропроводка, водоснабжение — дом может обрушиться или станет непригодным для жизни.\n\nТо же самое с программным обеспечением:\n\n- **Без анализа требований** вы можете создать идеальное приложение, которое никто не будет использовать.\n- **Без проектирования архитектуры** система быстро станет «спагетти-кодом», который невозможно поддерживать.\n- **Без тестирования и контроля качества** в продакшен попадут критические ошибки.\n- **Без управления изменениями и документацией** новые разработчики не смогут влиться в проект.\n- **Без учёта операционной среды** приложение может работать на вашем компьютере, но падать на сервере.\n\n### Пример: Приложение для заказа еды\n\n**Программистский подход:**\n- Написать функцию, которая принимает заказ.\n- Сохранить его в базу.\n- Отправить уведомление.\n- Готово.\n\n**Инженерный подход:**\n- Какие требования у пользователей и бизнеса?\n- Как масштабируется система при 10 000 заказах в минуту?\n- Что делать при сбое платежной системы?\n- Как обеспечить безопасность персональных данных?\n- Как обновлять систему без остановки?\n- Как измерять производительность и надёжность?\n\nИнженерия ПО — это **мышление на шаг вперёд**. Это не просто «сделать, чтобы работало», а «сделать, чтобы работало **долго**, **надёжно**, **масштабируемо** и **с минимальными затратами на поддержку**».\n\n### Вывод\n\nПрограммирование — это инструмент. Инженерия ПО — это дисциплина, которая определяет, **как**, **зачем** и **для кого** этот инструмент используется. В этом модуле мы начинаем переходить от роли «кодера» к роли «инженера» — человека, который видит систему целиком, понимает её контекст и принимает взвешенные решения.",
          ai_generated: true,
        },
        {
          content_type: "mermaid",
          title: "Жизненный цикл программного обеспечения",
          mermaid_code:
            "```mermaid\n%%{init: {'theme': 'base'}}%%\ndiagram LR\n    A[Анализ требований] --> B[Проектирование]\n    B --> C[Разработка]\n    C --> D[Тестирование]\n    D --> E[Внедрение]\n    E --> F[Сопровождение]\n    F -->|Обратная связь| A\n    classDef stage fill:#4C9AFF,stroke:#333,stroke-width:2px;\n    class A,B,C,D,E,F stage;\n```",
          explanation:
            "Диаграмма отражает классическую модель жизненного цикла программного обеспечения с итеративной обратной связью. Каждый этап выделен стилистически для наглядности. Петля обратной связи от 'Сопровождения' к 'Анализу требований' подчёркивает важность непрерывного улучшения — ключевой аспект инженерного подхода, который студенты осваивают в этом модуле.",
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            "## Жизненный цикл программного обеспечения\n\nЖизненный цикл программного обеспечения (ЖЦ ПО) — это структурированный процесс создания, внедрения, эксплуатации и вывода из использования программной системы. Он охватывает все этапы, начиная с момента возникновения идеи и заканчивая окончанием использования продукта. Важно понимать, что современный жизненный цикл ПО — это не строго линейная последовательность, а итеративный и гибкий процесс, в котором этапы могут повторяться, перекрываться или выполняться параллельно в зависимости от выбранной методологии разработки.\n\nКаждый этап жизненного цикла решает свои задачи и вносит вклад в качество конечного продукта. Даже в небольших проектах или прототипах эти этапы проходят, хотя и не всегда формально фиксируются.\n\n### Основные этапы жизненного цикла ПО\n\n#### 1. Анализ требований\n\nНа этапе анализа определяется, **что** именно должно делать программное обеспечение. Основная цель — понять потребности пользователей, бизнес-цели и функциональные/нефункциональные требования.\n\n- Сбор требований (интервью, опросы, анализ документации)\n- Формализация требований (SRS — Software Requirements Specification)\n- Анализ осуществимости (технической, экономической, временной)\n\n> \uD83D\uDCA1 Ошибка на этапе анализа — самая дорогая. Исправление требований на поздних стадиях может потребовать переписывания архитектуры.\n\n#### 2. Проектирование\n\nНа этом этапе решается, **как** система будет реализована. Проектирование включает создание архитектуры ПО, выбор технологий, структурирование компонентов и определение взаимодействий между ними.\n\n- Архитектурное проектирование (микросервисы, монолит, слоистая архитектура)\n- Детальное проектирование (диаграммы классов, последовательностей, интерфейсов)\n- Проектирование баз данных\n- Прототипирование пользовательского интерфейса\n\nПроектирование — это мост между требованиями и реализацией. Хороший дизайн делает систему масштабируемой, поддерживаемой и устойчивой к изменениям.\n\n#### 3. Разработка (реализация)\n\nЭтап, с которым чаще всего ассоциируют программирование. Здесь происходит написание кода на основе проектной документации.\n\n- Написание кода\n- Рефакторинг\n- Интеграция компонентов\n- Версионный контроль (Git)\n- Соблюдение стандартов кодирования\n\nРазработка ведётся в соответствии с архитектурными решениями, но при этом возможны корректировки, если на практике выявляются ограничения или новые требования.\n\n#### 4. Тестирование\n\nЦель — проверить, соответствует ли ПО заявленным требованиям и работает ли оно корректно.\n\n- Модульное тестирование (unit)\n- Интеграционное тестирование\n- Системное тестирование\n- Приёмочное тестирование (UAT)\n- Тестирование производительности, безопасности, удобства использования\n\nТестирование не заканчивается перед релизом — оно продолжается в процессе эксплуатации, особенно при обновлениях.\n\n#### 5. Внедрение и развертывание\n\nПереход от тестовой среды к эксплуатации. Включает:\n\n- Подготовку инфраструктуры\n- Перенос данных\n- Настройку окружения\n- Обучение пользователей\n- Постепенный или полный запуск («горячий старт», поэтапное внедрение)\n\nСовременные подходы (CI/CD) позволяют автоматизировать развертывание и минимизировать риски.\n\n#### 6. Сопровождение и поддержка\n\nПосле запуска ПО продолжает развиваться. Этап сопровождения может длиться дольше всех остальных.\n\n- Исправление ошибок (bug fixing)\n- Адаптация к изменениям (новые ОС, законы, стандарты)\n- Улучшение производительности\n- Добавление новых функций\n- Технический долг: управление и погашение\n\n> \uD83D\uDCA1 Сопровождение — не второстепенная задача. До 70% стоимости ПО приходится на этот этап.\n\n### Модели жизненного цикла\n\nСуществует несколько моделей, описывающих организацию процесса разработки:\n\n- **Каскадная модель (Waterfall)** — строго последовательные этапы, подходит для стабильных требований.\n- **Итерационная модель** — постепенная реализация функциональности через повторяющиеся циклы.\n- **Водопад с обратными связями (V-Model)** — каждому этапу разработки соответствует этап тестирования.\n- **Гибкие методологии (Agile, Scrum, Kanban)** — акцент на итерациях, обратной связи и адаптации.\n\n### Заключение\n\nПонимание жизненного цикла ПО — основа инженерного подхода. Даже если вы пишете небольшое приложение, полезно мысленно пройти все этапы: понять задачу, продумать структуру, написать код, проверить его и поддерживать. Это помогает избежать хаоса, снизить риски и создавать качественные, долгоживущие системы.\n\n> \uD83D\uDCA1 Разработка ПО — это не просто написание кода. Это системная инженерная дисциплина, где каждый этап важен для успеха проекта.",
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            '### Почему ToDo-приложение — не инженерия?\n\nХотя создание простого приложения для управления задачами (ToDo-приложения) часто используется в качестве учебного задания, оно не отражает сути **инженерии программного обеспечения**. Такие приложения служат отличным инструментом для изучения базовых навыков — синтаксиса языка, работы с интерфейсом, простой логики. Однако они не затрагивают ключевые аспекты, с которыми сталкиваются инженеры в реальных проектах.\n\nРассмотрим два сценария — учебное ToDo-приложение и реальный продукт, подобный **Trello**, чтобы понять, где заканчивается программирование и начинается инженерия.\n\n| Критерий | Учебное ToDo-приложение | Реальный проект (например, Trello) |\n|--------|--------------------------|-----------------------------------|\n| **Требования** | Чёткие, статичные: "пользователь может добавлять, редактировать и удалять задачи" | Меняются, противоречивы: "нужна синхронизация в реальном времени", "интеграция с календарём", "ролевой доступ", "история изменений" |\n| **Архитектура** | Простая MVC-структура, всё в одном файле или модуле | Распределённая архитектура: микросервисы для задач, пользователей, уведомлений; очереди сообщений (например, Kafka); кэши (Redis); балансировка нагрузки |\n| **Документация** | Отсутствует или минимальна: комментарии в коде | Системная: диаграммы архитектуры, RFC (Request for Comments), ADR (Architecture Decision Records), спецификации API |\n| **Команда** | Один разработчик, работает в одиночку | Многопрофильная команда: бэкенд- и фронтенд-разработчики, DevOps, QA-инженеры, product-менеджеры, UX-дизайнеры |\n| **Поддержка** | Проект сдан — и забыт | Постоянная поддержка: исправление багов, обновление зависимостей, масштабирование под растущую нагрузку, мониторинг, логирование |\n\n### Где начинается инженерия?\n\n**Инженерия программного обеспечения** — это не просто написание кода, а **системный подход** к созданию и поддержанию сложных, надёжных и масштабируемых систем. Она включает в себя:\n\n- Управление требованиями и приоритетами\n- Проектирование архитектуры с учётом отказоустойчивости и производительности\n- Коллаборацию в крупных командах\n- Документирование решений\n- Автоматизированное тестирование и CI/CD\n- Мониторинг и обратную связь от пользователей\n\nУчебные проекты, такие как ToDo-приложение, важны для старта. Но настоящая инженерия начинается там, где появляются:\n\n- **Сложность** — множество взаимодействующих компонентов\n- **Неопределённость** — требования меняются, технологии устаревают\n- **Необходимость в совместной работе** — тысячи строк кода, десятки людей, долгий жизненный цикл продукта\n\n> \uD83D\uDCA1 **Вывод**: инженерия начинается там, где появляется сложность, неопределённость и необходимость в совместной работе. ToDo-приложение — это первый шаг. А инженерия — это путь.',
          ai_generated: true,
        },
        {
          content_type: "quiz",
          questions: [
            [
              "Какой из перечисленных этапов жизненного цикла ПО в первую очередь связан с пониманием потребностей заказчика и конечных пользователей?",
              "Анализ требований",
            ],
            [
              "Что является основной целью этапа проектирования в жизненном цикле разработки программного обеспечения?",
              "Определение архитектуры и структуры системы",
            ],
            [
              "Какой принцип системного мышления подразумевает рассмотрение ПО как части более крупной экосистемы, включая пользователей, инфраструктуру и бизнес-процессы?",
              "Контекстное мышление",
            ],
            [
              "Что из перечисленного является ключевым отличием инженерного подхода к разработке ПО от простого написания кода?",
              "Фокус на долгосрочной поддержке, масштабируемости и качестве архитектуры",
            ],
            [
              "На каком этапе жизненного цикла ПО проводится верификация и валидация системы на соответствие требованиям?",
              "Тестирование",
            ],
          ],
          ai_generated: true,
        },
        {
          content_type: "mermaid",
          title: "Жизненный цикл разработки приложения для заказа еды",
          mermaid_code:
            "```mermaid\ngraph TD\n    A[Анализ требований] --> B[Проектирование]\n    B --> C[Разработка]\n    C --> D[Тестирование]\n    D -->|Успешно| E[Внедрение]\n    E --> F[Сопровождение]\n\n    %% Обратные связи при обнаружении проблем\n    D -->|Критические ошибки/Изменение ТЗ| B\n    D -->|Ошибки реализации| C\n    \n    F -->|Новые требования| A\n    F -->|Запрос на доработку| C\n\n    %% Стили для наглядности\n    linkStyle 0 stroke:#0044cc,stroke-width:2px\n    linkStyle 1 stroke:#0044cc,stroke-width:2px\n    linkStyle 2 stroke:#0044cc,stroke-width:2px\n    linkStyle 3 stroke:#00aa00,stroke-width:2px\n    linkStyle 4 stroke:#0044cc,stroke-width:2px\n    \n    linkStyle 5 stroke:#cc0000,stroke-width:2px\n    linkStyle 6 stroke:#ff8800,stroke-width:2px\n    linkStyle 7 stroke:#9900cc,stroke-width:2px\n    linkStyle 8 stroke:#ff8800,stroke-width:2px\n```",
          explanation:
            "Основной поток разработки (синие стрелки):\nАнализ требований → Проектирование: Сбор и анализ потребностей студентов, преподавателей, столовых университета. Определение функциональности приложения.\n\nПроектирование → Разработка: Создание архитектуры приложения, дизайна интерфейса, схемы базы данных.\n\nРазработка → Тестирование: Непосредственное программирование приложения согласно проекту.\n\nТестирование → Внедрение (зеленая стрелка): После успешного тестирования приложение развертывается в университетской среде.\n\nВнедрение → Сопровождение: Приложение переходит в стадию активного использования и поддержки.\n\nОбратные связи (цветные стрелки):\nКрасная стрелка:\nТестирование → Проектирование: Возврат на этап проектирования при обнаружении:\n\nКритических архитектурных ошибок\n\nНеобходимости изменения технического задания\n\nФундаментальных проблем в логике работы\n\nОранжевые стрелки:\nТестирование → Разработка: Исправление ошибок программирования, багов, недочетов реализации.\n\nСопровождение → Разработка: Внесение доработок в работающее приложение по запросам пользователей.\n\nФиолетовая стрелка:\nСопровождение → Анализ требований: Сбор новых требований от пользователей для следующих версий приложения, что инициирует новый цикл разработки.\n\nОсобенности для приложения заказа еды в университете:\nАнализ требований: Учет специфики студенческого расписания, бюджетов, особенностей работы столовых\n\nПроектирование: Создание интерфейса, удобного для мобильного использования между парами\n\nТестирование: Проверка работы в условиях высокой нагрузки (перемены между парами)\n\nВнедрение: Интеграция с существующими университетскими системами (студенческие билеты, системы оплаты)\n\nСопровождение: Регулярное обновление меню, учет сезонности, работа с отзывами пользователей\n\nДиаграмма показывает итеративный подход, где обратные связи позволяют совершенствовать приложение на всех этапах жизненного цикла.",
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            '## Ключевые выводы\n\n- **Программирование — это часть инженерии ПО, но не вся инженерия.**\n  Написание кода — лишь один из этапов создания программного обеспечения. Инженерия ПО охватывает гораздо более широкий спектр деятельности: анализ требований, проектирование архитектуры, тестирование, сопровождение, управление изменениями и взаимодействие с заинтересованными сторонами. Системное мышление позволяет видеть ПО как часть сложной экосистемы, где важны не только технические, но и организационные, экономические и человеческие факторы.\n\n- **Жизненный цикл помогает структурировать процесс, а не только результат.**\n  Модели жизненного цикла разработки ПО (например, каскадная, итеративная, спиральная, Agile) предоставляют структуру для управления проектом. Они помогают распределить ответственность, планировать ресурсы, контролировать качество и минимизировать риски. Понимание жизненного цикла позволяет команде не просто писать код, а управлять процессом создания ценности для пользователя.\n\n- **Хорошая архитектура рождается на этапе проектирования, а не в процессе написания кода.**\n  Архитектурные решения должны приниматься осознанно, на основе анализа требований, масштабируемости, надёжности и поддерживаемости. Рефакторинг и адаптация неизбежны, но попытка «вырастить» архитектуру исключительно через написание кода часто приводит к техническому долгу, сложностям в сопровождении и ограничениям в развитии системы.\n\n- **Инженерные решения принимаются в контексте: команды, сроков, масштаба, требований.**\n  Нет универсальных «лучших практик». Выбор технологий, архитектурных паттернов и процессов зависит от конкретной ситуации. Решение, оптимальное для стартапа с ограниченными ресурсами, может быть неуместным в крупной корпорации с высокими требованиями к надёжности. Инженер должен уметь оценивать компромиссы и принимать обоснованные решения в условиях неопределённости.\n\n### Визуализация ключевых аспектов инженерии ПО  ```mermaid\npie title Состав инженерии программного обеспечения\n    "Программирование" : 30\n    "Проектирование архитектуры" : 20\n    "Анализ требований" : 15\n    "Тестирование и обеспечение качества" : 15\n    "Управление проектом и процессами" : 10\n    "Сопровождение и эволюция системы" : 10\n```',
          ai_generated: true,
        },
      ],
    },
    {
      title: "Модуль 1: Основы компонентной архитектуры",
      description:
        "Первый шаг от написания кода к проектированию систем. Студенты научатся видеть приложение не как набор классов, а как совокупность взаимодействующих компонентов с чёткими границами и ответственностями. Акцент — на развитие системного мышления и избегание излишнего усложнения (overengineering).",
      order: 1,
      content_blocks: [
        {
          content_type: "text",
          md_content:
            "### Введение: от кода к архитектуре\n\nВы уже умеете писать приложения — например, ToDo-лист с использованием MVC и Git. Но как перейти от «работающего кода» к «хорошей архитектуре»? В этом модуле вы начнёте видеть систему на уровне компонентов — крупных, логически завершённых частей приложения, каждая со своей зоной ответственности.\n\nКогда вы пишете код, ваше внимание сосредоточено на реализации конкретных функций: как добавить задачу, как сохранить её в базу данных, как отобразить на экране. Это важно, но на определённом этапе масштабирования приложения такой подход перестаёт быть эффективным. Возникают проблемы: трудности в поддержке, медленная интеграция новых функций, высокая связанность между частями кода.\n\nИменно здесь на помощь приходит **компонентная архитектура** — подход, при котором приложение разбивается на независимые, переиспользуемые компоненты, каждый из которых отвечает за определённую функциональность. Вместо того чтобы думать в терминах классов и функций, вы начинаете мыслить на уровне **модулей**, **сервисов** и **интерфейсов взаимодействия**.\n\n#### Почему компоненты?\n\nКомпонент — это автономная часть системы, которая:\n\n- Имеет чётко определённую **зону ответственности**;\n- Предоставляет **интерфейс** для взаимодействия с другими компонентами;\n- Минимизирует зависимости от других частей системы;\n- Может быть разработана, протестирована и развёрнута независимо (в идеале).\n\nТакой подход позволяет:\n\n- Упростить понимание и сопровождение кода;\n- Повысить переиспользуемость;\n- Ускорить разработку за счёт параллельной работы над разными компонентами;\n- Избежать «спагетти-кода» и технического долга.\n\n#### От излишнего проектирования к разумной структуре\n\nВажно понимать разницу между **архитектурой** и **overengineering** (чрезмерным усложнением). Хорошая архитектура не означает создание множества абстракций «на будущее». Она — результат осознанного разделения ответственностей *сейчас*, с учётом текущих и прогнозируемых потребностей.\n\nВ этом модуле вы научитесь:\n\n- Выделять компоненты в приложении;\n- Определять их границы и интерфейсы;\n- Проектировать взаимодействие между ними;\n- Избегать типичных ошибок при проектировании.\n\nЦель — не просто написать код, который работает, а создать систему, которую легко понимать, изменять и масштабировать.",
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            "### Почему компоненты?\n\nПо мере роста программного обеспечения его сложность увеличивается экспоненциально. Начиная с простых скриптов, разработчики рано или поздно сталкиваются с проблемой: код становится запутанным, трудно читаемым и практически невозможным для поддержки. Именно на этом этапе становится очевидной необходимость перехода от монолитной структуры к **компонентной архитектуре**.\n\n#### Проблемы монолитного кода\n\nМонолит — это подход, при котором всё приложение представляет собой единый блок кода, где классы, функции и модули тесно связаны между собой. На начальных этапах это удобно: быстро писать, легко запускать. Однако по мере роста приложения возникают следующие проблемы:\n\n- **Сложность поддержки**: изменение одной части кода может непредсказуемо повлиять на другую.\n- **Низкая тестируемость**: из-за сильной связанности сложно изолировать части системы для тестирования.\n- **Затруднённая командная разработка**: несколько разработчиков вынуждены работать в одних и тех же файлах, что ведёт к конфликтам слияния и ошибкам.\n- **Сложность повторного использования**: код нельзя легко перенести в другое приложение.\n- **Overengineering**: без чётких границ разработчики склонны добавлять избыточную абстракцию, усложняя архитектуру без реальной необходимости.\n\n#### Как компоненты решают эти проблемы\n\nКомпонент — это автономная часть системы, которая:\n\n- Имеет **чётко определённую ответственность**.\n- Взаимодействует с другими компонентами через **явные интерфейсы**.\n- Скрыт от внутренней реализации других компонентов (**инкапсуляция**).\n- Может быть разработан, протестирован и развиваться независимо.\n\nТакой подход позволяет:\n\n1. **Разделить ответственность**\n   Каждый компонент отвечает за свою зону: например, один — за аутентификацию, другой — за работу с базой данных, третий — за пользовательский интерфейс. Это упрощает понимание системы в целом.\n\n2. **Упростить тестирование**\n   Поскольку компоненты изолированы, их можно тестировать отдельно. Можно использовать моки и заглушки для зависимостей, что делает тесты быстрее и надёжнее.\n\n3. **Облегчить командную разработку**\n   Разные команды или разработчики могут работать над разными компонентами параллельно, не мешая друг другу. Главное — соблюдать контракты (интерфейсы) взаимодействия.\n\n4. **Избежать overengineering**\n   Компонентный подход заставляет задуматься: *«Что именно должен делать этот компонент?»* Это способствует осознанному проектированию. Вместо того чтобы создавать абстракции «на будущее», разработчик фокусируется на текущих задачах и выделяет компоненты только тогда, когда в этом есть реальная необходимость.\n\n#### Пример: интернет-магазин\n\nПредставим простое приложение — интернет-магазин. Без компонентов весь код может быть в одном файле: обработка заказов, работа с корзиной, отправка писем, оплата — всё перемешано.\n\nС компонентной архитектурой мы можем выделить:\n\n- `Корзина` — управляет товарами пользователя.\n- `Оформление заказа` — обрабатывает создание и подтверждение заказа.\n- `Платежная система` — отвечает за взаимодействие с платёжными шлюзами.\n- `Уведомления` — отправляет email и SMS.\n- `Аутентификация` — управляет входом и регистрацией пользователей.\n\nКаждый из этих компонентов может быть разработан независимо, протестирован отдельно и при необходимости заменён (например, сменить платёжный шлюз).\n\n#### Заключение\n\nКомпонентная архитектура — это не просто способ организовать код, а **мышление на уровне системы**. Она помогает строить приложения, которые масштабируемы, поддерживаемы и понятны. Главное — не стремиться разбивать всё на компоненты «ради компонентов», а делать это осознанно, исходя из реальных границ ответственности в предметной области.\n\n> **Ключевой принцип**: компонент должен быть настолько большим, чтобы решать одну задачу, и настолько малым, чтобы не решать больше одной.",
          ai_generated: true,
        },
        {
          content_type: "video",
          platform: "YouTube",
          title:
            "Component Architecture Explained - What is Component-Based Architecture?",
          url: "https://www.youtube.com/watch?v=4b35M3hZ1lk",
          discussion_questions: [
            "Какие компоненты выделяются в примере из видео?",
            "Почему важно разделять ответственность между компонентами?",
            "Как компонентная архитектура помогает при масштабировании приложения?",
          ],
          duration_seconds: 287,
          key_moments: [],
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            "### Что такое компонент?\n\nКомпонент — это ключевой строительный блок современных программных систем. Он представляет собой **автономную, переиспользуемую часть приложения**, которая обладает чётко определённой ответственностью и взаимодействует с другими частями системы через стандартизированные интерфейсы.\n\n#### Основные характеристики компонента\n\n1. **Чёткая ответственность (Single Responsibility)**\n   Каждый компонент отвечает за одну конкретную задачу или область функциональности. Это упрощает понимание, разработку и тестирование.\n   \n   Пример: компонент `Сервис аутентификации` отвечает только за вход, регистрацию и проверку прав пользователей.\n\n2. **Инкапсуляция (Encapsulation)**\n   Внутренняя реализация компонента скрыта от остальной системы. Внешние модули взаимодействуют с ним только через публичные интерфейсы (API, методы, события).\n\n3. **Независимость (Independence)**\n   Компонент может быть разработан, протестирован, развернут и обновлён независимо от других компонентов, при условии, что интерфейсы остаются неизменными.\n\n4. **Переиспользуемость (Reusability)**\n   Хорошо спроектированный компонент можно использовать в разных частях системы или даже в других проектах.\n\n5. **Заменяемость (Replaceability)**\n   Компонент можно заменить на другой с той же функциональностью и интерфейсом без изменения остальной системы (например, замена SQLite на PostgreSQL в `Хранилище данных`).\n\n#### Примеры компонентов в приложении\n\n| Компонент | Ответственность |\n|----------|----------------|\n| `UI` | Отображение интерфейса, обработка ввода пользователя |\n| `Сервис аутентификации` | Управление сессиями, проверка прав доступа |\n| `Хранилище данных` | Сохранение и извлечение данных из базы |\n| `Уведомления` | Отправка email, push-уведомлений |\n| `Логирование` | Запись событий приложения для отладки и анализа |\n\n#### Визуализация компонентной архитектуры\n\nНиже представлена диаграмма, показывающая взаимодействие компонентов в типичном веб-приложении:",
          ai_generated: true,
        },
        {
          content_type: "mermaid",
          title: "Пример компонентной архитектуры ToDo-приложения",
          mermaid_code:
            '```mermaid\n%%{init: {\'theme\': \'base\'}}%%\ngraph TD\n    A[UI] --> B[Business Logic]\n    B --> C[Storage]\n    C --> D[File System]\n\n    click A "UI Component"\n    click B "Business Logic Component"\n    click C "Storage Component"\n    click D "File System"\n\n    classDef component fill:#4C97AF,stroke:#333,stroke-width:2px;\n    class A,B,C,D component;\n```',
          explanation:
            "Диаграмма компонентов показывает высокоуровневую структуру ToDo-приложения. Каждый компонент имеет чёткую ответственность: UI — за интерфейс, Business Logic — за логику задач, Storage — за доступ к данным, а File System — за физическое хранение. Стрелки отражают зависимости между компонентами. Такой подход помогает изолировать изменения и упрощает тестирование и поддержку кода.",
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            "### Связь компонентной архитектуры с MVC\n\nАрхитектурный паттерн **MVC (Model-View-Controller)** — один из фундаментальных подходов к проектированию приложений, особенно в контексте пользовательских интерфейсов. Он разделяет приложение на три взаимосвязанные компонента:\n\n- **Model** — отвечает за данные, бизнес-логику и работу с хранилищами.\n- **View** — отображает данные (представление), взаимодействует с пользователем.\n- **Controller** — обрабатывает пользовательский ввод, координирует взаимодействие между Model и View.\n\nОднако MVC традиционно применяется на **уровне модуля или экрана** — например, для одной формы ввода или страницы приложения. Компонентная архитектура поднимает уровень абстракции, позволяя строить систему из **независимых, переиспользуемых компонентов**, каждый из которых может сам содержать свою внутреннюю MVC-структуру.\n\n#### Как соотносятся MVC и компонентная архитектура?\n\n| MVC-элемент       | Роль в компонентной архитектуре |\n|--------------------|----------------------------------|\n| **View**           | Часть компонента **UI** — отвечает за отображение и визуальное поведение. |\n| **Controller**     | Может быть частью **Business Logic** или выделен в отдельный компонент для управления потоком данных. |\n| **Model**          | Часто инкапсулируется в компоненты **Storage** или **Business Logic**, в зависимости от сложности данных. |\n\nТаким образом, **компонентная архитектура не отменяет MVC, а обобщает его**: каждый компонент может представлять собой мини-MVC, объединённый по функциональному признаку. Например:\n\n- Компонент `Профиль пользователя` может включать:\n  - Свою **View** (UI-представление профиля),\n  - **Controller** (обработка редактирования),\n  - **Model** (данные пользователя и валидация),\n  — и при этом быть независимым от компонента `Настройки уведомлений`.\n\n#### Визуализация взаимосвязи",
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            "### Примеры архитектур в типичных приложениях\n\nПонимание компонентной архитектуры становится значительно проще, когда мы рассматриваем реальные примеры приложений. Компоненты — это логически завершённые части системы, которые отвечают за определённый аспект функциональности. Давайте разберём, как такие компоненты выглядят в двух распространённых типах приложений: интернет-магазине и чат-приложении.",
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            '# ToDo приложение на FastAPI с компонентной архитектурой\n\n### Структура проекта\n\n```text\ntodo_app/\n├── main.py\n├── api/\n│   ├── __init__.py\n│   ├── dependencies.py\n│   └── routes/\n│       ├── __init__.py\n│       ├── todos.py\n│       └── health.py\n├── core/\n│   ├── __init__.py\n│   ├── config.py\n│   └── database.py\n├── domain/\n│   ├── __init__.py\n│   ├── models.py\n│   ├── schemas.py\n│   └── repositories/\n│       ├── __init__.py\n│       └── todo_repository.py\n├── services/\n│   ├── __init__.py\n│   └── todo_service.py\n└── tests/\n    ├── __init__.py\n    └── test_todos.py\n```\n\n## 1. Основной файл приложения\n`main.py`:\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom api.routes import todos, health\nfrom core.config import settings\n\n# Создание экземпляра FastAPI приложения\napp = FastAPI(\n    title=settings.APP_TITLE,\n    version=settings.APP_VERSION,\n    description=settings.APP_DESCRIPTION\n)\n\n# Настройка CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.ALLOWED_ORIGINS,\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Подключение маршрутов\napp.include_router(health.router, tags=["Health"])\napp.include_router(todos.router, prefix="/api/v1/todos", tags=["Todos"])\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(\n        "main:app",\n        host=settings.HOST,\n        port=settings.PORT,\n        reload=settings.DEBUG\n    )\n```\n\n**Пояснение**: Точка входа в приложение, настройка CORS и подключение маршрутов.\n\n## 2. Конфигурация\n`core/config.py`:\n\n```python\nfrom pydantic_settings import BaseSettings\nfrom typing import List\n\nclass Settings(BaseSettings):\n    # Основные настройки приложения\n    APP_TITLE: str = "ToDo API"\n    APP_VERSION: str = "1.0.0"\n    APP_DESCRIPTION: str = "Простое ToDo приложение на FastAPI"\n    \n    # Настройки сервера\n    HOST: str = "0.0.0.0"\n    PORT: int = 8000\n    DEBUG: bool = True\n    \n    # Настройки CORS\n    ALLOWED_ORIGINS: List[str] = ["http://localhost:3000", "http://127.0.0.1:3000"]\n    \n    # Настройки базы данных (в реальном приложении - реальная БД)\n    DATABASE_URL: str = "sqlite:///./todos.db"\n    \n    class Config:\n        env_file = ".env"\n\n# Создаем экземпляр настроек\nsettings = Settings()\n```\n\n**Пояснение**: Централизованное управление конфигурацией с использованием Pydantic.\n\n## 3. Модели данных и схемы\n`domain/models.py`:\n\n```python\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\n\n# Базовые модели Pydantic для валидации данных\n\nclass TodoBase(BaseModel):\n    """Базовая модель задачи"""\n    title: str = Field(..., min_length=1, max_length=100, description="Название задачи")\n    description: Optional[str] = Field(None, max_length=500, description="Описание задачи")\n    completed: bool = Field(default=False, description="Статус выполнения")\n\nclass TodoCreate(TodoBase):\n    """Модель для создания задачи"""\n    pass\n\nclass TodoUpdate(BaseModel):\n    """Модель для обновления задачи"""\n    title: Optional[str] = Field(None, min_length=1, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n    completed: Optional[bool] = None\n\nclass TodoInDB(TodoBase):\n    """Модель задачи в БД"""\n    id: int = Field(..., description="Уникальный идентификатор")\n    created_at: datetime = Field(default_factory=datetime.now, description="Дата создания")\n    updated_at: datetime = Field(default_factory=datetime.now, description="Дата обновления")\n    \n    class Config:\n        from_attributes = True\n```\n\n**Пояснение**: Модели Pydantic для валидации входных/выходных данных и сериализации.\n\n## 4. Репозиторий для работы с данными\n`domain/repositories/todo_repository.py`:\n\n```python\nfrom typing import List, Optional, Dict\nfrom domain.models import TodoInDB, TodoCreate, TodoUpdate\nfrom datetime import datetime\n\nclass TodoRepository:\n    """\n    Репозиторий для работы с задачами.\n    В реальном приложении здесь будет работа с реальной БД.\n    """\n    \n    def __init__(self):\n        # Имитация базы данных в памяти\n        self._todos: Dict[int, TodoInDB] = {}\n        self._counter = 1\n    \n    async def get_all(self, skip: int = 0, limit: int = 100) -> List[TodoInDB]:\n        """Получить все задачи с пагинацией"""\n        todos = list(self._todos.values())\n        return todos[skip:skip + limit]\n    \n    async def get_by_id(self, todo_id: int) -> Optional[TodoInDB]:\n        """Получить задачу по ID"""\n        return self._todos.get(todo_id)\n    \n    async def create(self, todo: TodoCreate) -> TodoInDB:\n        """Создать новую задачу"""\n        todo_dict = todo.model_dump()\n        todo_dict["id"] = self._counter\n        todo_dict["created_at"] = datetime.now()\n        todo_dict["updated_at"] = datetime.now()\n        \n        todo_in_db = TodoInDB(**todo_dict)\n        self._todos[self._counter] = todo_in_db\n        self._counter += 1\n        \n        return todo_in_db\n    \n    async def update(self, todo_id: int, todo_update: TodoUpdate) -> Optional[TodoInDB]:\n        """Обновить существующую задачу"""\n        todo = self._todos.get(todo_id)\n        if not todo:\n            return None\n        \n        update_data = todo_update.model_dump(exclude_unset=True)\n        updated_todo = todo.model_copy(update=update_data)\n        updated_todo.updated_at = datetime.now()\n        \n        self._todos[todo_id] = updated_todo\n        return updated_todo\n    \n    async def delete(self, todo_id: int) -> bool:\n        """Удалить задачу"""\n        if todo_id in self._todos:\n            del self._todos[todo_id]\n            return True\n        return False\n    \n    async def count(self) -> int:\n        """Получить общее количество задач"""\n        return len(self._todos)\n\n# Создаем экземпляр репозитория (в реальном приложении через dependency injection)\ntodo_repository = TodoRepository()\n```\n\n**Пояснение**: Паттерн Repository для абстрагирования доступа к данным.\n\n## 5. Сервисный слой\n`services/todo_service.py`:\n\n```python\nfrom typing import List, Optional\nfrom domain.models import TodoInDB, TodoCreate, TodoUpdate\nfrom domain.repositories.todo_repository import todo_repository\n\nclass TodoService:\n    """\n    Сервисный слой для бизнес-логики задач.\n    Отделяет бизнес-логику от работы с данными.\n    """\n    \n    def __init__(self, repository = todo_repository):\n        self.repository = repository\n    \n    async def get_todos(\n        self, \n        skip: int = 0, \n        limit: int = 100,\n        completed: Optional[bool] = None\n    ) -> List[TodoInDB]:\n        """Получить список задач с фильтрацией и пагинацией"""\n        todos = await self.repository.get_all(skip=skip, limit=limit)\n        \n        if completed is not None:\n            todos = [todo for todo in todos if todo.completed == completed]\n        \n        return todos\n    \n    async def get_todo_by_id(self, todo_id: int) -> Optional[TodoInDB]:\n        """Получить задачу по ID"""\n        return await self.repository.get_by_id(todo_id)\n    \n    async def create_todo(self, todo_create: TodoCreate) -> TodoInDB:\n        """Создать новую задачу"""\n        # Можно добавить дополнительную бизнес-логику здесь\n        if len(todo_create.title.strip()) == 0:\n            raise ValueError("Название задачи не может быть пустым")\n        \n        return await self.repository.create(todo_create)\n    \n    async def update_todo(\n        self, \n        todo_id: int, \n        todo_update: TodoUpdate\n    ) -> Optional[TodoInDB]:\n        """Обновить задачу"""\n        # Проверка существования задачи\n        existing_todo = await self.repository.get_by_id(todo_id)\n        if not existing_todo:\n            return None\n        \n        # Бизнес-логика: если задача завершена, можно запретить изменение\n        if existing_todo.completed and todo_update.title is not None:\n            raise ValueError("Нельзя изменить название завершенной задачи")\n        \n        return await self.repository.update(todo_id, todo_update)\n    \n    async def delete_todo(self, todo_id: int) -> bool:\n        """Удалить задачу"""\n        return await self.repository.delete(todo_id)\n    \n    async def get_todos_count(self) -> int:\n        """Получить количество задач"""\n        return await self.repository.count()\n\n# Создаем экземпляр сервиса\ntodo_service = TodoService()\n```\n\n**Пояснение**: Сервисный слой содержит бизнес-логику и отделяет её от слоя доступа к данным.\n\n## 6. Зависимости\n`api/dependencies.py`:\n\n```python\nfrom typing import Generator\nfrom services.todo_service import todo_service\n\ndef get_todo_service() -> Generator:\n    """\n    Dependency injection для TodoService.\n    В реальном приложении здесь может быть управление сессиями БД.\n    """\n    try:\n        yield todo_service\n    finally:\n        # Здесь можно закрывать соединения с БД\n        pass\n```\n\n**Пояснение**: Dependency injection для внедрения зависимостей в маршруты.\n\n## 7. Маршруты (API endpoints)\n`api/routes/todos.py`:\n\n```python\nfrom typing import List, Optional\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom domain.models import TodoInDB, TodoCreate, TodoUpdate\nfrom services.todo_service import TodoService\nfrom api.dependencies import get_todo_service\n\nrouter = APIRouter()\n\n@router.get("/", response_model=List[TodoInDB])\nasync def read_todos(\n    skip: int = Query(0, ge=0, description="Количество пропускаемых записей"),\n    limit: int = Query(100, ge=1, le=1000, description="Лимит записей"),\n    completed: Optional[bool] = Query(None, description="Фильтр по статусу выполнения"),\n    service: TodoService = Depends(get_todo_service)\n) -> List[TodoInDB]:\n    """\n    Получить список всех задач.\n    \n    - **skip**: количество пропускаемых записей (для пагинации)\n    - **limit**: максимальное количество возвращаемых записей\n    - **completed**: фильтр по статусу выполнения (true/false)\n    """\n    return await service.get_todos(skip=skip, limit=limit, completed=completed)\n\n@router.get("/{todo_id}", response_model=TodoInDB)\nasync def read_todo(\n    todo_id: int,\n    service: TodoService = Depends(get_todo_service)\n) -> TodoInDB:\n    """\n    Получить задачу по ID.\n    \n    - **todo_id**: уникальный идентификатор задачи\n    """\n    todo = await service.get_todo_by_id(todo_id)\n    if todo is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"Задача с ID {todo_id} не найдена"\n        )\n    return todo\n\n@router.post("/", response_model=TodoInDB, status_code=status.HTTP_201_CREATED)\nasync def create_todo(\n    todo: TodoCreate,\n    service: TodoService = Depends(get_todo_service)\n) -> TodoInDB:\n    """\n    Создать новую задачу.\n    \n    - **title**: название задачи (обязательное поле)\n    - **description**: описание задачи (опционально)\n    - **completed**: статус выполнения (по умолчанию false)\n    """\n    try:\n        return await service.create_todo(todo)\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e)\n        )\n\n@router.put("/{todo_id}", response_model=TodoInDB)\nasync def update_todo(\n    todo_id: int,\n    todo_update: TodoUpdate,\n    service: TodoService = Depends(get_todo_service)\n) -> TodoInDB:\n    """\n    Обновить существующую задачу.\n    \n    - **todo_id**: уникальный идентификатор задачи\n    - Можно обновить любые поля (title, description, completed)\n    """\n    try:\n        updated_todo = await service.update_todo(todo_id, todo_update)\n        if updated_todo is None:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f"Задача с ID {todo_id} не найдена"\n            )\n        return updated_todo\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e)\n        )\n\n@router.delete("/{todo_id}", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo(\n    todo_id: int,\n    service: TodoService = Depends(get_todo_service)\n) -> None:\n    """\n    Удалить задачу.\n    \n    - **todo_id**: уникальный идентификатор задачи для удаления\n    """\n    success = await service.delete_todo(todo_id)\n    if not success:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"Задача с ID {todo_id} не найдена"\n        )\n\n@router.get("/stats/count", response_model=dict)\nasync def get_todos_count(\n    service: TodoService = Depends(get_todo_service)\n) -> dict:\n    """\n    Получить статистику по задачам.\n    \n    Возвращает общее количество задач.\n    """\n    count = await service.get_todos_count()\n    return {"total_todos": count}\n```\n\n`api/routes/health.py`:\n\n```python\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n@router.get("/health")\nasync def health_check() -> dict:\n    """\n    Проверка работоспособности API.\n    """\n    return {"status": "healthy", "service": "todo-api"}\n```\n\n**Пояснение**: Маршруты API с обработкой запросов и ошибок.\n\n## 8. Запуск приложения\nТребования (`requirements.txt`):\n\n```text\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\npydantic==2.5.0\npydantic-settings==2.1.0\n```\n\n**Запуск**:\n\n```bash\n# Установка зависимостей\npip install -r requirements.txt\n\n# Запуск сервера\npython main.py\n\n# Или через uvicorn напрямую\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n```\n\n## 9. Примеры запросов\n**Создание задачи**:\n```bash\ncurl -X POST "http://localhost:8000/api/v1/todos/" \\\n  -H "Content-Type: application/json" \\\n  -d \'{"title": "Купить молоко", "description": "1 литр"}\'\n```\n\n**Получение всех задач**:\n```bash\ncurl "http://localhost:8000/api/v1/todos/"\n```\n\n**Обновление задачи**:\n```bash\ncurl -X PUT "http://localhost:8000/api/v1/todos/1" \\\n  -H "Content-Type: application/json" \\\n  -d \'{"completed": true}\'\n```\n\n## Преимущества компонентной архитектуры:\n 1. **Разделение ответственности**: Каждый компонент отвечает за свою часть функциональности\n 2. **Тестируемость**: Компоненты можно тестировать независимо друг от друга\n 3. **Масштабируемость**: Легко добавлять новые функции и изменять существующие\n 4. **Поддержка кода**: Четкая структура облегчает понимание и поддержку кода\n 5. **Переиспользование**: Компоненты можно использовать в других проектах\n\n## Тестирование\n`tests/test_todos.py`:\n\n```python\nfrom fastapi.testclient import TestClient\nfrom main import app\n\nclient = TestClient(app)\n\ndef test_create_todo():\n    response = client.post("/api/v1/todos/", json={\n        "title": "Тестовая задача",\n        "description": "Описание тестовой задачи"\n    })\n    assert response.status_code == 201\n    data = response.json()\n    assert data["title"] == "Тестовая задача"\n    assert data["completed"] is False\n\ndef test_get_todos():\n    response = client.get("/api/v1/todos/")\n    assert response.status_code == 200\n    assert isinstance(response.json(), list)\n```\n\nЭтот пример демонстрирует чистую архитектуру с четким разделением слоев, что делает код поддерживаемым, тестируемым и масштабируемым.',
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            "Критерии хорошей компонентной архитектуры определяют, насколько гибкой, поддерживаемой и масштабируемой будет система. Они помогают оценить, достигнута ли цель разделения приложения на компоненты с чёткими границами и ответственностями. Рассмотрим ключевые проверки, которые позволяют определить качество архитектуры после рефакторинга.",
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            '### Избегание overengineering в компонентной архитектуре\n\nОдной из самых распространённых ошибок на начальном этапе проектирования программных систем является **overengineering** — чрезмерное усложнение архитектуры без реальной необходимости. Это проявляется в создании множества абстракций, интерфейсов, сервисов и компонентов «на будущее», которые либо никогда не будут использоваться, либо будут использоваться иначе, чем предполагалось изначально.\n\n#### Когда действительно нужно выделять компонент?\n\nКомпонент — это автономная часть системы с чётко определённой ответственностью и границами. Однако выделять компонент следует не по умолчанию, а только при наличии **реальных оснований**. Вот три ключевых критерия, которые помогут принять правильное решение:\n\n1. **Появляется реальная необходимость в изоляции**  \n   Если определённая функциональность требует независимого развёртывания, отдельного цикла тестирования или изолированного управления состоянием (например, из соображений безопасности или производительности), это веский повод выделить её в отдельный компонент.\n\n2. **Разные темпы изменений**  \n   Части системы развиваются с разной скоростью. Например, модуль обработки платежей может меняться редко и требовать высокой стабильности, в то время как модуль рекомендаций может обновляться ежедневно. В таком случае их логично разделить, чтобы изменения в одном не влияли на другой.\n\n3. **Работа разных команд**  \n   Если над разными частями системы работают отдельные команды, наличие чётких границ между компонентами позволяет командам работать автономно, минимизируя конфликты и необходимость согласования на каждом шагу.\n\n#### Пример из практики\n\nПредставим, что вы разрабатываете интернет-магазин. На раннем этапе может показаться разумным выделить отдельные компоненты для:\n- управления товарами\n- корзины\n- заказов\n- пользователей\n- уведомлений\n\nОднако если система небольшая, все эти функции могут эффективно работать в рамках одного модуля. Создание отдельных компонентов на старте приведёт к:\n- избыточной сложности\n- увеличению времени на разработку и отладку\n- трудностям в поддержке (например, необходимость запуска нескольких сервисов локально)\n\nГораздо разумнее начать с простой, но хорошо структурированной архитектуры, а компоненты выделять по мере роста системы и появления реальных потребностей.\n\n#### Простота — признак зрелости\n\nОпытный архитектор отличается не тем, насколько сложные системы он может построить, а тем, **насколько простыми он может их сделать**. Умение сопротивляться искушению «создать красивую абстракцию» ради будущего — важнейший навык.\n\n> **Цитата по теме:**\n> *"Лучшая архитектура — это та, которую не пришлось переосмысливать на третьей неделе разработки."*\n\n#### Визуализация: когда выделять компонент?\n\nНиже представлена диаграмма решений, помогающая определить, стоит ли выделять компонент:',
          ai_generated: true,
        },
        {
          content_type: "mermaid",
          title: "Диаграмма решений",
          mermaid_code:
            "```mermaid\ngraph TD\n    A[Нужно ли выделять компонент?] --> B{Проверка критериев}\n    \n    B --> C[Критерий 1:<br/>Необходимость в изоляции?]\n    C --> D{Да/Нет}\n    D -->|Да| E[✅ Выделить компонент]\n    D -->|Нет| F\n    \n    B --> G[Критерий 2:<br/>Разные темпы изменений?]\n    G --> H{Да/Нет}\n    H -->|Да| E\n    H -->|Нет| I\n    \n    B --> J[Критерий 3:<br/>Работа разных команд?]\n    J --> K{Да/Нет}\n    K -->|Да| E\n    K -->|Нет| L\n    \n    F[Продолжить с монолитом] --> M[\uD83D\uDCA1 Рекомендация:<br/>Начните с простой архитектуры<br/>и рефакторите позже по мере необходимости]\n    I --> M\n    L --> M\n    \n    E --> N[\uD83D\uDE80 Действие:<br/>Определите чёткие границы,<br/>интерфейсы и ответственность компонента]\n    \n    M --> O[⚠\uFE0F Предупреждение:<br/>Избегайте создания компонентов<br/>«на всякий случай» — это overengineering]\n    \n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style C fill:#fff3e0,stroke:#e65100\n    style G fill:#fff3e0,stroke:#e65100\n    style J fill:#fff3e0,stroke:#e65100\n    style E fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px\n    style M fill:#fffde7,stroke:#f57f17\n    style N fill:#f1f8e9,stroke:#33691e\n    style O fill:#ffebee,stroke:#c62828\n```",
          explanation:
            'Стартовый вопрос определяет необходимость архитектурного решения о выделении компонента.\n\nТри ключевых критерия проверяются последовательно: необходимость изоляции, разные темпы изменений и работа разных команд.\n\nПоложительное решение по любому из критериев ведет к выделению компонента с четким определением его границ.\n\nОтрицательные ответы по всем критериям рекомендуют сохранить монолитную архитектуру, избегая преждевременного усложнения.\n\nФинальные рекомендации предостерегают от создания компонентов "на будущее", что является классическим overengineering.',
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            "### Итоги модуля\n\nВы научились:\n- Видеть приложение как набор компонентов\n- Проводить границы модульности\n- Использовать диаграммы для визуализации архитектуры\n- Оценивать обоснованность архитектурных решений\n\nВ следующем модуле вы примените эти навыки к более сложным системам и начнёте принимать архитектурные решения на основе контекста.",
          ai_generated: true,
        },
        {
          content_type: "text",
          md_content:
            "### Дополнительные материалы\n\n#### Книга: «Clean Architecture» Роберт Мартин — главы 1–3\n\nКнига Роберта Мартина «Clean Architecture: Искусство разработки программного обеспечения» является одной из ключевых работ в области проектирования программных систем. В первых трёх главах автор раскрывает фундаментальные принципы архитектуры программного обеспечения:\n\n- **Глава 1: Архитектура — это важнее всего** — объясняет, почему архитектура не является просто технической деталью, а стратегическим активом. Подчёркивается, что хорошая архитектура обеспечивает гибкость, поддерживаемость и устойчивость системы к изменениям.\n- **Глава 2: Центральная цель** — раскрывает идею, что основная цель архитектуры — поддерживать жизнеспособность системы на протяжении всего её жизненного цикла. Это достигается за счёт независимости бизнес-логики от внешних факторов (например, баз данных, UI, фреймворков).\n- **Глава 3: Функциональная деградация** — рассматривает, как системы постепенно теряют свою целостность из-за накопления технического долга и отсутствия чётких границ между компонентами. Автор вводит понятие «грязной архитектуры» и показывает, как избежать её.\n\nЭти главы закладывают основу для понимания компонентной архитектуры и важности разделения ответственностей.\n\n#### Инструмент: C4 Model — официальный сайт\n\n[C4 Model](https://c4model.com/) — это простая, но мощная методология визуализации архитектуры программного обеспечения на разных уровнях детализации. Название C4 происходит от четырёх уровней представления (Context, Containers, Components, Code), что помогает командам эффективно коммуницировать по архитектурным вопросам.\n\n- **Контекст (Level 1)** — показывает систему в окружении: пользователи, внешние системы.\n- **Контейнеры (Level 2)** — разбивка системы на контейнеры (например, веб-приложение, база данных, микросервисы).\n- **Компоненты (Level 3)** — внутриконтейнерная структура: компоненты, их интерфейсы и зависимости.\n- **Код (Level 4)** — детализация на уровне классов (по необходимости).\n\nC4 Model особенно полезен на ранних этапах проектирования, когда важно быстро и понятно донести структуру системы до всех заинтересованных сторон.\n\n#### Статья: «How to Draw a Component Diagram»\n\nВыполняю поиск актуальной статьи по теме...",
          ai_generated: true,
        },
      ],
      assignment: {
        assignment_type: "test",
        title: "Тест по теме: Жизненный цикл программного обеспечения",
        max_score: 3,
        passing_score: 2,
        questions: [
          {
            text: "Опишите основные этапы жизненного цикла программного обеспечения (ЖЦ ПО) и кратко объясните, какая цель преследуется на каждом из них. Какие последствия могут быть, если пропустить один из этапов, например, этап тестирования?",
            options: [
              "Пропуск этапа тестирования не влияет на качество ПО, если разработчики опытные",
              "Пропуск тестирования может привести к выходу ПО с критическими ошибками, что повлияет на репутацию и безопасность",
              "Тестирование можно заменить этапом проектирования",
            ],
            correct_answers: [1],
            points: 1,
          },
          {
            text: "В чём принципиальное различие между программированием и инженерией программного обеспечения? Приведите пример, когда простое программирование может оказаться недостаточным, и объясните, почему в этом случае требуется именно инженерный подход.",
            options: [
              "Программирование — это написание кода, а инженерия ПО — только управление командой разработчиков",
              "Инженерия ПО включает в себя только тестирование и документирование, а программирование — это реализация",
              "Инженерия ПО — это системный подход, включающий планирование, анализ требований, проектирование, тестирование и сопровождение, тогда как программирование — лишь часть этого процесса",
            ],
            correct_answers: [2],
            points: 1,
          },
          {
            text: "Команда разработчиков получила от заказчика описание функциональности нового приложения для учёта рабочего времени. Сейчас они анализируют, какие именно данные нужно собирать, как пользователи будут взаимодействовать с системой, какие ограничения существуют (например, интеграция с существующими системами). На каком этапе жизненного цикла ПО находится проект? Обоснуйте свой ответ.",
            options: [
              "Этап программирования",
              "Этап сопровождения",
              "Этап анализа требований",
            ],
            correct_answers: [2],
            points: 1,
          },
        ],
        version: 0,
      },
    },
  ],
};

initApp(data);
