import { renderModule } from "../general/createModules.js";
import "../student/chat.js";
// const dataElement = document.getElementById("initial-data");
// const data = JSON.parse(dataElement.textContent);

const data = {
  content_blocks: [
    {
      content_type: "text",
      md_content:
        "### Введение: от кода к архитектуре\n\nВы уже умеете писать приложения — например, ToDo-лист с использованием MVC и Git. Но как перейти от «работающего кода» к «хорошей архитектуре»? В этом модуле вы начнёте видеть систему на уровне компонентов — крупных, логически завершённых частей приложения, каждая со своей зоной ответственности.\n\nКогда вы пишете код, ваше внимание сосредоточено на реализации конкретных функций: как добавить задачу, как сохранить её в базу данных, как отобразить на экране. Это важно, но на определённом этапе масштабирования приложения такой подход перестаёт быть эффективным. Возникают проблемы: трудности в поддержке, медленная интеграция новых функций, высокая связанность между частями кода.\n\nИменно здесь на помощь приходит **компонентная архитектура** — подход, при котором приложение разбивается на независимые, переиспользуемые компоненты, каждый из которых отвечает за определённую функциональность. Вместо того чтобы думать в терминах классов и функций, вы начинаете мыслить на уровне **модулей**, **сервисов** и **интерфейсов взаимодействия**.\n\n#### Почему компоненты?\n\nКомпонент — это автономная часть системы, которая:\n\n- Имеет чётко определённую **зону ответственности**;\n- Предоставляет **интерфейс** для взаимодействия с другими компонентами;\n- Минимизирует зависимости от других частей системы;\n- Может быть разработана, протестирована и развёрнута независимо (в идеале).\n\nТакой подход позволяет:\n\n- Упростить понимание и сопровождение кода;\n- Повысить переиспользуемость;\n- Ускорить разработку за счёт параллельной работы над разными компонентами;\n- Избежать «спагетти-кода» и технического долга.\n\n#### От излишнего проектирования к разумной структуре\n\nВажно понимать разницу между **архитектурой** и **overengineering** (чрезмерным усложнением). Хорошая архитектура не означает создание множества абстракций «на будущее». Она — результат осознанного разделения ответственностей *сейчас*, с учётом текущих и прогнозируемых потребностей.\n\nВ этом модуле вы научитесь:\n\n- Выделять компоненты в приложении;\n- Определять их границы и интерфейсы;\n- Проектировать взаимодействие между ними;\n- Избегать типичных ошибок при проектировании.\n\nЦель — не просто написать код, который работает, а создать систему, которую легко понимать, изменять и масштабировать.",
      ai_generated: true,
    },
    {
      content_type: "text",
      md_content:
        "### Почему компоненты?\n\nПо мере роста программного обеспечения его сложность увеличивается экспоненциально. Начиная с простых скриптов, разработчики рано или поздно сталкиваются с проблемой: код становится запутанным, трудно читаемым и практически невозможным для поддержки. Именно на этом этапе становится очевидной необходимость перехода от монолитной структуры к **компонентной архитектуре**.\n\n#### Проблемы монолитного кода\n\nМонолит — это подход, при котором всё приложение представляет собой единый блок кода, где классы, функции и модули тесно связаны между собой. На начальных этапах это удобно: быстро писать, легко запускать. Однако по мере роста приложения возникают следующие проблемы:\n\n- **Сложность поддержки**: изменение одной части кода может непредсказуемо повлиять на другую.\n- **Низкая тестируемость**: из-за сильной связанности сложно изолировать части системы для тестирования.\n- **Затруднённая командная разработка**: несколько разработчиков вынуждены работать в одних и тех же файлах, что ведёт к конфликтам слияния и ошибкам.\n- **Сложность повторного использования**: код нельзя легко перенести в другое приложение.\n- **Overengineering**: без чётких границ разработчики склонны добавлять избыточную абстракцию, усложняя архитектуру без реальной необходимости.\n\n#### Как компоненты решают эти проблемы\n\nКомпонент — это автономная часть системы, которая:\n\n- Имеет **чётко определённую ответственность**.\n- Взаимодействует с другими компонентами через **явные интерфейсы**.\n- Скрыт от внутренней реализации других компонентов (**инкапсуляция**).\n- Может быть разработан, протестирован и развиваться независимо.\n\nТакой подход позволяет:\n\n1. **Разделить ответственность**\n   Каждый компонент отвечает за свою зону: например, один — за аутентификацию, другой — за работу с базой данных, третий — за пользовательский интерфейс. Это упрощает понимание системы в целом.\n\n2. **Упростить тестирование**\n   Поскольку компоненты изолированы, их можно тестировать отдельно. Можно использовать моки и заглушки для зависимостей, что делает тесты быстрее и надёжнее.\n\n3. **Облегчить командную разработку**\n   Разные команды или разработчики могут работать над разными компонентами параллельно, не мешая друг другу. Главное — соблюдать контракты (интерфейсы) взаимодействия.\n\n4. **Избежать overengineering**\n   Компонентный подход заставляет задуматься: *«Что именно должен делать этот компонент?»* Это способствует осознанному проектированию. Вместо того чтобы создавать абстракции «на будущее», разработчик фокусируется на текущих задачах и выделяет компоненты только тогда, когда в этом есть реальная необходимость.\n\n#### Пример: интернет-магазин\n\nПредставим простое приложение — интернет-магазин. Без компонентов весь код может быть в одном файле: обработка заказов, работа с корзиной, отправка писем, оплата — всё перемешано.\n\nС компонентной архитектурой мы можем выделить:\n\n- `Корзина` — управляет товарами пользователя.\n- `Оформление заказа` — обрабатывает создание и подтверждение заказа.\n- `Платежная система` — отвечает за взаимодействие с платёжными шлюзами.\n- `Уведомления` — отправляет email и SMS.\n- `Аутентификация` — управляет входом и регистрацией пользователей.\n\nКаждый из этих компонентов может быть разработан независимо, протестирован отдельно и при необходимости заменён (например, сменить платёжный шлюз).\n\n#### Заключение\n\nКомпонентная архитектура — это не просто способ организовать код, а **мышление на уровне системы**. Она помогает строить приложения, которые масштабируемы, поддерживаемы и понятны. Главное — не стремиться разбивать всё на компоненты «ради компонентов», а делать это осознанно, исходя из реальных границ ответственности в предметной области.\n\n> **Ключевой принцип**: компонент должен быть настолько большим, чтобы решать одну задачу, и настолько малым, чтобы не решать больше одной.",
      ai_generated: true,
    },
    {
      content_type: "video",
      platform: "YouTube",
      title:
        "Component Architecture Explained - What is Component-Based Architecture?",
      url: "https://www.youtube.com/watch?v=4b35M3hZ1lk",
      discussion_questions: [
        "Какие компоненты выделяются в примере из видео?",
        "Почему важно разделять ответственность между компонентами?",
        "Как компонентная архитектура помогает при масштабировании приложения?",
      ],
      duration_seconds: 287,
      key_moments: [],
      ai_generated: true,
    },
    {
      content_type: "text",
      md_content:
        "### Что такое компонент?\n\nКомпонент — это ключевой строительный блок современных программных систем. Он представляет собой **автономную, переиспользуемую часть приложения**, которая обладает чётко определённой ответственностью и взаимодействует с другими частями системы через стандартизированные интерфейсы.\n\n#### Основные характеристики компонента\n\n1. **Чёткая ответственность (Single Responsibility)**\n   Каждый компонент отвечает за одну конкретную задачу или область функциональности. Это упрощает понимание, разработку и тестирование.\n   \n   Пример: компонент `Сервис аутентификации` отвечает только за вход, регистрацию и проверку прав пользователей.\n\n2. **Инкапсуляция (Encapsulation)**\n   Внутренняя реализация компонента скрыта от остальной системы. Внешние модули взаимодействуют с ним только через публичные интерфейсы (API, методы, события).\n\n3. **Независимость (Independence)**\n   Компонент может быть разработан, протестирован, развернут и обновлён независимо от других компонентов, при условии, что интерфейсы остаются неизменными.\n\n4. **Переиспользуемость (Reusability)**\n   Хорошо спроектированный компонент можно использовать в разных частях системы или даже в других проектах.\n\n5. **Заменяемость (Replaceability)**\n   Компонент можно заменить на другой с той же функциональностью и интерфейсом без изменения остальной системы (например, замена SQLite на PostgreSQL в `Хранилище данных`).\n\n#### Примеры компонентов в приложении\n\n| Компонент | Ответственность |\n|----------|----------------|\n| `UI` | Отображение интерфейса, обработка ввода пользователя |\n| `Сервис аутентификации` | Управление сессиями, проверка прав доступа |\n| `Хранилище данных` | Сохранение и извлечение данных из базы |\n| `Уведомления` | Отправка email, push-уведомлений |\n| `Логирование` | Запись событий приложения для отладки и анализа |\n\n#### Визуализация компонентной архитектуры\n\nНиже представлена диаграмма, показывающая взаимодействие компонентов в типичном веб-приложении:",
      ai_generated: true,
    },
    {
      content_type: "mermaid",
      title: "Пример компонентной архитектуры ToDo-приложения",
      mermaid_code:
        '```mermaid\n%%{init: {\'theme\': \'base\'}}%%\ngraph TD\n    A[UI] --> B[Business Logic]\n    B --> C[Storage]\n    C --> D[File System]\n\n    click A "UI Component"\n    click B "Business Logic Component"\n    click C "Storage Component"\n    click D "File System"\n\n    classDef component fill:#4C97AF,stroke:#333,stroke-width:2px;\n    class A,B,C,D component;\n```',
      explanation:
        "Диаграмма компонентов показывает высокоуровневую структуру ToDo-приложения. Каждый компонент имеет чёткую ответственность: UI — за интерфейс, Business Logic — за логику задач, Storage — за доступ к данным, а File System — за физическое хранение. Стрелки отражают зависимости между компонентами. Такой подход помогает изолировать изменения и упрощает тестирование и поддержку кода.",
      ai_generated: true,
    },
    {
      content_type: "text",
      md_content:
        "### Связь компонентной архитектуры с MVC\n\nАрхитектурный паттерн **MVC (Model-View-Controller)** — один из фундаментальных подходов к проектированию приложений, особенно в контексте пользовательских интерфейсов. Он разделяет приложение на три взаимосвязанные компонента:\n\n- **Model** — отвечает за данные, бизнес-логику и работу с хранилищами.\n- **View** — отображает данные (представление), взаимодействует с пользователем.\n- **Controller** — обрабатывает пользовательский ввод, координирует взаимодействие между Model и View.\n\nОднако MVC традиционно применяется на **уровне модуля или экрана** — например, для одной формы ввода или страницы приложения. Компонентная архитектура поднимает уровень абстракции, позволяя строить систему из **независимых, переиспользуемых компонентов**, каждый из которых может сам содержать свою внутреннюю MVC-структуру.\n\n#### Как соотносятся MVC и компонентная архитектура?\n\n| MVC-элемент       | Роль в компонентной архитектуре |\n|--------------------|----------------------------------|\n| **View**           | Часть компонента **UI** — отвечает за отображение и визуальное поведение. |\n| **Controller**     | Может быть частью **Business Logic** или выделен в отдельный компонент для управления потоком данных. |\n| **Model**          | Часто инкапсулируется в компоненты **Storage** или **Business Logic**, в зависимости от сложности данных. |\n\nТаким образом, **компонентная архитектура не отменяет MVC, а обобщает его**: каждый компонент может представлять собой мини-MVC, объединённый по функциональному признаку. Например:\n\n- Компонент `Профиль пользователя` может включать:\n  - Свою **View** (UI-представление профиля),\n  - **Controller** (обработка редактирования),\n  - **Model** (данные пользователя и валидация),\n  — и при этом быть независимым от компонента `Настройки уведомлений`.\n\n#### Визуализация взаимосвязи",
      ai_generated: true,
    },
    {
      content_type: "text",
      md_content:
        "### Примеры архитектур в типичных приложениях\n\nПонимание компонентной архитектуры становится значительно проще, когда мы рассматриваем реальные примеры приложений. Компоненты — это логически завершённые части системы, которые отвечают за определённый аспект функциональности. Давайте разберём, как такие компоненты выглядят в двух распространённых типах приложений: интернет-магазине и чат-приложении.",
      ai_generated: true,
    },
    {
      content_type: "text",
      md_content:
        '# ToDo приложение на FastAPI с компонентной архитектурой\n\n### Структура проекта\n\n```text\ntodo_app/\n├── main.py\n├── api/\n│   ├── __init__.py\n│   ├── dependencies.py\n│   └── routes/\n│       ├── __init__.py\n│       ├── todos.py\n│       └── health.py\n├── core/\n│   ├── __init__.py\n│   ├── config.py\n│   └── database.py\n├── domain/\n│   ├── __init__.py\n│   ├── models.py\n│   ├── schemas.py\n│   └── repositories/\n│       ├── __init__.py\n│       └── todo_repository.py\n├── services/\n│   ├── __init__.py\n│   └── todo_service.py\n└── tests/\n    ├── __init__.py\n    └── test_todos.py\n```\n\n## 1. Основной файл приложения\n`main.py`:\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom api.routes import todos, health\nfrom core.config import settings\n\n# Создание экземпляра FastAPI приложения\napp = FastAPI(\n    title=settings.APP_TITLE,\n    version=settings.APP_VERSION,\n    description=settings.APP_DESCRIPTION\n)\n\n# Настройка CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.ALLOWED_ORIGINS,\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Подключение маршрутов\napp.include_router(health.router, tags=["Health"])\napp.include_router(todos.router, prefix="/api/v1/todos", tags=["Todos"])\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(\n        "main:app",\n        host=settings.HOST,\n        port=settings.PORT,\n        reload=settings.DEBUG\n    )\n```\n\n**Пояснение**: Точка входа в приложение, настройка CORS и подключение маршрутов.\n\n## 2. Конфигурация\n`core/config.py`:\n\n```python\nfrom pydantic_settings import BaseSettings\nfrom typing import List\n\nclass Settings(BaseSettings):\n    # Основные настройки приложения\n    APP_TITLE: str = "ToDo API"\n    APP_VERSION: str = "1.0.0"\n    APP_DESCRIPTION: str = "Простое ToDo приложение на FastAPI"\n    \n    # Настройки сервера\n    HOST: str = "0.0.0.0"\n    PORT: int = 8000\n    DEBUG: bool = True\n    \n    # Настройки CORS\n    ALLOWED_ORIGINS: List[str] = ["http://localhost:3000", "http://127.0.0.1:3000"]\n    \n    # Настройки базы данных (в реальном приложении - реальная БД)\n    DATABASE_URL: str = "sqlite:///./todos.db"\n    \n    class Config:\n        env_file = ".env"\n\n# Создаем экземпляр настроек\nsettings = Settings()\n```\n\n**Пояснение**: Централизованное управление конфигурацией с использованием Pydantic.\n\n## 3. Модели данных и схемы\n`domain/models.py`:\n\n```python\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\n\n# Базовые модели Pydantic для валидации данных\n\nclass TodoBase(BaseModel):\n    """Базовая модель задачи"""\n    title: str = Field(..., min_length=1, max_length=100, description="Название задачи")\n    description: Optional[str] = Field(None, max_length=500, description="Описание задачи")\n    completed: bool = Field(default=False, description="Статус выполнения")\n\nclass TodoCreate(TodoBase):\n    """Модель для создания задачи"""\n    pass\n\nclass TodoUpdate(BaseModel):\n    """Модель для обновления задачи"""\n    title: Optional[str] = Field(None, min_length=1, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n    completed: Optional[bool] = None\n\nclass TodoInDB(TodoBase):\n    """Модель задачи в БД"""\n    id: int = Field(..., description="Уникальный идентификатор")\n    created_at: datetime = Field(default_factory=datetime.now, description="Дата создания")\n    updated_at: datetime = Field(default_factory=datetime.now, description="Дата обновления")\n    \n    class Config:\n        from_attributes = True\n```\n\n**Пояснение**: Модели Pydantic для валидации входных/выходных данных и сериализации.\n\n## 4. Репозиторий для работы с данными\n`domain/repositories/todo_repository.py`:\n\n```python\nfrom typing import List, Optional, Dict\nfrom domain.models import TodoInDB, TodoCreate, TodoUpdate\nfrom datetime import datetime\n\nclass TodoRepository:\n    """\n    Репозиторий для работы с задачами.\n    В реальном приложении здесь будет работа с реальной БД.\n    """\n    \n    def __init__(self):\n        # Имитация базы данных в памяти\n        self._todos: Dict[int, TodoInDB] = {}\n        self._counter = 1\n    \n    async def get_all(self, skip: int = 0, limit: int = 100) -> List[TodoInDB]:\n        """Получить все задачи с пагинацией"""\n        todos = list(self._todos.values())\n        return todos[skip:skip + limit]\n    \n    async def get_by_id(self, todo_id: int) -> Optional[TodoInDB]:\n        """Получить задачу по ID"""\n        return self._todos.get(todo_id)\n    \n    async def create(self, todo: TodoCreate) -> TodoInDB:\n        """Создать новую задачу"""\n        todo_dict = todo.model_dump()\n        todo_dict["id"] = self._counter\n        todo_dict["created_at"] = datetime.now()\n        todo_dict["updated_at"] = datetime.now()\n        \n        todo_in_db = TodoInDB(**todo_dict)\n        self._todos[self._counter] = todo_in_db\n        self._counter += 1\n        \n        return todo_in_db\n    \n    async def update(self, todo_id: int, todo_update: TodoUpdate) -> Optional[TodoInDB]:\n        """Обновить существующую задачу"""\n        todo = self._todos.get(todo_id)\n        if not todo:\n            return None\n        \n        update_data = todo_update.model_dump(exclude_unset=True)\n        updated_todo = todo.model_copy(update=update_data)\n        updated_todo.updated_at = datetime.now()\n        \n        self._todos[todo_id] = updated_todo\n        return updated_todo\n    \n    async def delete(self, todo_id: int) -> bool:\n        """Удалить задачу"""\n        if todo_id in self._todos:\n            del self._todos[todo_id]\n            return True\n        return False\n    \n    async def count(self) -> int:\n        """Получить общее количество задач"""\n        return len(self._todos)\n\n# Создаем экземпляр репозитория (в реальном приложении через dependency injection)\ntodo_repository = TodoRepository()\n```\n\n**Пояснение**: Паттерн Repository для абстрагирования доступа к данным.\n\n## 5. Сервисный слой\n`services/todo_service.py`:\n\n```python\nfrom typing import List, Optional\nfrom domain.models import TodoInDB, TodoCreate, TodoUpdate\nfrom domain.repositories.todo_repository import todo_repository\n\nclass TodoService:\n    """\n    Сервисный слой для бизнес-логики задач.\n    Отделяет бизнес-логику от работы с данными.\n    """\n    \n    def __init__(self, repository = todo_repository):\n        self.repository = repository\n    \n    async def get_todos(\n        self, \n        skip: int = 0, \n        limit: int = 100,\n        completed: Optional[bool] = None\n    ) -> List[TodoInDB]:\n        """Получить список задач с фильтрацией и пагинацией"""\n        todos = await self.repository.get_all(skip=skip, limit=limit)\n        \n        if completed is not None:\n            todos = [todo for todo in todos if todo.completed == completed]\n        \n        return todos\n    \n    async def get_todo_by_id(self, todo_id: int) -> Optional[TodoInDB]:\n        """Получить задачу по ID"""\n        return await self.repository.get_by_id(todo_id)\n    \n    async def create_todo(self, todo_create: TodoCreate) -> TodoInDB:\n        """Создать новую задачу"""\n        # Можно добавить дополнительную бизнес-логику здесь\n        if len(todo_create.title.strip()) == 0:\n            raise ValueError("Название задачи не может быть пустым")\n        \n        return await self.repository.create(todo_create)\n    \n    async def update_todo(\n        self, \n        todo_id: int, \n        todo_update: TodoUpdate\n    ) -> Optional[TodoInDB]:\n        """Обновить задачу"""\n        # Проверка существования задачи\n        existing_todo = await self.repository.get_by_id(todo_id)\n        if not existing_todo:\n            return None\n        \n        # Бизнес-логика: если задача завершена, можно запретить изменение\n        if existing_todo.completed and todo_update.title is not None:\n            raise ValueError("Нельзя изменить название завершенной задачи")\n        \n        return await self.repository.update(todo_id, todo_update)\n    \n    async def delete_todo(self, todo_id: int) -> bool:\n        """Удалить задачу"""\n        return await self.repository.delete(todo_id)\n    \n    async def get_todos_count(self) -> int:\n        """Получить количество задач"""\n        return await self.repository.count()\n\n# Создаем экземпляр сервиса\ntodo_service = TodoService()\n```\n\n**Пояснение**: Сервисный слой содержит бизнес-логику и отделяет её от слоя доступа к данным.\n\n## 6. Зависимости\n`api/dependencies.py`:\n\n```python\nfrom typing import Generator\nfrom services.todo_service import todo_service\n\ndef get_todo_service() -> Generator:\n    """\n    Dependency injection для TodoService.\n    В реальном приложении здесь может быть управление сессиями БД.\n    """\n    try:\n        yield todo_service\n    finally:\n        # Здесь можно закрывать соединения с БД\n        pass\n```\n\n**Пояснение**: Dependency injection для внедрения зависимостей в маршруты.\n\n## 7. Маршруты (API endpoints)\n`api/routes/todos.py`:\n\n```python\nfrom typing import List, Optional\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom domain.models import TodoInDB, TodoCreate, TodoUpdate\nfrom services.todo_service import TodoService\nfrom api.dependencies import get_todo_service\n\nrouter = APIRouter()\n\n@router.get("/", response_model=List[TodoInDB])\nasync def read_todos(\n    skip: int = Query(0, ge=0, description="Количество пропускаемых записей"),\n    limit: int = Query(100, ge=1, le=1000, description="Лимит записей"),\n    completed: Optional[bool] = Query(None, description="Фильтр по статусу выполнения"),\n    service: TodoService = Depends(get_todo_service)\n) -> List[TodoInDB]:\n    """\n    Получить список всех задач.\n    \n    - **skip**: количество пропускаемых записей (для пагинации)\n    - **limit**: максимальное количество возвращаемых записей\n    - **completed**: фильтр по статусу выполнения (true/false)\n    """\n    return await service.get_todos(skip=skip, limit=limit, completed=completed)\n\n@router.get("/{todo_id}", response_model=TodoInDB)\nasync def read_todo(\n    todo_id: int,\n    service: TodoService = Depends(get_todo_service)\n) -> TodoInDB:\n    """\n    Получить задачу по ID.\n    \n    - **todo_id**: уникальный идентификатор задачи\n    """\n    todo = await service.get_todo_by_id(todo_id)\n    if todo is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"Задача с ID {todo_id} не найдена"\n        )\n    return todo\n\n@router.post("/", response_model=TodoInDB, status_code=status.HTTP_201_CREATED)\nasync def create_todo(\n    todo: TodoCreate,\n    service: TodoService = Depends(get_todo_service)\n) -> TodoInDB:\n    """\n    Создать новую задачу.\n    \n    - **title**: название задачи (обязательное поле)\n    - **description**: описание задачи (опционально)\n    - **completed**: статус выполнения (по умолчанию false)\n    """\n    try:\n        return await service.create_todo(todo)\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e)\n        )\n\n@router.put("/{todo_id}", response_model=TodoInDB)\nasync def update_todo(\n    todo_id: int,\n    todo_update: TodoUpdate,\n    service: TodoService = Depends(get_todo_service)\n) -> TodoInDB:\n    """\n    Обновить существующую задачу.\n    \n    - **todo_id**: уникальный идентификатор задачи\n    - Можно обновить любые поля (title, description, completed)\n    """\n    try:\n        updated_todo = await service.update_todo(todo_id, todo_update)\n        if updated_todo is None:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f"Задача с ID {todo_id} не найдена"\n            )\n        return updated_todo\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e)\n        )\n\n@router.delete("/{todo_id}", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo(\n    todo_id: int,\n    service: TodoService = Depends(get_todo_service)\n) -> None:\n    """\n    Удалить задачу.\n    \n    - **todo_id**: уникальный идентификатор задачи для удаления\n    """\n    success = await service.delete_todo(todo_id)\n    if not success:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"Задача с ID {todo_id} не найдена"\n        )\n\n@router.get("/stats/count", response_model=dict)\nasync def get_todos_count(\n    service: TodoService = Depends(get_todo_service)\n) -> dict:\n    """\n    Получить статистику по задачам.\n    \n    Возвращает общее количество задач.\n    """\n    count = await service.get_todos_count()\n    return {"total_todos": count}\n```\n\n`api/routes/health.py`:\n\n```python\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n@router.get("/health")\nasync def health_check() -> dict:\n    """\n    Проверка работоспособности API.\n    """\n    return {"status": "healthy", "service": "todo-api"}\n```\n\n**Пояснение**: Маршруты API с обработкой запросов и ошибок.\n\n## 8. Запуск приложения\nТребования (`requirements.txt`):\n\n```text\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\npydantic==2.5.0\npydantic-settings==2.1.0\n```\n\n**Запуск**:\n\n```bash\n# Установка зависимостей\npip install -r requirements.txt\n\n# Запуск сервера\npython main.py\n\n# Или через uvicorn напрямую\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n```\n\n## 9. Примеры запросов\n**Создание задачи**:\n```bash\ncurl -X POST "http://localhost:8000/api/v1/todos/" \\\n  -H "Content-Type: application/json" \\\n  -d \'{"title": "Купить молоко", "description": "1 литр"}\'\n```\n\n**Получение всех задач**:\n```bash\ncurl "http://localhost:8000/api/v1/todos/"\n```\n\n**Обновление задачи**:\n```bash\ncurl -X PUT "http://localhost:8000/api/v1/todos/1" \\\n  -H "Content-Type: application/json" \\\n  -d \'{"completed": true}\'\n```\n\n## Преимущества компонентной архитектуры:\n 1. **Разделение ответственности**: Каждый компонент отвечает за свою часть функциональности\n 2. **Тестируемость**: Компоненты можно тестировать независимо друг от друга\n 3. **Масштабируемость**: Легко добавлять новые функции и изменять существующие\n 4. **Поддержка кода**: Четкая структура облегчает понимание и поддержку кода\n 5. **Переиспользование**: Компоненты можно использовать в других проектах\n\n## Тестирование\n`tests/test_todos.py`:\n\n```python\nfrom fastapi.testclient import TestClient\nfrom main import app\n\nclient = TestClient(app)\n\ndef test_create_todo():\n    response = client.post("/api/v1/todos/", json={\n        "title": "Тестовая задача",\n        "description": "Описание тестовой задачи"\n    })\n    assert response.status_code == 201\n    data = response.json()\n    assert data["title"] == "Тестовая задача"\n    assert data["completed"] is False\n\ndef test_get_todos():\n    response = client.get("/api/v1/todos/")\n    assert response.status_code == 200\n    assert isinstance(response.json(), list)\n```\n\nЭтот пример демонстрирует чистую архитектуру с четким разделением слоев, что делает код поддерживаемым, тестируемым и масштабируемым.',
      ai_generated: true,
    },
    {
      content_type: "text",
      md_content:
        "Критерии хорошей компонентной архитектуры определяют, насколько гибкой, поддерживаемой и масштабируемой будет система. Они помогают оценить, достигнута ли цель разделения приложения на компоненты с чёткими границами и ответственностями. Рассмотрим ключевые проверки, которые позволяют определить качество архитектуры после рефакторинга.",
      ai_generated: true,
    },
    {
      content_type: "text",
      md_content:
        '### Избегание overengineering в компонентной архитектуре\n\nОдной из самых распространённых ошибок на начальном этапе проектирования программных систем является **overengineering** — чрезмерное усложнение архитектуры без реальной необходимости. Это проявляется в создании множества абстракций, интерфейсов, сервисов и компонентов «на будущее», которые либо никогда не будут использоваться, либо будут использоваться иначе, чем предполагалось изначально.\n\n#### Когда действительно нужно выделять компонент?\n\nКомпонент — это автономная часть системы с чётко определённой ответственностью и границами. Однако выделять компонент следует не по умолчанию, а только при наличии **реальных оснований**. Вот три ключевых критерия, которые помогут принять правильное решение:\n\n1. **Появляется реальная необходимость в изоляции**  \n   Если определённая функциональность требует независимого развёртывания, отдельного цикла тестирования или изолированного управления состоянием (например, из соображений безопасности или производительности), это веский повод выделить её в отдельный компонент.\n\n2. **Разные темпы изменений**  \n   Части системы развиваются с разной скоростью. Например, модуль обработки платежей может меняться редко и требовать высокой стабильности, в то время как модуль рекомендаций может обновляться ежедневно. В таком случае их логично разделить, чтобы изменения в одном не влияли на другой.\n\n3. **Работа разных команд**  \n   Если над разными частями системы работают отдельные команды, наличие чётких границ между компонентами позволяет командам работать автономно, минимизируя конфликты и необходимость согласования на каждом шагу.\n\n#### Пример из практики\n\nПредставим, что вы разрабатываете интернет-магазин. На раннем этапе может показаться разумным выделить отдельные компоненты для:\n- управления товарами\n- корзины\n- заказов\n- пользователей\n- уведомлений\n\nОднако если система небольшая, все эти функции могут эффективно работать в рамках одного модуля. Создание отдельных компонентов на старте приведёт к:\n- избыточной сложности\n- увеличению времени на разработку и отладку\n- трудностям в поддержке (например, необходимость запуска нескольких сервисов локально)\n\nГораздо разумнее начать с простой, но хорошо структурированной архитектуры, а компоненты выделять по мере роста системы и появления реальных потребностей.\n\n#### Простота — признак зрелости\n\nОпытный архитектор отличается не тем, насколько сложные системы он может построить, а тем, **насколько простыми он может их сделать**. Умение сопротивляться искушению «создать красивую абстракцию» ради будущего — важнейший навык.\n\n> **Цитата по теме:**\n> *"Лучшая архитектура — это та, которую не пришлось переосмысливать на третьей неделе разработки."*\n\n#### Визуализация: когда выделять компонент?\n\nНиже представлена диаграмма решений, помогающая определить, стоит ли выделять компонент:',
      ai_generated: true,
    },
    {
      content_type: "mermaid",
      title: "Диаграмма решений",
      mermaid_code:
        "```mermaid\ngraph TD\n    A[Нужно ли выделять компонент?] --> B{Проверка критериев}\n    \n    B --> C[Критерий 1:<br/>Необходимость в изоляции?]\n    C --> D{Да/Нет}\n    D -->|Да| E[✅ Выделить компонент]\n    D -->|Нет| F\n    \n    B --> G[Критерий 2:<br/>Разные темпы изменений?]\n    G --> H{Да/Нет}\n    H -->|Да| E\n    H -->|Нет| I\n    \n    B --> J[Критерий 3:<br/>Работа разных команд?]\n    J --> K{Да/Нет}\n    K -->|Да| E\n    K -->|Нет| L\n    \n    F[Продолжить с монолитом] --> M[\uD83D\uDCA1 Рекомендация:<br/>Начните с простой архитектуры<br/>и рефакторите позже по мере необходимости]\n    I --> M\n    L --> M\n    \n    E --> N[\uD83D\uDE80 Действие:<br/>Определите чёткие границы,<br/>интерфейсы и ответственность компонента]\n    \n    M --> O[⚠\uFE0F Предупреждение:<br/>Избегайте создания компонентов<br/>«на всякий случай» — это overengineering]\n    \n    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style B fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style C fill:#fff3e0,stroke:#e65100\n    style G fill:#fff3e0,stroke:#e65100\n    style J fill:#fff3e0,stroke:#e65100\n    style E fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px\n    style M fill:#fffde7,stroke:#f57f17\n    style N fill:#f1f8e9,stroke:#33691e\n    style O fill:#ffebee,stroke:#c62828\n```",
      explanation:
        'Стартовый вопрос определяет необходимость архитектурного решения о выделении компонента.\n\nТри ключевых критерия проверяются последовательно: необходимость изоляции, разные темпы изменений и работа разных команд.\n\nПоложительное решение по любому из критериев ведет к выделению компонента с четким определением его границ.\n\nОтрицательные ответы по всем критериям рекомендуют сохранить монолитную архитектуру, избегая преждевременного усложнения.\n\nФинальные рекомендации предостерегают от создания компонентов "на будущее", что является классическим overengineering.',
      ai_generated: true,
    },
    {
      content_type: "text",
      md_content:
        "### Итоги модуля\n\nВы научились:\n- Видеть приложение как набор компонентов\n- Проводить границы модульности\n- Использовать диаграммы для визуализации архитектуры\n- Оценивать обоснованность архитектурных решений\n\nВ следующем модуле вы примените эти навыки к более сложным системам и начнёте принимать архитектурные решения на основе контекста.",
      ai_generated: true,
    },
    {
      content_type: "text",
      md_content:
        "### Дополнительные материалы\n\n#### Книга: «Clean Architecture» Роберт Мартин — главы 1–3\n\nКнига Роберта Мартина «Clean Architecture: Искусство разработки программного обеспечения» является одной из ключевых работ в области проектирования программных систем. В первых трёх главах автор раскрывает фундаментальные принципы архитектуры программного обеспечения:\n\n- **Глава 1: Архитектура — это важнее всего** — объясняет, почему архитектура не является просто технической деталью, а стратегическим активом. Подчёркивается, что хорошая архитектура обеспечивает гибкость, поддерживаемость и устойчивость системы к изменениям.\n- **Глава 2: Центральная цель** — раскрывает идею, что основная цель архитектуры — поддерживать жизнеспособность системы на протяжении всего её жизненного цикла. Это достигается за счёт независимости бизнес-логики от внешних факторов (например, баз данных, UI, фреймворков).\n- **Глава 3: Функциональная деградация** — рассматривает, как системы постепенно теряют свою целостность из-за накопления технического долга и отсутствия чётких границ между компонентами. Автор вводит понятие «грязной архитектуры» и показывает, как избежать её.\n\nЭти главы закладывают основу для понимания компонентной архитектуры и важности разделения ответственностей.\n\n#### Инструмент: C4 Model — официальный сайт\n\n[C4 Model](https://c4model.com/) — это простая, но мощная методология визуализации архитектуры программного обеспечения на разных уровнях детализации. Название C4 происходит от четырёх уровней представления (Context, Containers, Components, Code), что помогает командам эффективно коммуницировать по архитектурным вопросам.\n\n- **Контекст (Level 1)** — показывает систему в окружении: пользователи, внешние системы.\n- **Контейнеры (Level 2)** — разбивка системы на контейнеры (например, веб-приложение, база данных, микросервисы).\n- **Компоненты (Level 3)** — внутриконтейнерная структура: компоненты, их интерфейсы и зависимости.\n- **Код (Level 4)** — детализация на уровне классов (по необходимости).\n\nC4 Model особенно полезен на ранних этапах проектирования, когда важно быстро и понятно донести структуру системы до всех заинтересованных сторон.\n\n#### Статья: «How to Draw a Component Diagram»\n\nВыполняю поиск актуальной статьи по теме...",
      ai_generated: true,
    },
  ],
  assignment: {
    assignment_type: "test",
    title: "Тест по теме: Жизненный цикл программного обеспечения",
    max_score: 3,
    passing_score: 2,
    questions: [
      {
        text: "Опишите основные этапы жизненного цикла программного обеспечения (ЖЦ ПО) и кратко объясните, какая цель преследуется на каждом из них. Какие последствия могут быть, если пропустить один из этапов, например, этап тестирования?",
        options: [
          "Пропуск этапа тестирования не влияет на качество ПО, если разработчики опытные",
          "Пропуск тестирования может привести к выходу ПО с критическими ошибками, что повлияет на репутацию и безопасность",
          "Тестирование можно заменить этапом проектирования",
        ],
        correct_answers: [1],
        points: 1,
      },
      {
        text: "В чём принципиальное различие между программированием и инженерией программного обеспечения? Приведите пример, когда простое программирование может оказаться недостаточным, и объясните, почему в этом случае требуется именно инженерный подход.",
        options: [
          "Программирование — это написание кода, а инженерия ПО — только управление командой разработчиков",
          "Инженерия ПО включает в себя только тестирование и документирование, а программирование — это реализация",
          "Инженерия ПО — это системный подход, включающий планирование, анализ требований, проектирование, тестирование и сопровождение, тогда как программирование — лишь часть этого процесса",
        ],
        correct_answers: [2],
        points: 1,
      },
      {
        text: "Команда разработчиков получила от заказчика описание функциональности нового приложения для учёта рабочего времени. Сейчас они анализируют, какие именно данные нужно собирать, как пользователи будут взаимодействовать с системой, какие ограничения существуют (например, интеграция с существующими системами). На каком этапе жизненного цикла ПО находится проект? Обоснуйте свой ответ.",
        options: [
          "Этап программирования",
          "Этап сопровождения",
          "Этап анализа требований",
        ],
        correct_answers: [2],
        points: 1,
      },
    ],
    version: 0,
  },
};
renderModule(data);
